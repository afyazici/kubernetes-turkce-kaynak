<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Boxicons CSS -->
  <link href="https://unpkg.com/boxicons@2.1.0/css/boxicons.min.css" rel="stylesheet" />
  <title>Kubernetes TR</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <!-- navbar -->
  <nav class="navbar">
    <div class="logo_item">
      <i class="bx bx-menu" id="sidebarOpen"></i>
      <img src="images/logo.png" alt=""></img>KubernetesTR
    </div>

    <div class="navbar_content">
      <i class="bi bi-grid"></i>
      <i class='bx bx-sun' id="darkLight"></i>
      <a href="https://github.com/afyazici" class="nav_link submenu_item"><img src="images/profile.jpeg" alt="" class="profile"/></a>
    </div>
  </nav>

  <!-- sidebar -->
  <nav class="sidebar">
    <div class="menu_content">
      <ul class="menu_items">
        <div class="menu_title menu_dahsboard"></div>
        <!-- duplicate or remove this li tag if you want to add or remove navlink with submenu -->
        <!-- start -->

        <li class="item">
          <a href="#kubernetes-nedir" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/logo.png" alt="Logo">
            </span>
            <span class="navlink">1) Kubernetes Nedir?</span>
          </a>
        </li>


        <li class="item">
          <a href="#kubernetes-avantajlarÄ±" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/pros.png" alt="Logo">
            </span>
            <span class="navlink">2) Kubernetes AvantajlarÄ±?</span>
          </a>
        </li>

        <li class="item">
          <a href="#kubernetes-componentleri" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/component.png" alt="Logo">
            </span>
            <span class="navlink">3) Kubernetes Componentleri</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <a href="#pod" class="nav_link sublink">Pod</a>
            <a href="#service-ve-ingress" class="nav_link sublink">Service ve Ingress</a>
            <a href="#configmap-ve-secret" class="nav_link sublink">ConfigMap ve Secret</a>
            <a href="#volumes" class="nav_link sublink">Volumes</a>
            <a href="#deployment-ve-statefulset" class="nav_link sublink">Deployment ve StatefulSet</a>
          </ul>
        </li>

        <li class="item">
          <a href="#kubernetes-mimarisi" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/arch.png" alt="Logo">
            </span>
            <span class="navlink">4) Kubernetes Mimarisi</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#node-process" class="nav_link sublink">a) Node Process</a></li>
            <li><a href="#master-node" class="nav_link sublink">b) Master Node</a></li>
          </ul>
        </li>

        <li class="item">
          <a href="#cluster-yapÄ±sÄ±" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/cluster.png" alt="Logo">
            </span>
            <span class="navlink">5) Cluster YapÄ±sÄ±</span>
          </a>
        </li>

        <li class="item">
          <a href="#minikube-ve-kubectl-kurulumu" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/minikube.png" alt="Logo">
            </span>
            <span class="navlink">6) Minikube ve Kubectl</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#minikube" class="nav_link sublink">a) Minikube</a></li>
            <li><a href="#kubectl" class="nav_link sublink">b) Kubectl</a></li>
            <li><a href="#kurulum" class="nav_link sublink">c) Kurulum</a></li>
          </ul>
        </li>

        <li class="item">
          <a href="#ilk-cluster" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/first.png" alt="Logo">
            </span>
            <span class="navlink">7) Ä°lk Cluster</span>
          </a>
        </li>

        <li class="item">
          <a href="#main-kubectl-komutlarÄ±" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/commands.png" alt="Logo">
            </span>
            <span class="navlink">8) Main Kubectl KomutlarÄ±</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#layerlarÄ±n-Ã§alÄ±ÅŸma-ÅŸekli" class="nav_link sublink">a) LayerlarÄ±n Ã‡alÄ±ÅŸma Åekli</a></li>
            <li><a href="#debugging-pods" class="nav_link sublink">b) Debugging Pods</a></li>
            <li><a href="#deployment-silme-ve-apply-configuration-file" class="nav_link sublink">c) Deployment Silme ve Apply Configuration File</a></li>
            <li><a href="#kubectl-apply" class="nav_link sublink">d) Kubectl Apply</a></li>
          </ul>
        </li>

        <li class="item">
          <a href="#kubernetes-yaml-konfigÃ¼rasyonu" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/yal.png" alt="Logo">
            </span>
            <span class="navlink">9) YAML KonfigÃ¼rasyonu</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#parÃ§ada-k8s-config-dosyasÄ±" class="nav_link sublink">a) 3 ParÃ§ada K8s Config DosyasÄ±</a></li>
            <li><a href="#config-dosyasÄ±nÄ±n-formatÄ±" class="nav_link sublink">b) Config DosyasÄ±nÄ±n FormatÄ±</a></li>
            <li><a href="#podlar-iÃ§in-blueprint-template" class="nav_link sublink">c) Podlar iÃ§in Blueprint (Template)</a></li>
            <li><a href="#connecting-components-labels-selectors-ports" class="nav_link sublink">d) Connecting Components Labels - Selectors - Ports</a></li>
          </ul>
        </li>

        <li class="item">
          <a href="#ilk-demo-uygulama" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/first.png" alt="Logo">
            </span>
            <span class="navlink">10) Ä°lk Demo Uygulama</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#mongodb-pod" class="nav_link sublink">a) MongoDB Pod</a></li>
            <li><a href="#secret-ve-referans" class="nav_link sublink">b) Secret ve Referans</a></li>
            <li><a href="#mongodb-internal-service" class="nav_link sublink">c) MongoDB Internal Service</a></li>
            <li><a href="#mongo-express-deployment-service-configmap" class="nav_link sublink">d) Mongo Express Deployment & Service & ConfigMap</a></li>
            <li><a href="#mongo-express-external-service" class="nav_link sublink">e) Mongo Express External Service</a></li>
          </ul>
        </li>


        <li class="item">
          <a href="#kubernetes-namespaces" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/ns.png" alt="Logo">
            </span>
            <span class="navlink">11) Kubernetes Namespaces</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#namespace-nedir" class="nav_link sublink">a) Namespace Nedir</a></li>
            <li><a href="#default-namespaces" class="nav_link sublink">b) Default Namespaces</a></li>
            <li><a href="#ne-zaman-nasÄ±l-namespace-oluÅŸturmalÄ±" class="nav_link sublink">c) Ne Zaman & NasÄ±l Namespace OluÅŸturmalÄ±</a></li>
            <li><a href="#namespaces-Ã¶zellikleri" class="nav_link sublink">d) Namespaces Ã–zellikleri</a></li>
            <li><a href="#namespaces-component-oluÅŸturma" class="nav_link sublink">e) Namespaces Component OLuÅŸturma</a></li>
          </ul>
        </li>


        <li class="item">
          <a href="#kubernetes-ingress-explained" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/ingress.png" alt="Logo">
            </span>
            <span class="navlink">12) Kubernetes Ingress</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#external-service-vs-ingress" class="nav_link sublink">a) External Service vs Ingress</a></li>
            <li><a href="#ingress-konfigÃ¼rasyonu" class="nav_link sublink">b) Ingress KonfigÃ¼rasyon</a></li>
            <li><a href="#ingress-controller" class="nav_link sublink">c) Ingress Controller</a></li>
            <li><a href="#minikube-ingress-konfigÃ¼rasyonu" class="nav_link sublink">d) Minikube Ingress KonfigÃ¼rasyonu</a></li>
            <li><a href="#ingress-default-backend" class="nav_link sublink">e) Ingress Default Backend</a></li>
          </ul>
        </li>













        <!-- end -->
      </ul>


      <!-- Sidebar Open / Close -->
      <div class="bottom_content">
        <div class="bottom expand_sidebar">
          <span> Ä°yi Okumalar!</span>
        </div>
      </div>
    </div>
  </nav>
  <!-- JavaScript -->
  <script src="script.js"></script>

  <!-- Metinlerin olduÄŸu kÄ±sÄ±m -->
  <div class="content">


    <h1 id="kubernetes-tÃ¼rkÃ§e-dÃ¶kÃ¼man">Kubernetes TÃ¼rkÃ§e DÃ¶kÃ¼man â˜¸ï¸â˜¸ğŸ³ğŸ‘¨â€ğŸ’»</h1>
    <hr /><br>
    <p><img src="images/header.png" /></p>
    <hr />
    <ul>
    </ul>
    <hr />
    <h2 id="kubernetes-nedir">Kubernetes Nedir?</h2>
    <ul>
    <li><strong>Kubernetes</strong>, aÃ§Ä±k kaynaklÄ± bir konteyner yÃ¶netim aracÄ±dÄ±r.</li>
    <li>Google tarafÄ±ndan geliÅŸtirilmiÅŸtir.</li>
    <li>FarklÄ± daÄŸÄ±tÄ±m ortamlarÄ±nda konteynerleÅŸtirilmiÅŸ uygulamalarÄ± yÃ¶netmenize yardÄ±mcÄ± olur.
    <ul>
    <li>fiziksel ortamda</li>
    <li>sanal ortamda</li>
    <li>bulut ortamÄ±nda</li>
    </ul></li>
    </ul>
    <hr />
    <h2 id="kubernetes-avantajlarÄ±">Kubernetes AvantajlarÄ±:</h2>
    <ul>
    <li><strong>YÃ¼ksek eriÅŸilebilirlik</strong> veya kesintisiz Ã§alÄ±ÅŸma</li>
    <li><strong>Ã–lÃ§eklenebilirlik</strong> veya yÃ¼ksek performans</li>
    <li><strong>Afet kurtarma</strong> - yedekleme ve geri yÃ¼kleme</li>
    </ul>
    <hr />
    <h2 id="kubernetes-componentleri">Kubernetes Componentleri</h2>
    <h3 id="pod">Pod</h3>
    <ul>
    <li>Pod Kubernetesâ€™in en kÃ¼Ã§Ã¼k birimidir.</li>
    <li>Konteyner Ã¼zerinde sanallaÅŸtÄ±rma yapar. (abstraction)</li>
    </ul>
    <p><img src="images/1.png" /></p>
    <ul>
    <li>Bizler yalnÄ±zca Kubernetes katmanÄ±yla etkileÅŸime geÃ§eriz.</li>
    <li>Bir pod iÃ§inde birden fazla konteyner Ã§alÄ±ÅŸtÄ±rabiliriz, ancak genellikle bir pod baÅŸÄ±na bir uygulama bulunur.</li>
    <li>Her pod kendi IP adresine sahiptir. Her pod, birbirleriyle bu internal IP adresini kullanarak iletiÅŸim kurabilir.</li>
    </ul>
    <p>Ancak, Kubernetesâ€™teki pod bileÅŸenleri de geÃ§icidir: yani Ã§ok kolay bir ÅŸekilde Ã¶lebilirler. Ã–rneÄŸin, bir veritabanÄ± konteynerÄ±nÄ± kaybettiÄŸimizi dÃ¼ÅŸÃ¼nelim (konteyner iÃ§indeki uygulama Ã§Ã¶ktÃ¼ÄŸÃ¼ veya sunucu kaynaklarÄ± tÃ¼kendiÄŸi iÃ§in pod Ã¶lÃ¼r ve yerine yeni bir tane oluÅŸturulur). Bu durumda da yeni bir IP adresi atanÄ±r. VeritabanÄ±yla IP adresini kullanarak iletiÅŸim kuruyorsak elbette sakÄ±ncalÄ±dÄ±r. Her pod yeniden baÅŸladÄ±ÄŸÄ±nda, iletiÅŸimi her seferinde yeniden ayarlamamÄ±z gerekir. Bu nedenle, podâ€™un yeniden baÅŸladÄ±ÄŸÄ±nda IP adresini ayarlamamÄ±za gerek kalmadan, veritabanÄ±yla iletiÅŸim kurmanÄ±zÄ± saÄŸlayan baÅŸka bir Kubernetes bileÅŸeni olan <code>Service</code> kullanÄ±lÄ±r.</p>
    <h3 id="service-ve-ingress">Service ve Ingress</h3>
    <ul>
    <li>Service, her podâ€™a baÄŸlanabilen sabit bir IP adresidir. UygulamamÄ±zÄ±n kendi servisi olacak ve veritabanÄ± podâ€™u kendi servisine sahip olacak. Buradaki gÃ¼zel ÅŸey, servis ve Podâ€™un yaÅŸam dÃ¶ngÃ¼leri birbirine baÄŸlÄ± deÄŸil. Bu yÃ¼zden Pod Ã¶lse bile servis ve bu servise ait IP adresi kalÄ±r. Bu ÅŸekilde endpointâ€™i deÄŸiÅŸtirmemize gerek yoktur.</li>
    </ul>
    <p><img src="images/2.png" /></p>
    <ul>
    <li>Tabii ki, uygulamamÄ±zÄ±n bir tarayÄ±cÄ± aracÄ±lÄ±ÄŸÄ±yla eriÅŸilebilir olmasÄ±nÄ± isteriz deÄŸil mi? Bunun iÃ§in bir external service oluÅŸturmamÄ±z gerekiyor. <code>External Service</code>, dÄ±ÅŸ kaynaklardan iletiÅŸimi aÃ§an bir servistir. Ancak, veritabanÄ±mÄ±zÄ± halka aÃ§Ä±k isteklere aÃ§mak istemeyiz. Bunun iÃ§in <code>Internal Service</code> adÄ±nÄ± verdiÄŸimiz bir ÅŸey oluÅŸtururuz.</li>
    </ul>
    <p><img src="images/3.png" /></p>
    <ul>
    <li>External Service URLâ€™sinin Ã§ok pratik olmadÄ±ÄŸÄ±nÄ± fark ettik deÄŸil mi? Temelde, bir HTTP protokolÃ¼yle bir node IP adresi ve servis port numarasÄ±na sahibiz. Bu hÄ±zlÄ± bir ÅŸekilde bir ÅŸeyleri test etmek istiyorsak iyidir, ancak end-product iÃ§in iyi deÄŸildir. Genellikle, uygulamamÄ±zla gÃ¼venli bir protokol ve bir alan adÄ± kullanmak isteriz.</li>
    </ul>
    <p><img src="images/4.png" /></p>
    <p>Bunun iÃ§in Kubernetesâ€™in baÅŸka bir bileÅŸeni olan <code>Ingress</code> var. Bu ÅŸekilde, istek Ã¶nce servise deÄŸil, Ingressâ€™e gider ve oradan servise yÃ¶nlendirilir.</p>
    <p><img src="images/5.png" /></p>
    <h3 id="configmap-ve-secret">ConfigMap ve Secret</h3>
    <p>Podâ€™lar birbirleriyle servis aracÄ±lÄ±ÄŸÄ±yla iletiÅŸim kurar. UygulamamÄ±zÄ±n, veritabanÄ± ile iletiÅŸim kurmak iÃ§in kullandÄ±ÄŸÄ± bir database endpoint <code>Ã¶rneÄŸin mongodb servisi</code> olacak. Ancak bu veritabanÄ± URLâ€™sini (ya da endpoint) genellikle nerede yapÄ±landÄ±rÄ±rÄ±z?</p>
    <p><img src="images/6.png" /></p>
    <p>Genellikle bunu application properties file veya bazÄ± external environmental variable olarak yaparÄ±z, ancak genellikle yapÄ±landÄ±rma, uygulamanÄ±n iÃ§erisindeki built imageâ€™tedir.</p>
    <p>Ã–rneÄŸin, service endpoint (ya da service name) â€˜mongodbâ€™ olarak deÄŸiÅŸirse, uygulamadaki bu URLâ€™i ayarlamalÄ±yÄ±z. Genellikle yeni bir sÃ¼rÃ¼mle uygulamayÄ± rebuild etmemiz ve repoya pushlamamÄ±z gerekir. ArdÄ±ndan bu yeni imageâ€™i podâ€™umuzda pullâ€™layÄ±p tÃ¼m uygulamayÄ± yeniden baÅŸlatmamÄ±z gerekebilir.</p>
    <p><img src="images/7.png" /></p>
    <p>VeritabanÄ± URLâ€™i gibi kÃ¼Ã§Ã¼k bir deÄŸiÅŸiklik iÃ§in bu gerÃ§ekten zahmetli. Bu sebeple, Kubernetesâ€™in <code>configmap</code> adÄ±nda bir bileÅŸeni var. YapÄ±sÄ±, uygulamamÄ±za <code>external configuration</code> saÄŸlar. ConfigMap genellikle kullandÄ±ÄŸÄ±mÄ±z veritabanÄ± URLâ€™leri gibi yapÄ±landÄ±rma verilerini iÃ§erir. Kubernetesâ€™te bunu Podâ€™a baÄŸlarÄ±z. Pod, ConfigMapâ€™in iÃ§erdiÄŸi verileri alÄ±r. Ve ÅŸimdi, servis adÄ±nÄ± deÄŸiÅŸtirirsek (service end point), sadece ConfigMapâ€™i ayarlamamÄ±z yeterlidir. Yeni bir image oluÅŸturmamÄ±za ve tÃ¼m dÃ¶ngÃ¼yÃ¼ geÃ§irmemize gerek yoktur. BÃ¼yÃ¼k avantaj!</p>
    <p><img src="images/8.png" /></p>
    <p>Åimdi, external configurationâ€™Ä±n bir parÃ§asÄ± aynÄ± zamanda database kullanÄ±cÄ± adÄ± ve ÅŸifresi olabilir deÄŸil mi? Bu veriler de uygulama daÄŸÄ±tÄ±m sÃ¼recinde deÄŸiÅŸebilir. Ancak, bir ÅŸifreyi veya diÄŸer kimlik bilgilerini dÃ¼z metin formatÄ±nda bir configmapâ€™e koymamÄ±z gÃ¼vensiz olur.</p>
    <blockquote>
    <p><img src="images/9.png" /></p>
    </blockquote>
    <p>Bu amaÃ§la, Kubernetesâ€™in <code>Secret</code> adÄ±nda bir baÅŸka bileÅŸeni daha var. Yani, Secret, ConfigMap gibi, ancak fark ÅŸu ki; ÅŸifre gibi gizli verileri saklamak iÃ§in kullanÄ±lÄ±r. Ve tabii ki, dÃ¼z metin formatÄ±nda deÄŸil, base64 formatÄ±nda kodlanmÄ±ÅŸ olarak saklanÄ±r. Yani, Secret, kullanÄ±cÄ± adlarÄ± gibi kimlik bilgilerini iÃ§erecek ve veritabanÄ± kullanÄ±cÄ±larÄ±nÄ± iÃ§erecektir. ConfigMapâ€™e de koyabiliriz, ancak Ã¶nemli olan ÅŸifreler, sertifikalar, baÅŸkalarÄ±nÄ±n eriÅŸimini istemediÄŸimiz ÅŸeyler Secretâ€™e koyulmalÄ±dÄ±r. AynÄ± ConfigMap gibi, sadece Podâ€™umuza baÄŸlarÄ±z, bÃ¶ylece Pod bu verileri gÃ¶rebilir ve Secretâ€™ten okuyabilir. ConfigMap veya Secretâ€™ten verileri, Ã¶rneÄŸin environment variables olarak veya hatta bir Ã¶zellikler dosyasÄ± olarak uygulamamÄ±zÄ±n iÃ§inde kullanabiliriz.</p>
    <p><img src="images/10.png" /></p>
    <p>AslÄ±nda en Ã§ok kullanÄ±lan Kubernetes temel bileÅŸenlerinin neredeyse tamamÄ±nÄ± gÃ¶rdÃ¼k. Podâ€™a gÃ¶z attÄ±k. Hizmetlerin nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ±, Ingress bileÅŸeninin ne iÅŸe yaradÄ±ÄŸÄ±nÄ± gÃ¶rdÃ¼k ve ayrÄ±ca ConfigMap ve Secretsâ€™Ä± kullanan harici yapÄ±landÄ±rmayÄ± da gÃ¶rdÃ¼k.</p>
    <p><img src="images/11.png" /></p>
    <h3 id="volumes">Volumes</h3>
    <p>SÄ±ra geldi Ã§ok Ã¶nemli bir kavrama. <code>Veri depolama</code> nedir ve Kubernetes iÃ§erisinde nasÄ±l Ã§alÄ±ÅŸÄ±r? UygulamamÄ±zÄ±n kullandÄ±ÄŸÄ± bir database podâ€™umuz ve de bir miktar verimiz var. Åu anda gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z bu kurulumla, eÄŸer veritabanÄ± container veya podâ€™u yeniden baÅŸlatÄ±lÄ±rsa veri kaybolur. Bu aÃ§Ä±kÃ§a sorunlu ve elveriÅŸsizdir Ã§Ã¼nkÃ¼ databaseâ€™deki verilerinizin veya gÃ¼nlÃ¼k verilerinizin uzun sÃ¼reli gÃ¼venilir ve kalÄ±cÄ± olmasÄ±nÄ± isteriz. Bunu Kubernetesâ€™te yapmanÄ±n yolu, Kubernetesâ€™in baÅŸka bir bileÅŸeni olan <code>Volumes</code> kullanmaktÄ±r.</p>
    <p><img src="images/12.png" /></p>
    <p>Ã‡alÄ±ÅŸma ÅŸekli ÅŸÃ¶yledir: Temelde bir fiziksel depolama birimini -yani bir sabit diski- podâ€™umuza baÄŸlarÄ±z. * Bu depolama yerel bir makinede olabilir. * Podâ€™un Ã§alÄ±ÅŸtÄ±ÄŸÄ± aynÄ± sunucu nodeâ€™unda da olabilir. * Kubernetes kÃ¼mesinin dÄ±ÅŸÄ±nda(Bulut depolama, Kubernetes kÃ¼mesinin bir parÃ§asÄ± olmayan kendi yerleÅŸke depolamanÄ±z) olabilir. Bu yÃ¼zden bununla ilgili external reference var.</p>
    <p><img src="images/13.png" /></p>
    <p>BÃ¶ylece, database podâ€™u veya container yeniden baÅŸlatÄ±ldÄ±ÄŸÄ±nda, tÃ¼m veri kalÄ±cÄ± bir ÅŸekilde saklanmÄ±ÅŸ olacaktÄ±r.</p>
    <p>Kubernetes kÃ¼mesi ve tÃ¼m bileÅŸenlerinin ve depolama arasÄ±ndaki farkÄ± anlamamÄ±z Ã¶nemlidir. Yerel veya uzak bir depolama olmasÄ± fark etmeksizin, depolamayÄ± Kubernetes kÃ¼mesine takÄ±lmÄ±ÅŸ harici bir sabit diske benzetebiliriz. Ã‡Ã¼nkÃ¼ buradaki Ã¶nemli nokta; Kubernetes kÃ¼mesi aÃ§Ä±kÃ§a hiÃ§bir veri kalÄ±cÄ±lÄ±ÄŸÄ±nÄ± yÃ¶netmez. Kubernetes kullanÄ±cÄ±sÄ± veya yÃ¶neticisi olarak sizin veriyi yedeklemenizden, Ã§oÄŸaltmanÄ±zdan, yÃ¶netmenizden ve uygun donanÄ±mda saklamanÄ±zdan emin olmanÄ±z gerektiÄŸi anlamÄ±na gelir.</p>
    <h3 id="deployment-ve-statefulset">Deployment ve StatefulSet</h3>
    <p>Åimdi, her ÅŸey mÃ¼kemmel bir ÅŸekilde Ã§alÄ±ÅŸÄ±yor ve bir kullanÄ±cÄ± bir tarayÄ±cÄ± aracÄ±lÄ±ÄŸÄ±yla uygulamaya eriÅŸebiliyor. Bu kurulumla, application podâ€™u Ã¶lÃ¼rse, crashlerse veya yeni bir container image oluÅŸturduÄŸumuz iÃ§in podâ€™u restart etmemiz gerekiyorsa ne olurdu? BasitÃ§e cevap verecek olursak, bir kullanÄ±cÄ±nÄ±n uygulamamÄ±za ulaÅŸamadÄ±ÄŸÄ± bir sÃ¼re olan bir kesintimiz olurdu. BÃ¶yle bir durum end productâ€™ta gerÃ§ekleÅŸmesi Ã§ok kÃ¶tÃ¼ bir durumdur.</p>
    <p><img src="images/14.png" /></p>
    <p>Distributed systems ve konteynerlarÄ±n avantajÄ± tam olarak budur. YalnÄ±zca 1 application podâ€™u ve 1 database podâ€™u gibi bir ÅŸeye gÃ¼venmek yerine, her ÅŸeyi birden fazla sunucuda replikasÄ±nÄ± oluÅŸturuyoruz. Yani uygulamamÄ±zÄ±n bir klonu veya Ã§oÄŸaltmasÄ± Ã§alÄ±ÅŸacaÄŸÄ± baÅŸka bir node olacak ve bu da servise baÄŸlÄ± olacak. HatÄ±rlarsak servisin, bir pod Ã¶ldÃ¼ÄŸÃ¼nde end pointâ€™i sÃ¼rekli ayarlamamÄ±za gerek olmadÄ±ÄŸÄ±, kalÄ±cÄ± statik IP adresi ve bir DNS adÄ±na sahip olduÄŸunu sÃ¶ylemiÅŸtik.</p>
    <ul>
    <li>Service aynÄ± zamanda bir <code>load balancer</code>dÄ±r. Yani, servis isteÄŸi yakalayacak ve en az meÅŸgul olan podâ€™a yÃ¶nlendirecektir.</li>
    </ul>
    <p>Ancak application podâ€™unun ikinci replikasÄ±nÄ± oluÅŸturmak iÃ§in ikinci bir pod oluÅŸturmayÄ±z. Bunun yerine uygulama podâ€™umuzun bir blueprintâ€™ini tanÄ±mlarÄ±z ve o podâ€™un kaÃ§ tane replikasÄ±nÄ±n olmasÄ±nÄ± istediÄŸimizi belirtiriz. Ve bu component veya blueprintâ€™e <code>deployment</code> denir. Deployment, Kubernetesâ€™in baÅŸka bir componentidir. Pratikte, podâ€™larla Ã§alÄ±ÅŸmayÄ±z veya podâ€™lar oluÅŸturmayÄ±z. Ã‡Ã¼nkÃ¼ zaten kaÃ§ tane replika olacaÄŸÄ±nÄ± belirtebilir ve ihtiyacÄ±mÄ±z olan podâ€™larÄ±n replika sayÄ±sÄ±nÄ± artÄ±rabilir veya azaltabiliriz. Yani pod, containerâ€™larÄ±n Ã¼zerinde bir soyutlama katmanÄ±dÄ±r(layer of abstraction). Deployment ise, podlarÄ±n Ã¼zerinde baÅŸka bir soyutlama katmanÄ±dÄ±r(layer of abstraction). Bu durum; podâ€™larla etkileÅŸimi, kopyalama ve diÄŸer yapÄ±landÄ±rmalarÄ± daha kullanÄ±ÅŸlÄ± hale getirir.</p>
    <p><img src="images/15.png" /></p>
    <p>Yani sonuÃ§ olarak Ã§oÄŸunlukla podâ€™larla deÄŸil, deploymentâ€™larla Ã§alÄ±ÅŸÄ±rÄ±z. Uygulama podâ€™umuzun replikalarÄ±ndan biri Ã¶lÃ¼rse, servis istekleri baÅŸka bir replikaya yÃ¶nlendirilecektir, bu ÅŸekilde uygulamamÄ±z kullanÄ±cÄ±lar iÃ§in hala eriÅŸilebilir olacaktÄ±r.</p>
    <p><img src="images/16.png" /></p>
    <p>Åimdi muhtemelen ÅŸunu merak ediyoruzdur, database podâ€™u ne olacak? Ã‡Ã¼nkÃ¼ eÄŸer database podâ€™u Ã¶lÃ¼rse, uygulamanÄ±z da eriÅŸilemez olacaktÄ±r. Bu yÃ¼zden, bir database replikasÄ±na da ihtiyacÄ±mÄ±z var. Ancak, <code>deployment kullanarak bir databese'i kopyalayamayÄ±z</code>. Bunun nedeni, databaseâ€™in bir stateâ€™i olmasÄ±dÄ±r, yani veridir. Bu da demektir ki eÄŸer databaseâ€™in replikalarÄ± veya klonlarÄ± olsaydÄ±, hepsi aynÄ± paylaÅŸÄ±lan data storage volumeâ€™Ã¼ne eriÅŸmek zorunda kalacaktÄ±. Bu durumda da, hangi podâ€™larÄ±n anlÄ±k olarak depolama birimine yazdÄ±ÄŸÄ±nÄ± veya hangi podâ€™larÄ±n depolama biriminden okuduÄŸunu yÃ¶neten bir mekanizmaya ihtiyacÄ±mÄ±z olacaktÄ±.</p>
    <p>Bu mekanizma, Ã§oÄŸaltma Ã¶zelliklerinin yanÄ± sÄ±ra baÅŸka bir Kubernetes componenti olan <code>StatefulSet</code> ile saÄŸlanÄ±r.</p>
    <p><img src="images/17.png" /></p>
    <p>Bu component Ã¶zellikle database gibi uygulamalar iÃ§in tasarlanmÄ±ÅŸtÄ±r. Yani, MySQL, MongoDB, Elasticsearch veya herhangi bir diÄŸer stateful applications veya databaseleri; deployments yerine <code>StatefulSets</code> kullanÄ±larak oluÅŸturulmalÄ±dÄ±r. Bu Ã§ok Ã¶nemli bir ayrÄ±mdÄ±r. StatefulSet, aynÄ± deployment gibi, podâ€™larÄ± replikalamayÄ± yapar ve bunlarÄ± scalingâ€™e alÄ±r. Database reading ve writing iÅŸlemlerinin senkronize olduÄŸundan emin olur, bÃ¶ylece database tutarsÄ±zlÄ±klarÄ± olmaz.</p>
    <p><img src="images/18.png" /></p>
    <blockquote>
    <p> Ancak, bir Kubernetes kÃ¼mesinde StatefulSets kullanarak database uygulamalarÄ±nÄ± deploy etmek biraz zahmetli olabilir. Bu yÃ¼zden, database uygulamalarÄ±nÄ± Kubernetes kÃ¼mesinin dÄ±ÅŸÄ±nda barÄ±ndÄ±rmak ve yalnÄ±zca daÄŸÄ±tÄ±mlarÄ± veya durumsuz uygulamalarÄ± Kubernetes kÃ¼mesinin iÃ§inde sorunsuz bir ÅŸekilde Ã§oÄŸaltmak ve Ã¶lÃ§eklendirmek ve dÄ±ÅŸ database ile iletiÅŸim kurmak yaygÄ±n bir uygulamadÄ±r.</p>
    </blockquote>
    <p>Åimdi, uygulama podâ€™umuzun iki replikasÄ± ve databaseâ€™in iki kopyasÄ± olduÄŸunda ve hepsi load-balanced olduÄŸunda, kurulumumuz daha gÃ¼venlidir. Bu senaryoda eÄŸer Node 1 yeniden baÅŸlatÄ±lsaydÄ± veya Ã§Ã¶kseydi, hala uygulama ve database podâ€™larÄ±nÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ± ikinci bir nodeâ€™umuz olurdu. Uygulama, bu iki replikadan yeniden oluÅŸturulana kadar kullanÄ±cÄ± tarafÄ±ndan eriÅŸilebilir olacaktÄ±r, bu yÃ¼zden kesintiyi Ã¶nlemiÅŸ oluruz.</p>
    <p><img src="images/19.png" /></p>
    <p>Ã–zetlemek gerekirse, en Ã§ok kullanÄ±lan Kubernetes bileÅŸenlerini inceledik. ParÃ§alar arasÄ±nda iletiÅŸim kurmak iÃ§in <code>pod</code>lar ve <code>servis</code>lerle baÅŸladÄ±k, ve trafiÄŸi clusterlara yÃ¶nlendirmek iÃ§in kullanÄ±lan <code>Ingress</code> bileÅŸenini inceledik. AyrÄ±ca, <code>ConfigMaps</code> ve <code>Secret</code> kullanarak external configuration, ve <code>Volumes</code> kullanarak veri kalÄ±cÄ±lÄ±ÄŸÄ±nÄ± inceledik. Ve son olarak, <code>Deployments</code> ve <code>StatefulSets</code> gibi replicating ve blueprintlere baktÄ±k.</p>
    <p>Burada <code>stateful applications</code> Ã¶zellikle databaseler gibi stateful applications iÃ§in kullanÄ±lÄ±r. Ve evet, Kubernetesâ€™in sunduÄŸu Ã§ok daha fazla bileÅŸen var, ama bunlar Ã§ekirdek, temel olanlarÄ±. Bu temel bileÅŸenleri kullanarak oldukÃ§a gÃ¼Ã§lÃ¼ Kubernetes kÃ¼mesi oluÅŸturabiliriz.</p>
    <hr />
    <h2 id="kubernetes-mimarisi">Kubernetes Mimarisi</h2>
    <p>Kubernetesâ€™in temel mimarisinden bahsedeceÄŸiz. Bu yÃ¼zden Kubernetesâ€™in Ã§alÄ±ÅŸtÄ±ÄŸÄ± iki tÃ¼r nodeâ€™u inceleyeceÄŸiz: biri <code>master</code> diÄŸeri ise <code>slave</code>. BunlarÄ±n arasÄ±ndaki fark nedir ve her birinin cluster iÃ§indeki rolÃ¼ nedir, onlara bakacaÄŸÄ±z.</p>
    <p>Kubernetesâ€™in ne yaptÄ±ÄŸÄ±nÄ± ve clusterâ€™Ä±n nasÄ±l self-managed, self-healing ve automated olduÄŸunu gÃ¶steren temel kavramlarÄ± ele alacaÄŸÄ±z. Bir Kubernetes cluster operatÃ¶rÃ¼ olarak, Ã§ok daha az manuel Ã§aba harcamamÄ±z gerektiÄŸini gÃ¶receÄŸiz.</p>
    <h3 id="node-process">Node Process</h3>
    <p>Ä°ki application podâ€™unun Ã§alÄ±ÅŸtÄ±ÄŸÄ± tek bir node ile bu temel kurulumla baÅŸlayacaÄŸÄ±z. Kubernetes mimarisinin ana bileÅŸenlerinden biri worker servers veya nodeâ€™dur. Her node, o nodeâ€™da Ã§alÄ±ÅŸan birden fazla application podâ€™una sahip olacaktÄ±r.</p>
    <p>Ve Kubernetesâ€™in bunu yapma ÅŸekli, her nodeâ€™da bulunmasÄ± gereken ve bu podâ€™larÄ± planlamak ve yÃ¶netmek iÃ§in kullanÄ±lan <code>three process</code> kullanmasÄ±dÄ±r. Yani nodeâ€™lar, asÄ±l iÅŸi yapan cluster serverlardÄ±r. Bu yÃ¼zden bazen onlara worker nodes da denir.</p>
    <h4 id="container-runtime">1) Container Runtime</h4>
    <p>Her nodeâ€™da Ã§alÄ±ÅŸmasÄ± gereken ilk sÃ¼reÃ§, <code>container runtime</code>dÄ±r. Biz Docker ile iÅŸlem yapacaÄŸÄ±z, ancak baÅŸka bir teknoloji de olabilir. Applitacion podâ€™larÄ±nda iÃ§inde Ã§alÄ±ÅŸan containerlar olduÄŸu iÃ§in, her nodeâ€™da bir <code>container runtime</code> kurulmalÄ±dÄ±r.</p>
    <h4 id="kubelet">2) Kubelet</h4>
    <p>Kubernetesâ€™in bir parÃ§asÄ± olan kubelet, Podâ€™larÄ± ve bu Podâ€™larÄ±n altÄ±ndaki containerâ€™larÄ± schedule eder. Container Runtime, nodeâ€™un kendisiyle arayÃ¼z oluÅŸtururken, kubelet bu yapÄ±landÄ±rmayÄ± alÄ±r, bir podâ€™u Ã§alÄ±ÅŸtÄ±rÄ±r (veya iÃ§inde bir container baÅŸlatÄ±r) ve ardÄ±ndan o nodeâ€™dan containerâ€™a CPU, RAM gibi depolama kaynaklarÄ± atar.</p>
    <p>Bu nedenle, genellikle bir Kubernetes cluster kurulu olmalÄ±dÄ±r. Kubelet hizmetlerine sahip birden fazla nodeâ€™dan oluÅŸur. Bu worker nodeâ€™larÄ±, Ã–rneÄŸimizdeki application ve database podâ€™larÄ±nÄ±n replikalarÄ±nÄ± Ã§alÄ±ÅŸtÄ±racak yÃ¼zlerce diÄŸer nodeâ€™u Ã§alÄ±ÅŸtÄ±rÄ±r.</p>
    <p>AralarÄ±ndaki iletiÅŸim ÅŸekli, <code>servisler</code> ile olur, bu da isteÄŸi application parÃ§asÄ±na veya Ã¶rneÄŸin bir databaseâ€™e yÃ¶nlendiren bir <code>load-balancer</code> gibi Ã§alÄ±ÅŸÄ±r ve ardÄ±ndan ilgili parÃ§aya yÃ¶nlendirir.</p>
    <h4 id="kube-proxy">3) Kube Proxy</h4>
    <p>Hizmetlerden podâ€™lara istekleri iletmekten sorumlu Ã¼Ã§Ã¼ncÃ¼ sÃ¼reÃ§ <code>kube-proxy</code>dir ve her nodeâ€™da kurulmalÄ±dÄ±r. Kube-proxy, dÃ¼ÅŸÃ¼k bir iÅŸlem yÃ¼kÃ¼ ile performanslÄ± bir ÅŸekilde iletiÅŸim kurulmasÄ±nÄ± saÄŸlayan akÄ±llÄ± yÃ¶nlendirme mantÄ±ÄŸÄ±na sahiptir.</p>
    <p>Bir uygulama veya bu uygulamanÄ±n replikasÄ±, bir databaseâ€™e istek yapÄ±yorsa, hizmet sadece isteÄŸi rastgele bir replikaya yÃ¶nlendirmek yerine; isteÄŸi baÅŸlatan podâ€™un Ã§alÄ±ÅŸtÄ±ÄŸÄ± aynÄ± nodeâ€™da Ã§alÄ±ÅŸan replikaya yÃ¶nlendirecektir. Bu ÅŸekilde, isteÄŸi baÅŸka bir makineye gÃ¶ndermekle ilgili <code>aÄŸ iÅŸlem yÃ¼kÃ¼nden</code> kaÃ§Ä±nÄ±lmÄ±ÅŸ olur.</p>
    <p>Ã–zetlemek gerekirse; bir kubernetes clusterâ€™Ä±nÄ±n dÃ¼zgÃ¼n Ã§alÄ±ÅŸabilmesi iÃ§in <code>kubelet</code> ve <code>kube-proxy</code> her worker node iÃ§erisine <code>container runtime</code> ile birlikte kurulmalÄ±dÄ±r.</p>
    <p><img src="images/20.png" /></p>
    <p>Ancak ÅŸimdi soru ÅŸu: Bu cluster ile nasÄ±l etkileÅŸime girilir? Yeni bir application podâ€™u veya database podâ€™u nerede schedule edilmeli? Bir replika podâ€™u Ã¶lÃ¼rse, hangi process monitoring, reschedule veya restart iÅŸlemleri ile ilgilenir?</p>
    <h3 id="master-node">Master Node</h3>
    <p>Master servers(master nodes), iÃ§erisinde tamamen farklÄ± processler Ã§alÄ±ÅŸtÄ±rÄ±r. Ve bunlar, cluster state ve worker nodesâ€™larÄ± kontrol eden, <code>her yÃ¶netici dÃ¼ÄŸÃ¼mÃ¼nde Ã§alÄ±ÅŸan dÃ¶rt sÃ¼reÃ§tir</code>.</p>
    <h4 id="api-server">1) API Server</h4>
    <p>Ä°lk hizmetimiz API server. Bir Kubernetes clusterâ€™Ä±nda yeni bir application deploy etmek istediÄŸinizde, bir kullanÄ±cÄ± olarak API server ile interact ederiz. Bir Kubernetes Dashboard gibi bir kullanÄ±cÄ± arayÃ¼zÃ¼ de olabilir, <code>kubectl</code> gibi bir command-line tool veya bir Kubernetes APIâ€™si de olabilir.</p>
    <p>API sunucusu, cluster iÃ§ine herhangi bir gÃ¼ncelleme talebinin veya hatta clusterdan gelen sorgularÄ±n ilk isteÄŸini alÄ±r. Kimlik doÄŸrulamasÄ±(auth) yaparak, yalnÄ±zca kimliÄŸi doÄŸrulanmÄ±ÅŸ ve yetkilendirilmiÅŸ isteklerin clusterlara iletilmesini saÄŸlar.</p>
    <p><img src="images/21.png" /></p>
    <p>Bu, yeni podâ€™lar planlamak, yeni applications deploy etmek, yeni servisler oluÅŸturmak veya herhangi bir component oluÅŸturmak istediÄŸimizde, bu requestimizi master node API sunucusuna iletmek zorunda olduÄŸunuz anlamÄ±na gelir. API server daha sonra requestimizi doÄŸrular. Her ÅŸey yolundaysa, requestimizi diÄŸer sÃ¼reÃ§lere ileterek istediÄŸimiz podâ€™u veya bileÅŸeni schedule iÃ§in bir nodeâ€™a yÃ¶nlendirir.</p>
    <p><img src="images/22.png" /></p>
    <p>AyrÄ±ca, daÄŸÄ±tÄ±mÄ±mÄ±zÄ±n durumu veya cluster health etc., gibi sorgu isteklerini yapmak isteyebiliriz. Bu sorgular API sunucusuna bir istek gÃ¶nderir ve o da bize yanÄ±t verir.</p>
    <blockquote>
      <div class="note">
    <p><strong>NOT:</strong> Bu durum gÃ¼venlik aÃ§Ä±sÄ±ndan gayet iyidir Ã§Ã¼nkÃ¼ clusterlara yalnÄ±zca <code>bir entry point</code> vardÄ±r.</p>
  </div>
    </blockquote>
    <h4 id="scheduler">2) Scheduler</h4>
    <p>BaÅŸka bir Master process ise Schedulerâ€™dÄ±r. API serverÄ±na yeni bir pod schedule isteÄŸi gÃ¶nderdiÄŸimizi varsayalÄ±m. API server bu isteÄŸimizi doÄŸruladÄ±ktan sonra, bu podâ€™un bir worker nodeâ€™da baÅŸlatÄ±lmasÄ± iÃ§in <code>Scheduler</code>â€™a teslim eder.</p>
    <p>Ve tabii ki, herhangi bir nodeâ€™a rastgele atamak yerine, Scheduler, bir sonraki podâ€™un hangi belirli worker nodeâ€™un scheduled olacaÄŸÄ± konusunda zekice bir ÅŸekilde karar vermektedir. Ä°lk olarak, isteÄŸimizi kontrol eder ve planlamak istediÄŸimiz uygulamanÄ±n ne kadar kaynaÄŸa ihtiyacÄ± olduÄŸunu kontrol eder. Ne kadar CPU, ne kadar RAM vb.</p>
    <p>ArdÄ±ndan, worker nodeâ€™daki kullanÄ±labilir kaynaklarÄ± kontrol eder. EÄŸer bir nodeâ€™un en Ã§ok kaynaÄŸa sahip olduÄŸunu sÃ¶ylÃ¼yorsa, yeni podâ€™u o nodeâ€™a schedule eder.</p>
    <p><img src="images/23.png" /></p>
    <p>Ã–nemli bir nokta ÅŸu ki, scheduler sadece yeni bir podâ€™un hangi nodeâ€™a schedule edileceÄŸine karar verir. AsÄ±l planlamayÄ± yapan ve podâ€™u konteynerla baÅŸlatan iÅŸlem ise <code>kubelet</code>â€™tir. Yani kubelet, schedulerâ€™dan gelen isteÄŸi alÄ±r ve bu isteÄŸi ilgili node Ã¼zerinde yÃ¼rÃ¼tÃ¼r.</p>
    <h4 id="controller-manager">3) Controller Manager</h4>
    <p>Bir sonraki Ã¶nemli bileÅŸen ise <code>controller manager</code>â€™dÄ±r. Bu bileÅŸen, herhangi bir dÃ¼ÄŸÃ¼mde podâ€™lar Ã¶ldÃ¼ÄŸÃ¼nde ne olacaÄŸÄ± sorusu aÃ§Ä±sÄ±ndan kritik Ã¶neme sahiptir. Ã–lÃ¼ nodeâ€™larÄ± tespit etmek ve daha sonra bu podâ€™larÄ± en kÄ±sa sÃ¼rede reschedule etmek gerekir.</p>
    <p><img src="images/24.png" /></p>
    <p>DolayÄ±sÄ±yla controller manager, state changesâ€™larÄ±, Ã¶rneÄŸin podâ€™larÄ±n Ã§Ã¶kmesini tespit eder. Podâ€™lar Ã¶ldÃ¼ÄŸÃ¼nde controller manager bunu algÄ±lar ve cluster stateâ€™ini mÃ¼mkÃ¼n olan en kÄ±sa sÃ¼rede kurtarmaya Ã§alÄ±ÅŸÄ±r.</p>
    <p>Ã–len podâ€™larÄ± yeniden schedule etme amacÄ±yla schedulerâ€™a bir istek gÃ¶nderir. Bu dÃ¶ngÃ¼ iÃ§inde, scheduler kaynak hesaplamasÄ±na gÃ¶re hangi worker nodeâ€™larÄ±n bu podâ€™larÄ± tekrar baÅŸlatmasÄ± gerektiÄŸine karar verir ve bu worker nodeâ€™lar Ã¼zerindeki ilgili <code>kubelet</code>lere, podâ€™larÄ± yeniden baÅŸlatmalarÄ± iÃ§in istek gÃ¶nderir.</p>
    <p><img src="images/25.png" /></p>
    <h4 id="etcd">4) Etcd</h4>
    <p>Son olarak, ana iÅŸlemlerden biri olan etcd, bir cluster stateâ€™inin key-value deposudur. Bunu aslÄ±nda bir cluster beyni olarak dÃ¼ÅŸÃ¼nebiliriz. Yani clusterâ€™daki her deÄŸiÅŸiklik -Ã¶rneÄŸin yeni bir pod schedule edildiÄŸinde veya bir pod Ã¶ldÃ¼ÄŸÃ¼nde- etcdâ€™nin bu key-value deposunda kaydedilir veya gÃ¼ncellenir.</p>
    <p><img src="images/26.png" /></p>
    <p>Etcd deposunun bir kÃ¼me beyni olarak adlandÄ±rÄ±lmasÄ±nÄ±n sebebi, scheduler, controller manager gibi tÃ¼m bu mekanizmalarÄ±n, etcdâ€™nin sahip olduÄŸu veriler sayesinde Ã§alÄ±ÅŸmasÄ±dÄ±r.</p>
    <p><img src="images/27.png" /></p>
    <p>Ã–rneÄŸin, scheduler her bir worker nodeâ€™unda hangi kaynaklarÄ±n mevcut olduÄŸunu nasÄ±l bilir? Veya controller manager, cluster durumunda bir deÄŸiÅŸiklik olduÄŸunu nasÄ±l tespit eder? Podâ€™larÄ±n Ã¶lmesi, kubeletâ€™in schedulerâ€™Ä±n isteÄŸi Ã¼zerine yeni podâ€™larÄ± baÅŸlatmasÄ±, API sunucusuna cluster health hakkÄ±nda bir sorgu gÃ¶ndermemiz veya uygulama daÄŸÄ±tÄ±m durumumuz gibi bu durum bilgilerini, API sunucusu nereden alÄ±r?</p>
    <p>Cevap: TÃ¼m bu bilgiler etcd kÃ¼mesinde saklanÄ±r. Etcdâ€™nin key-value deposunda saklanmayan ÅŸey ise gerÃ§ek uygulama verileridir. Ã–rneÄŸin, bir cluster iÃ§inde Ã§alÄ±ÅŸan bir database uygulamamÄ±z varsa, veriler etcdâ€™de deÄŸil, baÅŸka bir yerde saklanÄ±r. Bu, yalnÄ±zca master iÅŸlemlerinin worker iÅŸlemleriyle ve tersiyle iletiÅŸim kurmasÄ± iÃ§in kullanÄ±lan bir cluster state bilgisidir.</p>
    <p>ArtÄ±k muhtemelen ana iÅŸlemlerin, Ã¶zellikle de verileri gÃ¼venilir bir ÅŸekilde saklanmasÄ± veya Ã§oÄŸaltÄ±lmasÄ± gereken etcd deposunun, cluster operasyonu iÃ§in kritik Ã¶neme sahip olduÄŸunu anlamÄ±ÅŸÄ±zdÄ±r. Bu nedenle, uygulamada bir Kubernetes kÃ¼mesi genellikle birden fazla masterâ€™dan oluÅŸur. Her bir master dÃ¼ÄŸÃ¼mÃ¼ kendi ana iÅŸlemlerini Ã§alÄ±ÅŸtÄ±rÄ±r; elbette API sunucusu load-balancedâ€™dÄ±r ve etcd deposu tÃ¼m master dÃ¼ÄŸÃ¼mleri arasÄ±nda distributed bir depolama oluÅŸturur.</p>
    <p><img src="images/28.png" /></p>
    <hr />
    <h2 id="cluster-yapÄ±sÄ±">Cluster YapÄ±sÄ±</h2>
    <p>Åimdi worker ve master nodeâ€™larÄ±nda Ã§alÄ±ÅŸan iÅŸlemleri gÃ¶rdÃ¼kten sonra, gerÃ§ek hayattaki bir cluster kurulumuna bakalÄ±m. Ã‡ok kÃ¼Ã§Ã¼k bir clusterâ€™da muhtemelen iki master node ve Ã¼Ã§ worker node olur.</p>
    <p><img src="images/29.png" /></p>
    <p>Burada dikkat edilmesi gereken bir diÄŸer nokta ise master node sunucularÄ±nÄ±n donanÄ±m kaynaklarÄ±nÄ±n aslÄ±nda farklÄ± olmasÄ±dÄ±r. Master iÅŸlemleri daha Ã¶nemlidir, ancak aslÄ±nda daha az iÅŸ yÃ¼kÃ¼ne sahiptirler. DolayÄ±sÄ±yla CPU, RAM ve depolama gibi daha az kaynaÄŸa ihtiyaÃ§ duyarlar. Worker nodeâ€™larÄ± ise, containerlarÄ± Ã§alÄ±ÅŸtÄ±ran podâ€™larÄ± barÄ±ndÄ±rma gibi asÄ±l iÅŸi yaparlar.</p>
    <p>Bu nedenle, worker nodeâ€™larÄ±nÄ±n daha fazla kaynaÄŸa ihtiyacÄ± vardÄ±r. UygulamamÄ±zÄ±n karmaÅŸÄ±klÄ±ÄŸÄ± ve kaynak gereksinimi arttÄ±kÃ§a, aslÄ±nda clusterâ€™Ä±mÄ±za daha fazla master ve worker nodeâ€™u ekleyerek daha gÃ¼Ã§lÃ¼ ve saÄŸlam bir kÃ¼me oluÅŸturabiliriz. BÃ¶ylece uygulama kaynak gereksinimlerimizi karÅŸÄ±layabiliriz.</p>
    <p><img src="images/30.png" /></p>
    <p>Var olan bir Kubernetes clusterâ€™Ä±nda yeni master veya worker serverlarÄ± eklemek aslÄ±nda oldukÃ§a kolaydÄ±r. Bir master sunucusu eklemek istiyorsak, yeni bir bare metal sunucu ediniyoruz. Ãœzerine tÃ¼m master workâ€™leri kurup onu Kubernetes kÃ¼mesine ekliyoruz. Bu kadar..</p>
    <p>Yine aynÄ± ÅŸekilde, iki worker nodeâ€™una ihtiyacÄ±mÄ±z varsa, bare metal sunucular ediniyoruz. Container runtime, kubelet ve kube-proxy gibi tÃ¼m worker node iÅŸlemlerini Ã¼zerlerine kurup onlarÄ± Kubernetes clusterÄ±na ekleyin.</p>
    <p>Ä°ÅŸte bu kadar. Bu ÅŸekilde, uygulama karmaÅŸÄ±klÄ±ÄŸÄ± ve kaynak gereksinimi arttÄ±kÃ§a, Kubernetes kÃ¼memizin gÃ¼cÃ¼nÃ¼ ve kaynaklarÄ±nÄ± sonsuza kadar artÄ±rabiliriz.</p>
    <hr />
    <h2 id="minikube-ve-kubectl-kurulumu">Minikube ve Kubectl Kurulumu</h2>
    <h3 id="minikube">Minikube</h3>
    <p><img src="images/31.png" /></p>
    <p>Genellikle Kubernetes dÃ¼nyasÄ±nda bir production cluster kurduÄŸumuzda, aÅŸaÄŸÄ±daki gibi gÃ¶rÃ¼necektir.</p>
    <p><img src="images/32.png" /></p>
    <p>En az iki olmak Ã¼zere birden fazla Masterâ€™a sahip olacaÄŸÄ±z ve birden fazla worker node olacak. Worker dÃ¼ÄŸÃ¼mlerinin kendi ayrÄ± sorumluluklarÄ± vardÄ±r. Diyagramda gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi, her biri bir nodeâ€™u temsil eden gerÃ§ek ayrÄ± sanal veya fiziksel makinelerimiz olur.</p>
    <p>Åimdi, yerel ortamÄ±mÄ±zda bir ÅŸey test etmek istiyorsak veya yeni bir uygulama, yeni bileÅŸenler daÄŸÄ±tarak Ã§ok hÄ±zlÄ± bir ÅŸekilde bir ÅŸey denemek istiyorsak ve bunlarÄ± yerel makinemizde test etmek istiyorsak; aÃ§Ä±kÃ§asÄ± bÃ¶yle bir cluster kurmak oldukÃ§a zor olacaktÄ±r. Bellek ve CPU gibi yeterli kaynaÄŸÄ±mÄ±z yoksa imkansÄ±z bile olabilir. Ä°ÅŸte tam olarak bu kullanÄ±m durumu iÃ§in <code>Minikube</code> adÄ± verilen aÃ§Ä±k kaynaklÄ± araÃ§ var.</p>
    <p>Minikubeâ€™un ne olduÄŸuna gelirsek, temelde hem master processleri hem de worker processleri tek bir nodeâ€™da Ã§alÄ±ÅŸtÄ±ran tek node bir clusterdÄ±r. Bu nodeâ€™da Ã¶nceden yÃ¼klenmiÅŸ bir Docker container runtime olacak ÅŸekilde konteynerleri veya konteynerli podâ€™larÄ± Ã§alÄ±ÅŸtÄ±rabileceÄŸiz.</p>
    <p><img src="images/33.png" /></p>
    <p>DizÃ¼stÃ¼ bilgisayarÄ±mÄ±zda VirtualBox, KVM veya baÅŸka bir hipervizÃ¶r aracÄ±lÄ±ÄŸÄ±yla Ã§alÄ±ÅŸacak. Yani temel olarak, Minikube dizÃ¼stÃ¼ bilgisayarlarÄ±mÄ±zda bir sanal makine oluÅŸturacak ve burada gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z nodeâ€™lar bu sanal makinede Ã§alÄ±ÅŸacak.</p>
    <p>Ã–zetleyecek olursak, Minikube, yerel kurulumumuzda Kubernetesâ€™i test etmek iÃ§in kullanabileceÄŸimiz dizÃ¼stÃ¼ bilgisayarÄ±nÄ±zda bir sanallaÅŸtÄ±rma aracÄ±yla Ã§alÄ±ÅŸan tek node bir Kubernetes clusterdÄ±r.</p>
    <p><img src="images/34.png" /></p>
    <p>Yerel makinemizde bir cluster veya mini cluster kurduktan sonra, bu cluster ile etkileÅŸim kurmak iÃ§in bir yola ihtiyacÄ±mÄ±z olacaktÄ±r. Componentler oluÅŸturmak, yapÄ±landÄ±rmak vb. isteyeceÄŸiz. Tam burada <code>kubectl</code> devreye giriyor.</p>
    <h3 id="kubectl">Kubectl</h3>
    <p>local makinemizde Minikubeâ€™u temsil eden bu virtual nodeâ€™a sahip olduktan sonra, bu cluster ile etkileÅŸim kurmak iÃ§in bir yola ihtiyacÄ±mÄ±z vardÄ±r. Bunu Kubernetes clusterlarÄ± iÃ§in bir command line toolu olan <code>kubectl</code> kullanarak yapabiliriz.</p>
    <p>NasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶relim. Minikubeâ€™un hem master hem de worker processleri Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±nÄ± sÃ¶ylemiÅŸtik, bu nedenle API server adÄ± verilen master processlerden biri aslÄ±nda Kubernetes clusterÄ±n entry point noktasÄ±dÄ±r.</p>
    <p><img src="images/35.png" /></p>
    <p>Kubernetesâ€™te bir ÅŸey yapmak istiyorsak veya herhangi bir ÅŸeyi yapÄ±landÄ±rmak istiyorsak, Ã¶nce API server ile konuÅŸmamÄ±z gerekir. API server ile konuÅŸmanÄ±n yolu ise farklÄ± istemciler aracÄ±lÄ±ÄŸÄ±yla olur. Bir dashboard gibi bir UI arayÃ¼zÃ¼nÃ¼z olabilir, Kubernetes APIâ€™sini kullanarak konuÅŸabilir veya <code>kubectl</code> command line tool kullanabiliriz.</p>
    <p><img src="images/36.png" /></p>
    <p><code>kubectl</code> aslÄ±nda Ã¼Ã§ istemcinin de en gÃ¼Ã§lÃ¼sÃ¼dÃ¼r Ã§Ã¼nkÃ¼ <code>kubectl</code> ile Kubernetesâ€™te istediÄŸimiz her ÅŸeyi yapabiliriz.</p>
    <p>Bu yazÄ±nÄ±n neredeyse sonuna kadar <code>kubectl</code> kullanÄ±lmaktadÄ±r. <code>kubectl</code> API sunucusuna component oluÅŸturmak, component silmek vb. iÃ§in komutlar gÃ¶nderdikten sonra, Minikube nodeâ€™undaki worker processler bunlarÄ± gerÃ§ekleÅŸtirecektir. Podâ€™lar oluÅŸturmak, podâ€™larÄ± yok etmek, servisler oluÅŸturmak vb. iÃ§in komutlarÄ± yÃ¼rÃ¼teceklerdir.</p>
    <p>Bu, Minikube Ã§alÄ±ÅŸma ÅŸeklidir. <code>kubectl</code> cluster ile nasÄ±l kullanÄ±lÄ±r? Burada Ã¶nemli bir nokta, <code>kubectl</code>â€™in yalnÄ±zca Minikube cluster iÃ§in olmadÄ±ÄŸÄ±dÄ±r. Bir cloud clusterâ€™Ä±mÄ±z veya hibrit bir clusterâ€™Ä±mÄ±z varsa, <code>kubectl</code> herhangi bir Kubernetes cluster kurulumuyla etkileÅŸim kurmak iÃ§in kullanÄ±lan araÃ§tÄ±r. Bu nedenle burada unutulmamasÄ± Ã¶nemlidir.</p>
    <p><img src="images/37.png" /></p>
    <p>ArtÄ±k Minikube ve <code>kubectl</code>â€™nin ne olduÄŸunu bildiÄŸimize gÃ¶re, onlarÄ± pratikte gÃ¶rmek iÃ§in kuruluma baÅŸlayalÄ±m.</p>
    <h3 id="kurulum">Kurulum</h3>
    <p>Daha Ã¶nce de belirttiÄŸimiz gibi Minikube bir sanallaÅŸtÄ±rmaya ihtiyaÃ§ duyar, Ã§Ã¼nkÃ¼ bazÄ± hipervizÃ¶rlerde Ã§alÄ±ÅŸacaktÄ±r. Bu nedenle bir tÃ¼r hipervizÃ¶r yÃ¼klemeliyiz.</p>
    <p>Åimdi linux Ã¼zerinde minikube ve kubectl kurulumuna geÃ§elim.</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube &amp;&amp; rm minikube-linux-amd64
            </code></pre>
        </div>
    </div>

    <p>Åimdi her ÅŸeyin kurulduÄŸundan emin olalÄ±m ve komutlarÄ± kontrol edelim. Yani, <code>minikube</code> komutu Ã§alÄ±ÅŸmalÄ±:</p>


    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">c3ng0@ubn:~$ minikube start

            ğŸ˜„  minikube v1.33.1 on Ubuntu 22.04
            âœ¨  Automatically selected the docker driver. Other choices: kvm2, qemu2, none, ssh
            ğŸ“Œ  Using Docker driver with root privileges
            ğŸ‘  Starting &quot;minikube&quot; primary control-plane node in &quot;minikube&quot; cluster
            ğŸšœ  Pulling base image v0.0.44 ...
            ğŸ’¾  Downloading Kubernetes v1.30.0 preload ...
                &gt; preloaded-images-k8s-v18-v1...:  112.62 MiB / 342.90 MiB  32.84% 5.18 MiB
                &gt; gcr.io/k8s-minikube/kicbase...:  70.41 MiB / 481.58 MiB  14.62% 2.65 MiB
                &gt; index.docker.io/kicbase/sta...:  481.58 MiB / 481.58 MiB  100.00% 11.15 M
            â—  minikube was unable to download gcr.io/k8s-minikube/kicbase:v0.0.44, but successfully downloaded docker.io/kicbase/stable:v0.0.44 as a fallback image
            ğŸ”¥  Creating docker container (CPUs=2, Memory=2200MB) ...
                &gt; kubectl.sha256:  64 B / 64 B [-------------------------] 100.00% ? p/s 0s
                &gt; kubeadm.sha256:  64 B / 64 B [-------------------------] 100.00% ? p/s 0s
                &gt; kubelet.sha256:  64 B / 64 B [-------------------------] 100.00% ? p/s 0s
                &gt; kubectl:  49.07 MiB / 49.07 MiB [------------] 100.00% 14.58 MiB p/s 3.6s
                &gt; kubeadm:  47.92 MiB / 47.92 MiB [--------------] 100.00% 3.97 MiB p/s 12s
                &gt; kubelet:  95.46 MiB / 95.46 MiB [--------------] 100.00% 6.52 MiB p/s 15s

                â–ª Generating certificates and keys ...
                â–ª Booting up control plane ...
                â–ª Configuring RBAC rules ...
            ğŸ”—  Configuring bridge CNI (Container Networking Interface) ...
            ğŸ”  Verifying Kubernetes components...
                â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
            ğŸŒŸ  Enabled addons: storage-provisioner, default-storageclass
            ğŸ’¡  kubectl not found. If you need it, try: &#39;minikube kubectl -- get pods -A&#39;
            ğŸ„  Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default</code></pre>
        </div>
    </div>


    <p>Ve <code>kubectl</code> indirmemiz gerekiyor:</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            </code></pre>
        </div>
    </div>
    <p>Binaryâ€™i doÄŸrula(opsiyonel)</p>
    <p>kubectl checksumfile indir:</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256"
            </code></pre>
        </div>
    </div>

    <p>Ä°ndirilen checksum file ile binary doÄŸrulama:</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check
            </code></pre>
        </div>
    </div>
    <p>DoÄŸru ise Ã§Ä±ktÄ± aÅŸaÄŸÄ±daki gibi olmalÄ±:</p>


    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl: OK
            </code></pre>
        </div>
    </div>
    <ul>
    <li>Kubectl Kurulumu</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
            </code></pre>
        </div>
    </div>
    <ul>
    <li>Son sÃ¼rÃ¼mÃ¼ kurduÄŸumuzu kontrol etme:</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl version --client
            </code></pre>
        </div>
    </div>
    <br>
    <br>
    <p><img src="images/38.png" /></p>
    <p>daha fazlasÄ± iÃ§in <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/">kubernetes.io</a></p>
    <p>Minikube oldukÃ§a basit bir komut satÄ±rÄ± aracÄ± ile birlikte gelir. Tek bir komutla tÃ¼m Kubernetes kÃ¼mesini bu tek dÃ¼ÄŸÃ¼m kurulumunda hÄ±zlÄ±ca baÅŸlatabilir, durdurabilir veya silebiliriz.</p>
    <hr />
    <h2 id="ilk-cluster">Ä°lk Cluster</h2>
    <p>Åimdi her ikisini de kurduÄŸumuza gÃ¶re, bir Minikube Kubernetes cluster oluÅŸturalÄ±m.</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
minikube start
            </code></pre>
        </div>
    </div>


    <p>iÅŸte Minikube ile bir Kubernetes cluster nasÄ±l baÅŸlatacaÄŸÄ±mÄ±z:</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
minikube start --vm-driver=kvm
            </code></pre>
        </div>
    </div>


    <p>Burada, kurulu hipervizÃ¶rÃ¼n devreye girdiÄŸini gÃ¶rebiliriz Ã§Ã¼nkÃ¼ Minikubeâ€™un bir Sanal ortamda Ã§alÄ±ÅŸmasÄ± gerektiÄŸinden, Minikubeâ€™a hangi hipervizÃ¶rÃ¼ kullanmasÄ± gerektiÄŸini sÃ¶yleyeceÄŸiz. Bunun iÃ§in, <code>--vm-driver</code> olarak adlandÄ±rÄ±lan bir seÃ§enek belirleyeceÄŸiz ve burada bende kurulu olan <code>kvm</code>â€™i ayarladÄ±m.</p>
    <p>Bunu yÃ¼rÃ¼ttÃ¼ÄŸÃ¼mde bir ÅŸeyler indirecek, yani ilk kez yapÄ±yorsak biraz daha uzun sÃ¼rebilir.</p>
    <p><img src="images/39.png" /></p>
    <p>Ve bahsettiÄŸim gibi, makinenizde Docker yoksa bile Ã§alÄ±ÅŸacak.</p>
    <p>TamamlandÄ±. ArtÄ±k <code>kubectl</code>, Minikubeâ€™u kullanacak ÅŸekilde yapÄ±landÄ±rÄ±lmÄ±ÅŸ durumda, bu da Minikube clusterâ€™Ä±nÄ±n kurulduÄŸu anlamÄ±na gelir.</p>
    <p><img src="images/40.png" /></p>
    <p>Kubernetes KÃ¼mesi ile etkileÅŸimde bulunmak iÃ§in tasarlanmÄ±ÅŸ olan <code>kubectl</code> komutu da o Minikube kÃ¼mesi ile baÄŸlantÄ±lÄ±dÄ±r, eÄŸer ÅŸunu yaparsak:</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl get nodes
            </code></pre>
        </div>
    </div>


    <p>Bu, Kubernetes cluster nodeâ€™larÄ±nÄ±n durumunu bize bildirir. Bize bir Minikube nodeâ€™unun hazÄ±r olduÄŸunu sÃ¶yleyecek ve gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi aÃ§Ä±kÃ§a master processleri Ã§alÄ±ÅŸtÄ±rmalÄ± Ã§Ã¼nkÃ¼ sadece bir node var.</p>
    <p><img src="images/41.png" /></p>
    <p>Ve ayrÄ±ca Minikubeâ€™Ä±n durumunu alabiliriz:</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
minikube status
            </code></pre>
        </div>
    </div>

<br>
    <p><img src="images/42.png" /></p>
    <p>Yani, ana makinede kubelet adlÄ± bir hizmetin Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼yoruz, bu da aslÄ±nda konteyner runtime kullanarak podâ€™larÄ± Ã§alÄ±ÅŸtÄ±ran bir hizmettir, yani her ÅŸey Ã§alÄ±ÅŸÄ±yor.</p>
    <p>Buradan itibaren mini Kub kÃ¼mesi ile <code>kubectl</code> komut satÄ±rÄ± aracÄ±lÄ±ÄŸÄ±yla etkileÅŸime geÃ§eceÄŸiz. Minicube sadece cluster baÅŸlatma ve silme iÃ§in kullanÄ±lÄ±r, ancak configuring ve diÄŸer her ÅŸeyi <code>kubectl</code> aracÄ±lÄ±ÄŸÄ±yla yapacaÄŸÄ±z.</p>
    <hr />
    <h2 id="main-kubectl-komutlarÄ±">Main Kubectl KomutlarÄ±</h2>
    <p>Bu bÃ¶lÃ¼mde bazÄ± temel Kubectl komutlarÄ±nÄ± gÃ¶receÄŸiz ve minikubeâ€™da nasÄ±l create ve debug pods yapÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶receÄŸiz.</p>
    <p>Cubectlâ€™i clusterda herhangi bir ÅŸey yapmak iÃ§in kullanacaÄŸÄ±z. -components oluÅŸturmak, status almak, vb.-</p>
    <ul>
    <li>Ä°lk olarak, nodeâ€™larÄ±n durumunu alacaÄŸÄ±z.</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl get nodes
            </code></pre>
        </div>
    </div>
    <p>Bu komutu kullanarak nodeâ€™larÄ±n durumunu Ã¶ÄŸrenebiliyoruz.</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl get nodes
    NAME       STATUS   ROLES           AGE    VERSION
    minikube   Ready    control-plane   145m   v1.30.0
            </code></pre>
        </div>
    </div>
    <p>GÃ¶rÃ¼yoruz ki bir node var ve her ÅŸey o nodeâ€™da Ã§alÄ±ÅŸÄ±yor Ã§Ã¼nkÃ¼ bu bir <code>minikube</code>.</p>
    <ul>
    <li>Podâ€™larÄ± kontrol edebiliriz ve herhangi bir podâ€™umuz olmadÄ±ÄŸÄ± iÃ§in sonuÃ§ yok.</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl get pod
            </code></pre>
        </div>
    </div>
    <ul>
    <li>Services kontrol edebiliriz, varsayÄ±lan bir servisimiz var.</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl get services
    NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
    kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   148m
            </code></pre>
        </div>
    </div>
    <p>Åimdi, herhangi bir Podâ€™umuz olmadÄ±ÄŸÄ± iÃ§in bir tane oluÅŸturacaÄŸÄ±z ve Kubernetes bileÅŸenleri oluÅŸturmanÄ±n bir Kubectl create komutu olduÄŸunu hatÄ±rlayalÄ±m. Kubectl create komutunu kullanarak tÃ¼m bu bileÅŸenleri oluÅŸturabiliriz.</p>
    <ul>
    <li>Ancak listede <code>Pod</code> yok Ã§Ã¼nkÃ¼ Kubernetes dÃ¼nyasÄ±nda, Pod, Kubernetes clusterÄ±nÄ±n en kÃ¼Ã§Ã¼k birimidir ve genellikle, Podâ€™larÄ± doÄŸrudan oluÅŸturulmaz. Veya Podâ€™larla doÄŸrudan Ã§alÄ±ÅŸÄ±lmaz. Podâ€™larÄ±n Ã¼zerinde bir soyutlama katmanÄ±<code>(abstraction over Pods)</code> vardÄ±r, buna Â·<code>deployment</code>Â· denir. Ä°ÅŸte bu oluÅŸturmak Ã¼zere olduÄŸumuz ÅŸey. Bu da, altÄ±ndaki parÃ§alarÄ± oluÅŸturacak.</li>
    </ul>
    <div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ex">Usage</span>:</span>
    <span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>   <span class="ex">kubectl</span> create deployment NAME --image=image -- [COMMAND] [args...] [options]</span></code></pre></div>
    <ul>
    <li><strong>NAME</strong>: deploymentâ€™a isim vermeliyiz</li>
    <li><strong>â€“image=</strong>: oluÅŸturacaÄŸÄ±mÄ±z container imageâ€™i</li>
    </ul>
    <p>Åimdi bir nginx daÄŸÄ±tÄ±mÄ± oluÅŸturalÄ±m.</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl create deployment nginx-depl --image=nginx
  deployment.apps/nginx-depl created
            </code></pre>
        </div>
    </div>

<br>
    <ul>
    <li>Nginx gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼, Docker Hubâ€™dan indirecektir. Bu komutu yÃ¼rÃ¼ttÃ¼ÄŸÃ¼mÃ¼z zaman, gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi nginx deployment oluÅŸturuldu.</li>
    </ul>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
c3ng0@ubn:~$ kubevtl get deployment
    NAME         READY   UP-TO-DATE   AVAILABLE   AGE
    nginx-depl   0/1     1            0           15s
            </code></pre>
        </div>
    </div>

<br>
    <ul>
    <li>OluÅŸturulmuÅŸ bir deployment olduÄŸunu gÃ¶rÃ¼yoruz ve burada â€œhazÄ±r deÄŸilâ€ durumunda olduÄŸunu da gÃ¶rebiliyoruz.</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl get pod
    NAME                          READY   STATUS    RESTARTS   AGE
    nginx-depl-85c9d7c5f4-g4lwt   0/1     Creating  0          31s
            </code></pre>
        </div>
    </div>


    <ul>
    <li><p>ArtÄ±k bir Podâ€™umuz var. Name deÄŸeri, prefix ve rastgele bir hashâ€™e sahipt. Burada â€œkonteyner oluÅŸturuluyorâ€ yazÄ±yor, yani henÃ¼z hazÄ±r deÄŸil. Bir sÃ¼re beklersek <code>Running</code>.</p></li>
    <li><p>Bir deployment oluÅŸturduÄŸumuzda, deployment, Pod oluÅŸturmak iÃ§in gereken tÃ¼m bilgilere veya blueprintlere sahip olur.</p></li>
    </ul>
    <p><img src="images/43.png" /></p>
    <ul>
    <li><p>Bu en temel yapÄ±landÄ±rmadÄ±r, sadece adÄ± ve gÃ¶rÃ¼ntÃ¼sÃ¼. Bu kadar.. geri kalanÄ± default.</p></li>
    <li><p>Deployment ve Pod arasÄ±nda bir baÅŸka katman vardÄ±r ve bu, otomatik olarak kubernetes tarafÄ±ndan yÃ¶netilen <code>replicaset</code>â€™tir.</p></li>
    <li><p><code>kubectl get replicaset</code> yaparsak, bir nginx replica set hashâ€™imiz olduÄŸunu gÃ¶rÃ¼yoruz. Ve burada, Pod adÄ±nÄ±n bir deployment prefix, replicasetâ€™in IDâ€™si ve son olarak kendi IDâ€™si olduÄŸunu gÃ¶rebiliriz. Pod adÄ± bu ÅŸekilde oluÅŸmaktadÄ±r. Replicaset, Podâ€™un tÃ¼m replikalarÄ±nÄ± yÃ¶netir. Biz hiÃ§bir zaman replica set oluÅŸturmayacak, silmeyecek veya gÃ¼ncellemeyeceÄŸiz. DoÄŸrudan deploymentlar ile Ã§alÄ±ÅŸacaÄŸÄ±z. Bu daha uygun Ã§Ã¼nkÃ¼ deploymentlarda Pod blueprintini tamamen yapÄ±landÄ±rabiliriz. Podâ€™un kaÃ§ replikasÄ±na ihtiyacÄ±mÄ±z olduÄŸunu belirtebilir ve geri kalan configurationâ€™u orada yapabiliriz.</p></li>
    </ul>
    <h3 id="layerlarÄ±n-Ã§alÄ±ÅŸma-ÅŸekli">LayerlarÄ±n Ã§alÄ±ÅŸma ÅŸekli:</h3>
    <ul>
    <li>Ä°lk olarak Deployment, ReplicaSetâ€™i yÃ¶netir.</li>
    <li>ReplicaSet, o Podâ€™un tÃ¼m replikalarÄ±nÄ± yÃ¶netir.</li>
    <li>Pod, bir konteynerin soyutlamasÄ±dÄ±r. Deploymentâ€™tan aÅŸaÄŸÄ±daki her ÅŸey otomatik olarak kubernetes tarafÄ±ndan yÃ¶netilmelidir.</li>
    </ul>
    <p>Ã–rneÄŸin, kullanÄ±ldÄ±ÄŸÄ± image gibi bir ÅŸeyi doÄŸrudan bir deployment iÃ§erisinde dÃ¼zenlememiz gerekecek, Pod iÃ§inde deÄŸil. Ã–yleyse hemen yapalÄ±m.</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">nginx-depl.yaml</span>
        </div>
        <div class="window-content">
            <pre><code class="language-yaml">
              c3ng0@ubn:~$ kubectl edit deployment nginx-depl


                    # Please edit the object below. Lines beginning with a '#' will be ignored,
                    # and an empty file will abort the edit. If an error occurs while saving this file will be
                    # reopened with the relevant failures.
                    #
                    apiVersion: apps/v1
                    kind: Deployment
                    metadata:
                      annotations:
                        deployment.kubernetes.io/revision: "1"
                      creationTimestamp: "2024-05-14T11:31:36Z"
                      generation: 1
                      labels:
                        app: nginx-depl
                      name: nginx-depl
                      namespace: default
                      resourceVersion: "9431"
                      uid: 66d185d6-b628-4d10-b3bc-4aea093dfc59
                    spec:
                      progressDeadlineSeconds: 600
                      replicas: 1
                      ...
                      ...
                      ...
            </code></pre>
        </div>
    </div>

    <p>Deployment oluÅŸtururken verdiÄŸimiz iki seÃ§enek dÄ±ÅŸÄ±nda her ÅŸeyin otomatik olarak oluÅŸturulmuÅŸ bir deployment, otomatik olarak oluÅŸturulmuÅŸ bir yapÄ±landÄ±rma dosyasÄ±nÄ± alÄ±yoruz. Åimdilik sadece image'i istediÄŸimiz versiyonu 1.16â€™ya sabitlemek istediÄŸimizi varsayalÄ±m ve bu deÄŸiÅŸikliÄŸi kaydedelim.</p>


    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
              spec:
                containers:
## Sildik       - image: nginx
          ---
              spec:
                containers:
## Ekledik      - image: nginx:1.16
            </code></pre>
        </div>
    </div>

    <pre><code>
    </code></pre>
    <p>Ve gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi daÄŸÄ±tÄ±m dÃ¼zenlendi.</p>
    <p><img src="images/44.png" /></p>
    <p>Åimdi <code>kubectl get pod</code> yaparsak, eski podâ€™umuzu gÃ¶rÃ¼rÃ¼z.</p>
    <p><img src="images/45.png" /></p>
    <ul>
    <li>Eski Pod sona erdi ve yeni pod baÅŸladÄ±.</li>
    </ul>
    <p>EÄŸer ReplicaSetâ€™i gÃ¶rÃ¼ntÃ¼lersek, eski olanÄ±n iÃ§inde pod olmadÄ±ÄŸÄ±nÄ± ve yeni bir tane oluÅŸturulduÄŸunu gÃ¶rÃ¼yoruz.</p>
    <p><img src="images/46.png" /></p>
    <p>Yani sonuÃ§ olarak deployment yapÄ±landÄ±rmasÄ±nÄ± dÃ¼zenledik ve altÄ±ndaki her ÅŸey otomatik olarak gÃ¼ncellendi. Bu yaptÄ±ÄŸÄ±mÄ±z, Kubernetesâ€™in sihrine ve nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±na bir Ã¶rnektir.</p>
    <h3 id="debugging-pods">Debugging Pods</h3>
    <p>Bir diÄŸer Ã§ok pratik komut ise <code>kubectl logs</code>, bu aslÄ±nda Pod iÃ§inde Ã§alÄ±ÅŸan uygulamanÄ±n neyi kaydettiÄŸini gÃ¶sterir.</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl logs [POD_NAME]
            </code></pre>
        </div>
    </div>


    <p>LoglarÄ± gÃ¶rÃ¼ntÃ¼lemeden Ã¶nce Nginx hiÃ§bir ÅŸey kaydetmediÄŸi iÃ§in baÅŸka bir daÄŸÄ±tÄ±m oluÅŸturalÄ±m. Mongodbâ€™den oluÅŸturalÄ±m ve adÄ±na <code>mongo-depl</code> verelim.</p>
    <p><img src="images/47.png" /></p>
    <p>Åimdi mongodb deployment oluÅŸturuluyor.</p>
    <p><img src="images/48.png" /></p>
    <p>Åu anda loglara bakabiliriz:</p>
    <p><img src="images/49.png" /></p>
    <ul>
    <li><code>kubectl describe pod [POD_NAME]</code> events sekmesinde bize state deÄŸiÅŸikliklerini verir.</li>
    </ul>
    <br>
    <p><img src="images/50.png" /></p>
    <p>Loglamak, uygulamanÄ±n gerÃ§ekte neyi yazdÄ±ÄŸÄ±nÄ± gÃ¶rmede ve hata ayÄ±klamada yardÄ±mcÄ± olmaktadÄ±r.</p>
    <p>BaÅŸka bir Ã§ok kullanÄ±ÅŸlÄ± komut, <code>kubectl exec</code>tir. Debugging yaparken, bir ÅŸey Ã§alÄ±ÅŸmÄ±yorsa veya sadece Podâ€™un iÃ§eriÄŸini kontrol etmek iÃ§in kullanÄ±lÄ±r. BasitÃ§e aÃ§Ä±klayacak olursak, Ã§alÄ±ÅŸan Podâ€™dan shell alÄ±r. bu yÃ¼zden:</p>


    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl exec -it [POD_NAME] -- bin/bash
            </code></pre>
        </div>
    </div>
<br>
    <ul>
    <li>-it = <strong>interactive terminal</strong></li>
    </ul>
    <p><img src="images/51.png" /></p>
    <p>Bu komutla mongodb uygulama konteynerinin terminalini alÄ±yoruz ve ÅŸu anda root kullanÄ±cÄ±sÄ± olarak mongodb konteynerinin iÃ§indeyiz. Exec, hata ayÄ±klama veya bir ÅŸeyleri test etmek veya denemek istediÄŸinizde kullanÄ±ÅŸlÄ±dÄ±r. Konteynera girebilir veya terminali alabilir ve orada bazÄ± komutlar Ã§alÄ±ÅŸtÄ±rabiliriz.</p>
    <h3 id="deployment-silme-ve-apply-configuration-file">Deployment Silme ve Apply Configuration File</h3>
    <p>Tabii ki kubectl ile podlarÄ± silebiliriz, Ã¶nce deploymentâ€™larÄ± ve podlarÄ± gÃ¶rÃ¼ntÃ¼leyelim.</p>
    <p><img src="images/52.png" /></p>
    <pre><code>kubectl delete deployment [deployment_name]</code></pre>
    <p><img src="images/53.png" /></p>
    <p>kontrol edersek Podâ€™un sonlandÄ±ÄŸÄ±nÄ± ve eÄŸer replica set alÄ±rsak, mongodb replicasetinin de gittiÄŸini gÃ¶rebiliriz.</p>
    <p>TÃ¼m crud iÅŸlemleri (create,update,delete vb.) deployment seviyesinde gerÃ§ekleÅŸir ve altÄ±ndaki her ÅŸey otomatik olarak takip eder. AynÄ± ÅŸekilde Services gibi diÄŸer Kubernetes kaynaklarÄ± oluÅŸturabiliriz.</p>
    <p>Ancak fark ettiÄŸiniz gibi, Kubectl ile deployment gibi kubernetes bileÅŸenlerini oluÅŸtururken, tÃ¼m bu seÃ§enekleri komut satÄ±rÄ±nda belirtmemiz gerekir.</p>
    <ul>
    <li>AdÄ± belirtmemiz gerekir.</li>
    <li>Imageâ€™i belirtmemiz gerekir</li>
    <li>option1</li>
    <li>option2.. vb. olabilir.</li>
    </ul>
    <p>Elbette bir deploymentâ€™ta veya bir Podâ€™ta yapÄ±landÄ±rmak istediÄŸimiz birÃ§ok ÅŸey olabilir ve aÃ§Ä±kÃ§asÄ± bunlarÄ±n hepsini komut satÄ±rÄ±nda yazmak pratik olmayacaktÄ±r. Bunun iÃ§in genellikle Kubernetes yapÄ±landÄ±rma dosyalarÄ±yla Ã§alÄ±ÅŸÄ±lmaktadÄ±r. Yani oluÅŸturduÄŸumuz bileÅŸenin tÃ¼rÃ¼, adÄ±, imageâ€™i ve diÄŸer tÃ¼m seÃ§enekleri bir yapÄ±landÄ±rma dosyasÄ±nda toplanÄ±r. Sadece cubectlâ€™e bu yapÄ±landÄ±rma dosyasÄ±nÄ± yÃ¼rÃ¼tmesini sÃ¶yleriz.</p>
    <p>Bunu yapmanÄ±n yolu <code>kubectl apply</code> komutunu kullanmaktÄ±r.</p>
    <h3 id="kubectl-apply">kubectl apply</h3>
    <p>Apply, temelde dosyayÄ±, yapÄ±landÄ±rma dosyasÄ±nÄ± bir parametre olarak alÄ±r ve orada ne yazdÄ±ysak yapar.</p>
    <div class="sourceCode" id="cb26"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="ex">kubectl</span> apply -f [file_name]</span></code></pre></div>
    <p>Apply, â€œ-fâ€ iÃ§in bir seÃ§enek alÄ±r ve bu dosyanÄ±n adÄ±nÄ± belirtir ve genellikle bu dosyalar iÃ§in kullanÄ±lan biÃ§im YAMLâ€™dir ve bu, dosyadaki her ÅŸeyi yÃ¼rÃ¼ten komuttur. Bu yÃ¼zden aslÄ±nda bunu yapÄ±landÄ±rma dosyasÄ± olarak adlandÄ±racaÄŸÄ±z.</p>
    <p>Ã–rnek olarak Ã§ok basit, temel bir <code>nginx-deployment.yaml</code> deployment dosyasÄ± oluÅŸturalÄ±m.</p>
    <p>Deployment iÃ§in temel yapÄ±landÄ±rma:</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">nginx-deployment.yaml</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.16
        ports:
        - containerPort: 80
            </code></pre>
        </div>
    </div>

    <ul>
    <li>Åu an iÃ§in gerekli olan satÄ±rlarÄ±, aÅŸaÄŸÄ±da inceleyelim.</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
    kind: Deployment
        ## Ne oluÅŸturmak istediÄŸimizi belirtiyoruz, Deployment oluÅŸturmak istiyoruz.
    name: nginx-deployment
        ## OluÅŸturacaÄŸÄ±mÄ±z Deployment ismi.
    spec:            ## specification for deployment
          replicas: 1    ## Pod'lardan oluÅŸturulacak replika sayÄ±sÄ±
      template:
            metadata:
              labels:
                app: nginx
            spec:    ## specification for pods
              containers:
              - name: nginx
                image: nginx:1.16   ## Konteyner image'imiz iÃ§in nginx versiyonu
                ports:
                - containerPort: 80 ## Binding Port
        ## Bu alan olutÅŸturacaÄŸÄ±mÄ±z deployment'a ait blueprint
            </code></pre>
        </div>
    </div>

    <p>Bu, bizim config dosyamÄ±z ve buna bir kere sahip olduktan sonra, bu yapÄ±landÄ±rmayÄ± istediÄŸimiz zaman uygulayabiliriz.</p>
    <p><img src="images/54.png" /></p>
    <p>Deployment oluÅŸturuldu, ÅŸimdi podu gÃ¶rÃ¼ntÃ¼lersek, nginx daÄŸÄ±tÄ±mÄ± podu oluÅŸturuldu ve Ã§alÄ±ÅŸÄ±yor olduÄŸunu gÃ¶rÃ¼rÃ¼z.</p>
    <p><img src="images/55.png" /></p>
    <p>AyrÄ±ca daÄŸÄ±tÄ±mÄ±n 3 dakika 57 saniye Ã¶nce oluÅŸturulduÄŸunu gÃ¶rÃ¼yoruz. EÄŸer bu deploymentâ€™ta bir ÅŸeyleri deÄŸiÅŸtirmek istersek, sadece yerel yapÄ±landÄ±rmamÄ±zÄ± deÄŸiÅŸtirmemiz yeterlidir. Ã–rneÄŸin, bir yerine iki replika istersek, sadece dosyayÄ± dÃ¼zenleyip tekrar apply ederiz. Ve deployment, nginx daÄŸÄ±tÄ±mÄ± olarak tekrar yapÄ±landÄ±rÄ±lacaktÄ±r.</p>
    <p><img src="images/56.png" /></p>
    <p><img src="images/57.png" /></p>
    <p>Fark ettiysek Ã§Ä±ktÄ±da bize â€œconfiguredâ€ dendi. Fark ÅŸu ki, Kubernetes, nginx deploymentâ€™Ä±nÄ±n var olmadÄ±ÄŸÄ±nÄ± algÄ±larsa, yeni bir tane oluÅŸturacak, ancak eÄŸer deployment zaten varsa, yapÄ±landÄ±rma dosyasÄ±nÄ± apply ettiÄŸimizde, onu gÃ¼ncellemesi gerektiÄŸini bilecek ve yeni bir deployment oluÅŸturmak yerine eski deploymentâ€™Ä± cofigure edecek.</p>
    <p><img src="images/58.png" /></p>
    <p>Eski deployment hala ayakta (9m45s) fakat yeni bir replika oluÅŸturuldu(3m22s) Ã§Ã¼nkÃ¼ replika sayÄ±sÄ±nÄ± arttÄ±rdÄ±k. yani <code>kubectl apply</code> ile bir component oluÅŸturabilir ve gÃ¼ncelleyebiliriz. Elbette Services, Volumes gibi diÄŸer kubernetes bileÅŸenlerine de ayar Ã§ekebiliriz.</p>
    <hr />
    <p>Ã–zetlemek gerekirse, bu yazÄ±da birkaÃ§ kubectl komutuna baktÄ±k, bir component oluÅŸturmayÄ±, nasÄ±l configure edeceÄŸimizi ve sileceÄŸimizi gÃ¶rdÃ¼k. Podâ€™larÄ±n, deploymentâ€™larÄ±n, replikasetâ€™lerinin vb. stateâ€™lerini nasÄ±l alacaÄŸÄ±mÄ±zÄ± gÃ¶rdÃ¼k. AyrÄ±ca Podâ€™un iÃ§indeki uygulamanÄ±n konsola yazdÄ±ÄŸÄ± her ÅŸeyi nasÄ±l kaydedeceÄŸimizi gÃ¶rdÃ¼k ve <code>kubectl exec</code>â€™i kullanarak Ã§alÄ±ÅŸan bir konteynerdan nasÄ±l shell alacaÄŸÄ±mÄ±zÄ± gÃ¶rdÃ¼k. Son olarak, kubernetes yapÄ±landÄ±rma dosyasÄ±nÄ± ve <code>kubectl apply</code> komutunu kullanarak componentleri nasÄ±l oluÅŸturup gÃ¼ncelleyeceÄŸimizi gÃ¶rdÃ¼k. Son olarak azÄ±cÄ±k da <code>kubectl describe</code> komutunu gÃ¶rdÃ¼k, bu da bir konteynerin bir Podâ€™da sorun giderme iÃ§in ek bilgi almak istediÄŸinizde kullandÄ±ÄŸÄ±nÄ±z bir komuttu.</p>
    <h3 id="komutlarÄ±-hatÄ±rlayalÄ±m">KomutlarÄ± HatÄ±rlayalÄ±m</h3>
    <blockquote>

      <div class="note">
        <p> <strong>Crud KomutlarÄ±</strong><br>
           Deployment OluÅŸturma -&gt; <code>kubectl create deployment [name]</code><br>
           Deployment DÃ¼zenleme -&gt; <code>kubectl edit deployment [name]</code><br>
           Deployment Silme -&gt; <code>kubectl delete deployment [name]</code></p>
        <p><strong>FarklÄ± Kubernetes Componenetlerin Durumu</strong><code>kubectl get nodes | pod | services | replicaset | deployment</code></p>
        <p><strong>Podlar ile Debugging</strong><br>
          Pod LoglarÄ± -&gt; <code>kubectl logs [pod_name]</code><br>
          Terminal ile Poda BaÄŸlanma -&gt; <code>kubectl exec -it [pod_name] -- /bin/bash</code><br>
          Pod Bilgisi -&gt; <code>kubectl describe pod [pod_name]</code></p>
        <p><strong>CRUD iÃ§in Config DosyasÄ± Kullanma</strong><br>
          KonfigÃ¼rasyon DosyasÄ±nÄ± Uygulama -&gt; <code>kubectl apply -f [file_name]</code><br>
          KonfigÃ¼rasyon DosyasÄ±yla Silme -&gt; <code>kubectl delete -f [file_name]</code></p>
    </div>
    </blockquote>
    <hr />
    <h2 id="kubernetes-yaml-konfigÃ¼rasyonu">Kubernetes YAML KonfigÃ¼rasyonu</h2>
    <p>Bu konu baÅŸlÄ±ÄŸÄ±nda Kubernetes yapÄ±landÄ±rma dosyasÄ±nÄ±n sÃ¶zdizimini ve iÃ§eriÄŸini gÃ¶receÄŸiz.</p>
    <p><img src="images/59.png" /></p>
    <p>Bu dosya, Kubernetes clusterÄ±nda componentler oluÅŸturmak ve yapÄ±landÄ±rmak iÃ§in ana tooldur. BÃ¼yÃ¼k yapÄ±landÄ±rma dosyalarÄ±nÄ± gÃ¶rdÃ¼ysek biraz karÄ±ÅŸÄ±k olduklarÄ±nÄ± dÃ¼ÅŸÃ¼nebiliriz, ancak aslÄ±nda oldukÃ§a basit ve mantÄ±klÄ± bir yapÄ±ya sahiptir. Ã–yleyse baÅŸlayalÄ±m!</p>
    <h3 id="parÃ§ada-k8s-config-dosyasÄ±">3 ParÃ§ada K8s Config DosyasÄ±</h3>
    <p><img src="images/60.png" /></p>
    <p>YukarÄ±daki fotoÄŸrafta yan yana bir <code>deployment</code> ve <code>service</code> yapÄ±landÄ±rma dosyasÄ± Ã¶rnekleri var.</p>
    <p>Ã–ncelikle her Kubernetes config(yapÄ±landÄ±rma) dosyasÄ± Ã¼Ã§ kÄ±sÄ±mdan oluÅŸur.</p>
    <ul>
    <li>Ä°lk kÄ±sÄ±m, oluÅŸturduÄŸunuz componentin <code>metadata</code>â€™larÄ±nÄ±n bulunduÄŸu yerdir.</li>
    <li>Ä°kinci kÄ±sÄ±m, yapÄ±landÄ±rma dosyasÄ±ndaki <code>specification</code>â€™dur(Ã¶zellik). Her component config dosyasÄ±nda, o component iÃ§in uygulamak istediÄŸimiz her tÃ¼rlÃ¼ yapÄ±landÄ±rmayÄ± bu bÃ¶lÃ¼me koyarÄ±z.</li>
    </ul>
    <p><img src="images/61.png" /></p>
    <p>Config dosyasÄ±ndaki Ä°lk iki satÄ±r, tam olarak neyi oluÅŸturmak istediÄŸimizi belirtiyor. Soldaki kÄ±sÄ±mda <code>deployment</code> oluÅŸturuyoruz, saÄŸdaki kÄ±sÄ±mda ise bir <code>service</code> oluÅŸturuyoruz. Ä°lk satÄ±rlarda ise API versiyonu belirtiyoruz. Her component iÃ§in API versiyonu farklÄ± olabilir. Ve bu, her component iÃ§in bir API versiyonu araÅŸtÄ±rmanÄ±z gerektiÄŸi anlamÄ±na gelir.</p>
    <ul>
    <li><em>Kubernetesâ€™te her bileÅŸenin farklÄ± API sÃ¼rÃ¼mÃ¼ olmasÄ±nÄ±n temel nedeni, her bileÅŸenin farklÄ± gereksinimlere ve Ã¶zelliklere sahip olmasÄ±dÄ±r. Her bileÅŸenin farklÄ± bir API sÃ¼rÃ¼mÃ¼ olmasÄ±, bu bileÅŸenin Ã¶zelliklerini ve davranÄ±ÅŸÄ±nÄ± belirleyen Ã¶zelleÅŸtirilmiÅŸ bir yapÄ±ya sahip olmasÄ±nÄ± saÄŸlar.</em></li>
    </ul>
    <p>Specification kÄ±smÄ±nda belirteceÄŸimiz Ã¶zellikler, oluÅŸturduÄŸumuz component tÃ¼rÃ¼ne Ã¶zgÃ¼ olacaktÄ±r. AÅŸaÄŸÄ±daki resimde gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi:</p>
    <p><img src="images/63.png" /></p>
    <p>Deployment kendi Ã¶zelliklerine sahip olacak ve tabii servis de kendi ÅŸeylerine sahip olacak.</p>
    <p>HatÄ±rlarsak config dosyalarÄ±nÄ±n Ã¼Ã§ parÃ§adan olduÄŸunu sÃ¶ylemiÅŸtik ama ÅŸu an sadece <code>metadata</code> ve <code>specification</code>â€™u gÃ¶rdÃ¼k. Peki Ã¼Ã§Ã¼ncÃ¼ parÃ§amÄ±z nerede?</p>
    <ul>
    <li>ÃœÃ§Ã¼ncÃ¼ kÄ±sÄ±m <code>status</code>â€™tur. Kubernetes tarafÄ±ndan otomatik olarak oluÅŸturulup eklenir.</li>
    </ul>
    <p>Ã‡alÄ±ÅŸma ÅŸekli ÅŸÃ¶yledir:</p>
    <ul>
    <li><p>Kubernetes her zaman <code>desired state</code>(istenen durum) ve <code>actual state</code>â€™i(gerÃ§ek durum) karÅŸÄ±laÅŸtÄ±rÄ±r. EÄŸer gerÃ§ek durum ve istenen durum uyuÅŸmuyorsa, Kubernetes bir ÅŸeylerin dÃ¼zeltilmesi gerektiÄŸini bilir ve onu dÃ¼zeltmeye Ã§alÄ±ÅŸÄ±r.</p></li>
    <li><p>Bu, Kubernetesâ€™in saÄŸladÄ±ÄŸÄ± <code>self-healing</code> Ã¶zelliÄŸinin temelidir.</p></li>
    <li><p>Ã–rneÄŸin, yukarÄ±daki deployment kodundaki specification bÃ¶lÃ¼mÃ¼nde, nginx deployment iÃ§in iki replika istediÄŸimizi belirtmiÅŸiz. Bu config dosyasÄ±nÄ± kullanarak deployment oluÅŸturduÄŸumuzda(apply), Kubernetes, deployment status(durumunu) takip edecek, config dosyamÄ±za status parÃ§amÄ±zÄ± da ekleyecek ve bunu sÃ¼rekli olarak gÃ¼ncelleyecektir.</p></li>
    </ul>
    <p><img src="images/65.png" /></p>
    <ul>
    <li>EÄŸer status, bir noktada sadece bir replikanÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± sÃ¶ylÃ¼yorsa, Kubernetes bu statusu Ã¶zellikle belirttiÄŸimiz iki replikayla karÅŸÄ±laÅŸtÄ±racak ve bir sorun olduÄŸunu bilecektir. BaÅŸka bir replika oluÅŸturmasÄ± gerektiÄŸini anlayacak ve bunu otomatik olarak gerÃ§ekleÅŸtirecektir. <code>self-healing</code>.</li>
    </ul>
    <p><img src="images/66.png" /></p>
    <p>BunlarÄ± gÃ¶rÃ¼nce aklÄ±mÄ±za Kubernetesâ€™in, otomatik olarak buraya ekleyerek veya sÃ¼rekli olarak gÃ¼ncellemek iÃ§in status verisini nereden aldÄ±ÄŸÄ± takÄ±labilir.</p>
    <ul>
    <li>Bu bilgi daha Ã¶nce bahsettiÄŸimiz <code>etcd</code>â€™den gelir. Master processâ€™lerden biri olan etcd, aslÄ±nda cluster verilerini depolar. Etcd <strong>her zaman</strong> herhangi bir Kubernetes bileÅŸeninin mevcut durumunu tutar ve bu status bilgisi buradan gelir.</li>
    </ul>
    <h3 id="config-dosyasÄ±nÄ±n-formatÄ±">Config DosyasÄ±nÄ±n FormatÄ±</h3>
    <p>YukarÄ±daki gÃ¶rÃ¼ntÃ¼lerden de gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi config dosyalarÄ±nÄ±n formatÄ± <code>YAML</code>â€™dÄ±r. YAML oldukÃ§a basit bir formattÄ±r, ancak girintiler konusunda Ã§ok katÄ±dÄ±r. YanlÄ±ÅŸ girintiye sahip bir dosyamÄ±z varsa, bu dosya geÃ§ersiz olacaktÄ±r. Bu yÃ¼zden 200 satÄ±rdan oluÅŸan bir yapÄ±landÄ±rma dosyamÄ±z varsa, <code>YAMLlint</code> gibi bir online yaml validator kullanmak mantÄ±klÄ± olacaktÄ±r.</p>
    <p>BaÅŸka bahsedilecek bir konu da, bu config dosyalarÄ±nÄ± nereye kaydedeceÄŸimizdir. Klasik bir uygulama, kodumuzla birlikte saklamaktÄ±r. Ã‡Ã¼nkÃ¼ deployment ve servis, uygulamaya uygulanacaktÄ±r. Bu yapÄ±landÄ±rma dosyalarÄ±mÄ±zÄ±, uygulama kodunun bir parÃ§asÄ± olarak saklamak iyi bir yÃ¶ntemdir. Bunlar <code>Infrastructure as a Code</code> <strong>IaC</strong> kavramÄ±nÄ±n bir parÃ§asÄ± olabilir veya config dosyalarÄ± iÃ§in kendi git depolarÄ±mÄ±zÄ± da oluÅŸturabiliriz.</p>
    <h3 id="podlar-iÃ§in-blueprint-template">Podlar iÃ§in Blueprint (Template)</h3>
    <p>Biraz geriye gidersek deploymentâ€™larÄ±n, kendisinin altÄ±ndaki podlarÄ± yÃ¶nettiÄŸini sÃ¶ylemiÅŸtik.</p>
    <p><img src="images/67.png" /></p>
    <p>Yani bir deploymentâ€™ta bir ÅŸeyi dÃ¼zenlediÄŸimizde, bunun altÄ±ndaki bÃ¼tÃ¼n podlara yayÄ±lÄ±r ve birkaÃ§ pod oluÅŸturmak istediÄŸimizde aslÄ±nda bir deployment oluÅŸtururuz ve bu deployment gerisini halleder.</p>
    <p>*Bunlar nasÄ±l gerÃ§ekleÅŸir? Bu bahsettiÄŸimiz ÅŸeyler konfigÃ¼rasyonda nerede tanÄ±mlanÄ±r?</p>
    <p>Config dosyamÄ±zdaki, <code>specification</code> kÄ±smÄ±nda yer alan <code>template</code>â€™i geniÅŸletirsek; templateâ€™imizin de kendi <code>metadata</code>â€™sÄ±nÄ±n ve <code>specification</code>â€™u olduÄŸunu gÃ¶rÃ¼rÃ¼z.</p>
    <p><img src="images/71.png" /> Yani basitÃ§e tabir edecek olursak <strong>â€œconfiguration file inside of a configuration fileâ€</strong></p>
    <p>Bunun sebebi, template iÃ§erisindeki konfigÃ¼rasyonun bir <code>pod</code> iÃ§in geÃ§erli olmasÄ±dÄ±r. Bir podun bir deployment config dosyasÄ± iÃ§inde kendi yapÄ±landÄ±rmasÄ± olmalÄ±dÄ±r. Bu tÃ¼m deploymentâ€™larÄ±n nasÄ±l tanÄ±mlanacaÄŸÄ±nÄ± gÃ¶sterir.</p>
    <p><img src="images/72.png" /> Bu sarÄ± alan ise bir pod iÃ§in bir blueprintâ€™tir. Hangi imageâ€™e dayanacaÄŸÄ±mÄ±zÄ±, hangi portu aÃ§acaÄŸÄ±mÄ±zÄ±, konteynerin adÄ±nÄ±n ne olacaÄŸÄ±nÄ± vb. belirler.</p>
    <h3 id="connecting-components-labels-selectors-ports">Connecting Components (Labels &amp; Selectors &amp; Ports)</h3>
    <p>BaÄŸlantÄ±nÄ±n kurulduÄŸu ÅŸekil <code>labels</code> ve <code>selectors</code> kullanÄ±larak gerÃ§ekleÅŸir.</p>
    <p><img src="images/73.png" /> * Metadata bÃ¶lÃ¼mÃ¼ <code>labels</code> iÃ§erir.</p>
    <p><img src="images/74.png" /> * Specification bÃ¶lÃ¼mÃ¼ ise <code>selectors</code> iÃ§erir.</p>
    <hr />
    <p>Metadata kÄ±smÄ±nda bir componente bir <code>key-value</code> (anahtar-deÄŸer) Ã§ifti veririz. YukarÄ±daki Ã¶rnekte app: nginx var. Bu label, bu componente yapÄ±ÅŸÄ±yor.</p>
    <p>Bu ÅŸekilde, bu blueprint kullanÄ±larak oluÅŸturulan podlara <code>app: nginx</code> labeli veriyoruz ve deploymenti, â€œapp: nginxâ€ labelâ€™iyle eÅŸleÅŸen tÃ¼m labelâ€™lara baÄŸlamak veya eÅŸleÅŸtirmek iÃ§in ayarlÄ±yoruz.</p>
    <p><img src="images/75.png" /></p>
    <p>Bu sayede deployment, hangi podlarÄ±n kendisine ait olduÄŸunu bilecektir.</p>
    <p>DaÄŸÄ±tÄ±mÄ±n kendi â€œapp nginxâ€ labeli var ve bu iki label, <code>Service</code> iÃ§indeki <code>selector</code> tarafÄ±ndan kullanÄ±lÄ±r. Bu nedenle, Service iÃ§erisinde specification bÃ¶lÃ¼mÃ¼nde bir selector tanÄ±mlarÄ±z ki bu, temelde bir connection oluÅŸturur. (Service ile Deployment veya parÃ§alarÄ± arasÄ±nda)</p>
    <p><img src="images/76.png" /></p>
    <p>Ã‡Ã¼nkÃ¼ Service, kendisine kayÄ±tlÄ± olan podlarÄ±, hangi podlarÄ±n o servise ait olduÄŸunu bilmesi gerekir ve bu baÄŸlantÄ± <code>label</code>â€™Ä±n <code>selector</code> bÃ¶lÃ¼mÃ¼yle yapÄ±lÄ±r.</p>
    <ul>
    <li>Service ve pod iÃ§inde yapÄ±landÄ±rÄ±lmasÄ± gereken baÅŸka bir ÅŸey de <code>Port</code> lardÄ±r.</li>
    </ul>
    <p>Yani, servis iÃ§erisinde, servisin kendisinin eriÅŸilebilir olduÄŸu bir <em>Port</em> vardÄ±r.</p>
    <p><img src="images/77.png" /></p>
    <p>Pod iÃ§erisindeki KonteynerÄ±n da kendisine ait bir Portâ€™u vardÄ±r.</p>
    <p><img src="images/78.png" /></p>
    <p>Bu nasÄ±l yapÄ±landÄ±rÄ±lÄ±r? Temelde, bir servisin kendisinin eriÅŸilebilir olduÄŸu bir portu vardÄ±r, bu yÃ¼zden diÄŸer servisler bir istek gÃ¶nderdiÄŸinde bu nginx servisine isteÄŸi 80 numaralÄ± baÄŸlantÄ± noktasÄ±nda gÃ¶ndermelidir, ancak bu servisin, isteÄŸi hangi podâ€™a yÃ¶nlendirmesi gerektiÄŸini, aynÄ± zamanda o podâ€™un hangi portu dinlediÄŸini de bilmesi gerekir ve bu da <code>target port</code>tur.</p>
    <p><img src="images/79.png" /></p>
    <p>Alttaki resimdeki gibi saÄŸdaki servis config dosyamÄ±zdaki <code>targetPort: 8080</code>, Deployment config dosyasÄ±ndaki containerâ€™Ä±n portuyla <code>containerPort:8080</code> eÅŸleÅŸmelidir.</p>
    <p><img src="images/80.png" /></p>
    <p>BÃ¶ylelikle deployment ve servisimizin temel yapÄ±landÄ±rmalarÄ±nÄ± tamamlamÄ±ÅŸ oluruz. Burada dikkate alÄ±nmasÄ± gereken Ã¶nemli bir nokta, AÅŸaÄŸÄ±daki resimdeki her iki bÃ¶lÃ¼mde de gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z Ã§oÄŸu Ã¶zelliÄŸin zorunlu olduÄŸudur.</p>
    <p><img src="images/81.png" /><br></p>
    <p>Bu aslÄ±nda deployment ve servis iÃ§in minimum yapÄ±landÄ±rmadÄ±r.</p>
    <p>DosyalarÄ±mÄ±zÄ± elde ettikten sonra, bunlarÄ± uygulayabilir veya bunlarÄ± kullanarak bileÅŸenler oluÅŸturabiliriz. Konsola geÃ§ip oluÅŸturmadan Ã¶nce <code>nginx-deployment.yaml</code> dosyasÄ± ile <code>nginx-service.yaml</code> dosyalarÄ±nÄ±n iÃ§eriklerini buraya yazÄ±yoruz.</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">nginx-deployment.yaml</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
    apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: nginx-deployment
          labels:
            app: nginx
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: nginx
          template:
            metadata:
              labels:
                app: nginx
            spec:
              containers:
              - name: nginx
                image: nginx:1.16
                ports:
                - containerPort: 8080

    apiVersion: v1
        kind: Service
        metadata:
          name: nginx-service
        spec:
          selector:
            app: nginx
          ports:
          - protocol: TCP
            port: 80
            targetPort: 8080
            </code></pre>
        </div>
    </div>
    <p><img src="images/82.png" /> <img src="images/84.png" /></p>
    <p><code>kubectl apply deployment</code> komutuyla deployment ve servis oluÅŸturuldu.</p>
    <p>Åimdi eÄŸer podlarÄ± listelersem, burada iki replikanÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼yoruz Ã§Ã¼nkÃ¼ config dosyamÄ±zda bÃ¶yle tanÄ±mlamÄ±ÅŸtÄ±k. <img src="images/85.png" /></p>
    <p>AyrÄ±ca aÅŸaÄŸÄ±da gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi; nginx servisimiz de var.</p>
    <p><img src="images/86.png" /></p>
    <p><code>kubernetes</code> default servistir, her zaman oradadÄ±r. Bizim oluÅŸturduÄŸumuz <code>nginx-service</code> ve Port 80â€™de dinlemede.</p>
    <p>Åimdi, servisin istekleri doÄŸru podâ€™lara ilettiÄŸini nasÄ±l doÄŸrulayabiliriz? Bunun iÃ§in:</p>
    <div class="sourceCode" id="cb34"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="ex">kubectl</span> describe service [service_name]</span></code></pre></div>
    <p><img src="images/87.png" /></p>
    <p>Ve burada, status bilgilerinin olduÄŸunu gÃ¶rebiliriz. Hedef BaÄŸlantÄ± NoktasÄ±nÄ± tanÄ±mlarÄ±z ve burada endpointâ€™imiz var ve bunlar servisin isteÄŸi ileteceÄŸi podâ€™larÄ±n IP adresleri ve baÄŸlantÄ± noktalarÄ± olmalÄ±dÄ±r. Peki, bunlarÄ±n doÄŸru podâ€™larÄ±n IP adresleri olduÄŸunu nasÄ±l bileceÄŸiz? <code>kubectl get pod</code> komutu, IP adresi bilgisi vermez. Bunun iÃ§in;</p>
    <div class="sourceCode" id="cb35"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="ex">kubectl</span> get pod -o wide</span></code></pre></div>
    <p><code>-o wide</code> ile daha fazla bilgi istiyoruz.</p>
    <p><img src="images/88.png" /></p>
    <p>ArtÄ±k IP adresini de gÃ¶rÃ¼yoruz ve baktÄ±ÄŸÄ±mÄ±z zaman, servisin doÄŸru end-pointâ€™e sahip olduÄŸunu biliyoruz.</p>
    <p>Åimdi, config dosyasÄ±nÄ±n Ã¼Ã§Ã¼ncÃ¼ partÄ±nÄ± gÃ¶relim. HatÄ±rlarsak bu Kubernetesâ€™in otomatik olarak oluÅŸturduÄŸu bir durumdu. Bunu yapmanÄ±n yolu, config dosyasÄ±nÄ± yaml formatÄ±nda alabiliriz.</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl get deployment nginx-deployment -o yaml
            </code></pre>
        </div>
    </div>
    <p>bu komutu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda sonuÃ§larÄ± veya gÃ¼ncellenmiÅŸ configi alÄ±yoruz. Konsolumuzda yaml Ã§Ä±ktÄ±sÄ±nÄ± aldÄ±k fakat bunu bir dosyaya kaydedelim ve yazdÄ±ÄŸÄ±mÄ±z config ile karÅŸÄ±laÅŸtÄ±ralÄ±m.</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl get deployment nginx-deployment -o yaml > result.yaml
            </code></pre>
        </div>
    </div>
    <br>
    <p><img src="images/90.png" /></p>
    <p>Burada eklenen birÃ§ok ÅŸey var ama sadece status kÄ±smÄ±na gÃ¶z atalÄ±m. Daha Ã¶nce de belirttiÄŸimiz gibi tÃ¼m bunlar otomatik olarak kubernetes tarafÄ±ndan dÃ¼zenlenir ve sÃ¼rekli olarak gÃ¼ncellenir. KaÃ§ replikanÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±, bu replikalarÄ±n durumunu ve bazÄ± diÄŸer bilgileri belirtir. Bu kÄ±sÄ±m ayrÄ±ca debugging yaparken de yardÄ±mcÄ± olabilir. EÄŸer fark ettiysek, metadata ve specification kÄ±smÄ±na da yeni ÅŸeyler eklenmiÅŸ.</p>
    <p>Burada dikkate alÄ±nmasÄ± gereken bir ÅŸey: * Ã¶rneÄŸin, bir deploymenti kopyalamak istersek, <em>-belki otomatikleÅŸtirilmiÅŸ betikler kullanarak-</em> yapmanÄ±z gereken bu oluÅŸturulan extra verileri kaldÄ±rmak ve temizlemektir. * Yani bu son result deployment config dosyasÄ±nÄ± Ã¶nce temizlersek, ardÄ±ndan o blueprint konfigÃ¼rasyonundan baÅŸka bir deployment oluÅŸturabiliriz. * Son olarak, deploymentâ€™Ä± veya servisi silmek istersem, bunu config dosyasÄ±nÄ± kullanarak da yapabiliriz.</p>
    <div class="sourceCode" id="cb38"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a><span class="ex">kubectl</span> delete -f nginx-deployment.yml</span></code></pre></div>
    <p><img src="images/91.png" /></p>
    <hr />
    <h2 id="ilk-demo-uygulama">Ä°lk Demo Uygulama</h2>
    <p>Bu bÃ¶lÃ¼mde iki uygulama deploy edeceÄŸiz: MongoDB ve Express. Bu iki uygulama ile basit bir web app ve database kurulumunun tipik bir Ã¶rneÄŸini Ã§ok iyi gÃ¶rebileceÄŸiz. O zaman yapmaya baÅŸlayalÄ±m..<br> <img src="images/92.png" /></p>
    <ul>
    <li><p>Ä°lk olarak bir MongoDB podâ€™u oluÅŸturacaÄŸÄ±z.</p></li>
    <li><p>Bu pod ile iletiÅŸim kurabilmek iÃ§in bir servise ihtiyacÄ±mÄ±z olacak. Internal servis oluÅŸturacaÄŸÄ±z, yani bu podâ€™a dÄ±ÅŸarÄ±dan gelen(external request) istekler engellenecek ve yalnÄ±zca aynÄ± cluster iÃ§indeki componentler iletiÅŸim kurabilecek. Bu bizim istediÄŸimiz ÅŸey.</p></li>
    <li><p>Daha sonra bir Mongo Express deployment oluÅŸturacaÄŸÄ±z. Ä°ki ÅŸeye ihtiyacÄ±mÄ±z olacak: biri MongoDBâ€™nin veritabanÄ± URLâ€™si, bÃ¶ylece Express bu URLâ€™ye baÄŸlanabilecek; diÄŸeri ise veritabanÄ±nÄ±n kullanÄ±cÄ± adÄ± ve ÅŸifresi, bÃ¶ylece kimlik doÄŸrulamasÄ± yapabilecek.</p></li>
    <li><p>Bu bilgileri Mongo Express deploymentâ€™a geÃ§irebilmenin yolu, deployment config dosyasÄ±nda <code>environmental variables</code>(Ã§evresel deÄŸiÅŸkenler) aracÄ±lÄ±ÄŸÄ±yla olacak, Ã§Ã¼nkÃ¼ uygulama bu ÅŸekilde yapÄ±landÄ±rÄ±lmÄ±ÅŸ.</p></li>
    <li><p>VeritabanÄ± URLâ€™sini iÃ§eren bir <code>ConfigMap</code> ve kimlik bilgilerini iÃ§eren bir <code>Secret</code> oluÅŸturacaÄŸÄ±z ve bunlarÄ± deployment dosyasÄ±nÄ±n iÃ§ine referans olarak ekleyeceÄŸiz.</p></li>
    <li><p>Bu kurulum tamamlandÄ±ÄŸÄ±nda, Mongo Expressâ€™in tarayÄ±cÄ± Ã¼zerinden eriÅŸilebilir olmasÄ± gerekecek. Bunu yapmak iÃ§in, <code>external request</code>(dÄ±ÅŸ istek)lerin podâ€™a iletilmesine izin verecek bir <code>external service</code> oluÅŸturacaÄŸÄ±z.</p></li>
    </ul>
    <p><img src="images/93.png" /></p>
    <p>Bu kurulumla birlikte istek akÄ±ÅŸÄ± aÅŸaÄŸÄ±daki gibi gÃ¶rÃ¼necek.</p>
    <p><img src="images/94.png" /></p>
    <ul>
    <li>Ä°stek tarayÄ±cÄ±dan gelecek ve Mongo Expressâ€™in external servisine gidecek.</li>
    <li>Bu servis isteÄŸi Mongo Express podâ€™una iletecek.</li>
    <li>Pod, MongoDBâ€™nin internal servisine baÄŸlanacak ve isteÄŸi MongoDB podâ€™una iletecek. Burada kimlik doÄŸrulama yapÄ±lacak. <strong>Åimdi bu kurulumun tamamÄ±nÄ± Kubernetes yapÄ±landÄ±rma dosyalarÄ±nÄ± kullanarak oluÅŸturalÄ±m.</strong></li>
    </ul>
    <h3 id="mongodb-pod">a) MongoDB Pod</h3>
    <p>Ä°lk olarak, Ã§alÄ±ÅŸan bir Minikube clusterÄ±mÄ±z var. <code>kubectl get all</code> komutunu kullanarak kÃ¼medeki tÃ¼m bileÅŸenleri listelediÄŸimde yalnÄ±zca default Kubernetes servisini gÃ¶rÃ¼yoruz.</p>
    <p><img src="images/95.png" /></p>
    <p>Yani clusterÄ±mÄ±z boÅŸ ve sÄ±fÄ±rdan baÅŸlÄ±yoruz. Ä°lk yapacaÄŸÄ±mÄ±z ÅŸey bir MongoDB deployment oluÅŸturmak.</p>
    <p><img src="images/96.png" /></p>
    <p>MongoDB iÃ§in hazÄ±r olan deployment dosyasÄ± aÅŸaÄŸÄ±daki ÅŸekilde.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">mongodb-deployment.yaml</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: mongodb-deployment
      labels:
        app: mongodb
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: mongodb
      template:
        metadata:
          labels:
            app: mongodb
        spec:
          containers:
          - name: mongodb
            image: mongo
        </code></pre>
    </div>
</div>
    <p>Bu daÄŸÄ±tÄ±ma <code>mongodb-deployment</code> adÄ±nÄ± verelim. Konteyner <code>mongodb</code> olarak adlandÄ±rÄ±lacak ve kullanacaÄŸÄ±mÄ±z image bu olacak. Hadi Docker-Hubâ€™a gidip MongoDB image yapÄ±landÄ±rmasÄ±nÄ± kontrol edelim. * https://hub.docker.com/_/mongo</p>
    <p>AradÄ±ÄŸÄ±mÄ±z ÅŸey, bu konteyneri nasÄ±l kullanacaÄŸÄ±mÄ±z, yani hangi portlarÄ± aÃ§acaÄŸÄ± ve hangi harici yapÄ±landÄ±rmalarÄ± alacaÄŸÄ±z.</p>
    <p><img src="images/97.png" /></p>
    <p>MongoDB konteynerinin varsayÄ±lan portu 27017â€™miÅŸ, bu yÃ¼zden bunu kullanacaÄŸÄ±z.</p>
    <p>AyrÄ±ca <code>Environment Variables</code>(Ã§evresel deÄŸiÅŸkenler) kullanacaÄŸÄ±z.</p>
    <p><img src="images/98.png" /></p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">mongodb-deployment.yaml</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: mongodb-deployment
      labels:
        app: mongodb
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: mongodb
      template:
        metadata:
          labels:
            app: mongodb
        spec:
          containers:
          - name: mongodb
            image: mongo
            ports:
            - containerPort: 27017
            env:
            - name: MONGO_INITDB_ROOT_USERNAME
              value:
            - name: MONGO_INITDB_ROOT_PASSWORD
              value:
        </code></pre>
    </div>
</div>
    <ul>
    <li><code>ports</code> Ã¶zelliÄŸi ve <code>containerPort</code> ile hangi portu aÃ§mak istediÄŸimizi belirttik. Standart portu kullandÄ±k. AltÄ±nda iki environment variables(<code>env</code>) belirttik.</li>
    <li>Birincisi <code>MONGO_INITDB_ROOT_USERNAME</code> ve boÅŸ bÄ±rakacaÄŸÄ±z.</li>
    <li>DiÄŸeri ise <code>MONGO_INITDB_ROOT_PASSWORD</code> olacak ve bunu da boÅŸ bÄ±rakacaÄŸÄ±z.</li>
    </ul>
    <blockquote>
    <p> <strong>Åunu unutmamalÄ±yÄ±z ki bu, bir repository iÃ§ine kaydedilecek bir config dosyasÄ±dÄ±r. Bu yÃ¼zden admin kullanÄ±cÄ± adÄ± ve ÅŸifresini yapÄ±landÄ±rma dosyasÄ±nÄ±n iÃ§ine yazmamalÄ±yÄ±z.</strong></p>
    </blockquote>
    <h3 id="secret-ve-referans">b) Secret ve Referans</h3>
    <p>Åimdi yapacaÄŸÄ±mÄ±z ÅŸey, deÄŸerleri referans alacaÄŸÄ±mÄ±z bir <code>secret</code> oluÅŸturmak olacak.</p>
    <p><img src="images/100.png" /></p>
    <p>Yani bu gizli dosya Kubernetesâ€™te yer alacak ve kimse git reposunda buna eriÅŸemeyecek. <strong>Secret lives in K8s, not in the repository</strong></p>
    <p>Åimdilik az Ã¶nce yazdÄ±ÄŸÄ±mÄ±z henÃ¼z bitmemiÅŸ olan deployment config dosyasÄ±nÄ± kaydedelim. AdÄ±nÄ± <code>mongo-depoyment.yml</code> olarak koyup kaydedelim.</p>
    <p>Åimdi bu yapÄ±landÄ±rmayÄ± apply etmeden Ã¶nce, root kullanÄ±cÄ± adÄ± ve ÅŸifresinin yer alacaÄŸÄ± <code>Secret</code> oluÅŸturacaÄŸÄ±z. Yeni bir dosya oluÅŸturalÄ±m ve aÅŸaÄŸÄ±daki <em>Secret</em> configi yapÄ±ÅŸtÄ±ralÄ±m.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: v1
    kind: Secret
    metadata:
      name: mongodb-secret
    type: Opaque
    data:
      username:
      password:
        </code></pre>
    </div>
</div>

    <p>OldukÃ§a basit bir yapÄ±sÄ± var. * <code>kind: Secret</code> var. * <code>metadata</code> var, ve bu sadece adÄ±nÄ± iÃ§eriyor. Buna <code>mongodb-secret</code> diyeceÄŸiz. * <code>type: Opaque</code> aslÄ±nda en temel <code>key-value</code> secret tÃ¼rÃ¼dÃ¼r. DiÄŸer tÃ¼rler Ã¶rneÄŸin TLS sertifikalarÄ±nÄ± iÃ§erir. Yani bir gizli dosya oluÅŸturabiliriz ve bunu TLS sertifikasÄ± tÃ¼rÃ¼nde yapabiliriz. Ancak Ã§oÄŸunlukla default tÃ¼rÃ¼ (Opaque) kullanacaÄŸÄ±z. * <code>data</code> var ve burada <code>key-value</code> Ã§iftleri bulunuyor. Elbette bunlar bizim belirlediÄŸimiz isimler olacak. Mesela data kÄ±smÄ±nda deÄŸiÅŸiklik yapalÄ±m.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
data:
      mongo-root-username:
      mongo-root-password:
        </code></pre>
    </div>
</div>

    <ul>
    <li>KullanÄ±cÄ± adÄ±nÄ± <code>root-username</code> ve ÅŸifreyi <code>root-password</code> olarak belirleyeceÄŸiz.</li>
    </ul>
    <blockquote>
    <p> <strong>Buradaki Ã¶nemli nokta, bu anahtar-deÄŸer Ã§iftlerindeki deÄŸerlerin dÃ¼z metin olmamasÄ±dÄ±r. Bir gizli dosya oluÅŸtururken deÄŸerlerin base64 ile kodlanmasÄ± gerekir.</strong></p>
    </blockquote>
    <p>Bunu yapmanÄ±n en basit yolu terminale gitmektir. Burada, <code>echo -n</code> komutunu kullanacaÄŸÄ±z.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
echo -n "username" | base64
echo -n "password" | base64
        </code></pre>
    </div>
</div>

    <p>Buraya istediÄŸim dÃ¼z metin deÄŸerini koyalÄ±m. <code>username</code> ve <code>password</code> kullanalÄ±m ve base64 ile kodlayalÄ±m. Elde ettiÄŸimiz deÄŸerleri secret confige kopyalayalÄ±m.</p>
    <p><img src="images/101.png" /></p>
    <p>TamamladÄ±ktan sonra dosyayÄ± <code>mongo-secret.yaml</code> olarak kaydedelim.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">mongo-secret.yaml</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: v1
    kind: Secret
    metadata:
      name: mongodb-secret
    type: Opaque
    data:
      mongo-root-username: dXNlcm5hbWU=
      mongo-root-password: cGFzc3dvcmQ=
        </code></pre>
    </div>
</div>

    <p>Åimdiye kadar sadece config dosyalarÄ± yazdÄ±k, clusterda henÃ¼z bir ÅŸey oluÅŸturmadÄ±k. Deploymenti referans alacaÄŸÄ±mÄ±z secretâ€™tan Ã¶nce oluÅŸturmalÄ±yÄ±z. EÄŸer secret iÃ§ermeyen bir deployment oluÅŸturursak, hata alÄ±rÄ±z ve deployment baÅŸlatÄ±lamaz.</p>
    <p>Ä°lk componentimiz hazÄ±r olduÄŸuna gÃ¶re, ÅŸimdi config dosyasÄ±ndan bir secret oluÅŸturabiliriz. Åu an her iki dosyamÄ±z da mevcut.</p>
    <p><img src="images/102.png" /></p>
    <p>AÅŸaÄŸÄ±daki komutu Ã§alÄ±ÅŸtÄ±rÄ±yoruz ve <code>secret</code> oluÅŸturuluyor.</p>
    <div class="sourceCode" id="cb45"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a><span class="ex">kubectl</span> apply -f mongo-secret-yaml</span></code></pre></div>
    <p><img src="images/103.png" /></p>
    <p>SecretlarÄ±mÄ±zÄ± listelemek iÃ§in de aÅŸaÄŸÄ±daki komutu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda, Yeni Secretâ€™Ä±mÄ±zÄ±n oluÅŸturulduÄŸunu gÃ¶rmeliyiz.</p>
    <div class="sourceCode" id="cb46"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a><span class="ex">kubectl</span> get secret</span></code></pre></div>
    <p><img src="images/104.png" /></p>
    <p>ArtÄ±k Secretâ€™Ä±mÄ±zÄ± deployment config dosyamÄ±zda referans alabiliriz. Config dosyamÄ±za geri dÃ¶nelim ve Secretâ€™taki belirli <code>key-value</code> verilerini referans alalÄ±m.</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
    env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: mongo-root-username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: mongo-root-password
            </code></pre>
        </div>
    </div>

    <ul>
    <li><code>value</code> yerine <code>valueFrom</code> yazÄ±yoruz ve altÄ±na <code>secretKeyRef</code> yazÄ±yoruz.</li>
    <li><code>secretKeyRef</code> nameâ€™i, <code>Secret</code> dosyamÄ±zÄ±n adÄ± olacak.</li>
    <li><code>key</code> deÄŸerini almak iÃ§in de, Secret dosyamÄ±zdan isimleriyle referans alacaÄŸÄ±z. <code>mongo-root-username</code>, <code>mongo-root-password</code>.</li>
    </ul>
    <p><img src="images/105.png" /></p>
    <p>Bu ÅŸekilde referans almayÄ± tamamlÄ±yoruz.</p>
    <ul>
    <li>UnutmayÄ±n, YAML dosyasÄ± girintilere Ã§ok dikkat eder.</li>
    </ul>
    <p>BÃ¶ylece root kullanÄ±cÄ± adÄ± ve ÅŸifresi, Secretâ€™tan referans alÄ±nacak ve config dosyasÄ±nÄ±n iÃ§inde gerÃ§ek deÄŸerler bulunmayacak. Bu gÃ¼venlik aÃ§Ä±sÄ±ndan oldukÃ§a iyidir Ã§Ã¼nkÃ¼ kimlik bilgilerimizin kod reposunda bulunmasÄ±nÄ± asla istemeyiz.</p>
    <p>Deployment dosyamÄ±z artÄ±k hazÄ±r, ArtÄ±k apply edebiliriz.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectl apply -f [YAML_file]
        </code></pre>
    </div>
</div>



    <p><img src="images/106.png" /> <img src="images/107.png" /></p>
    <p>Deployment oluÅŸturuldu, yani <code>get all</code> komutunu Ã§alÄ±ÅŸtÄ±rÄ±rsam Podâ€™un baÅŸlatÄ±ldÄ±ÄŸÄ±nÄ±, deploymenti ve ReplicaSetâ€™i gÃ¶rmeliyim.</p>
    <p>Åimdi Podâ€™un statusunu kontrol edelim. Konteyner oluÅŸturuluyor, bu yÃ¼zden izlememiz gerekiyor. EÄŸer uzun sÃ¼rerse ve bir sorun olup olmadÄ±ÄŸÄ±nÄ± gÃ¶rmek isterseniz, <code>kubectl describe pod</code> ve Pod adÄ±mÄ±zÄ± yazÄ±yoruz.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectl describe pod [POD_NAME]
        </code></pre>
    </div>
</div>

    <p><img src="images/108.png" /></p>
    <p>GÃ¶rÃ¼yoruz ki sadece image Ã§ekiyor, bu yÃ¼zden uzun sÃ¼rÃ¼yor.</p>
    <p>Tekrar <code>kubectl get pod</code> komutunu Ã§alÄ±ÅŸtÄ±rÄ±rsak, Podâ€™un Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶receÄŸiz. Åu anda bir MongoDB deployment ve bir replika Pod Ã§alÄ±ÅŸÄ±yor.</p>
    <p><img src="images/109.png" /></p>
    <h3 id="mongodb-internal-service">c) MongoDB Internal Service</h3>
    <p><img src="images/110.png" /></p>
    <p>Åimdiki adÄ±mda, diÄŸer componentlerin veya diÄŸer Podâ€™larÄ±n bu MongoDB ile konuÅŸabilmesi iÃ§in bir <code>internal service</code> oluÅŸturacaÄŸÄ±z. Ã–nce servisconfiguration oluÅŸturalÄ±m.</p>
    <p>YAML dosyamÄ±za geri dÃ¶nelim.</p>
    <blockquote>
    <p><strong>YAMLâ€™da tek dosyada, birden fazla yaml yazabiliriz. YAMLâ€™da 3 tire <code>---</code> belge ayÄ±rma sÃ¶zdizimidir. Yani yeni bir belge baÅŸladÄ±ÄŸÄ±nÄ± belirtmiÅŸ oluyoruz.</strong></p>
    </blockquote>
    <p>Hatta deployment ve servisi aynÄ± config dosyasÄ±na koyabiliriz Ã§Ã¼nkÃ¼ genelde bu iki dosya birlikte bulunur.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">mongodb-service.yaml</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: mongodb-deployment
      labels:
        app: mongodb
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: mongodb
      template:
        metadata:
          labels:
            app: mongodb
        spec:
          containers:
          - name: mongodb
            image: mongo
            ports:
            - containerPort: 27017
            env:
            - name: MONGO_INITDB_ROOT_USERNAME
              valueFrom:
                secretKeyRef:
                  name: mongodb-secret
                  key: mongo-root-username
            - name: MONGO_INITDB_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mongodb-secret
                  key: mongo-root-password
    ---
    apiVersion: v1
    kind: Service
    metadata:
      name: mongodb-service
    spec:
      selector:
        app: mongodb
      ports:
        - protocol: TCP
          port: 27017
          targetPort: 27017
        </code></pre>
    </div>
</div>

    <p>Bu MongoDB iÃ§in bir servis. BazÄ± nitelikleri gÃ¶zden geÃ§irelim.</p>
    <ul>
    <li><code>kind: Service</code> ve <code>name: mongodb-service</code> olarak adlandÄ±rdÄ±k.</li>
    <li><code>selector</code> Ã¶nemli Ã§Ã¼nkÃ¼ biz bu oluÅŸturacaÄŸÄ±mÄ±z servisin Podâ€™a baÄŸlanmasÄ±nÄ± istiyoruz ve bunu yapmanÄ±n yolu Servisten <code>selector</code>, Deploymentâ€™tan <code>label</code> kullanmaktÄ±r. Bu etiketleri kullanarak, deployment ve Podâ€™un sahip olduÄŸu labellarÄ±, servis bulup baÄŸlanabilir.</li>
    <li><code>ports:</code> Burada servisin baÄŸlantÄ± noktasÄ±nÄ± (port) aÃ§Ä±yoruz.
    <ul>
    <li><code>port: 27017</code> Servis portudur.</li>
    <li><code>targetPort: 27017</code> Konteyner veya Pod portudur. Deployment config iÃ§erisindeki <code>containerPort</code> ile, Servisteki <code>targetPort</code> birbiriyle eÅŸleÅŸmelidir. Tabii ki, bu iki baÄŸlantÄ± noktasÄ± <em>farklÄ± olabilir</em>, ama biz bu seferlik aynÄ± portu kullanalÄ±m.</li>
    </ul></li>
    </ul>
    <p>Hadi ÅŸimdi servisi oluÅŸturalÄ±m. Bu dosyayÄ± kaydedelim ve aynÄ± dosyayÄ± tekrar uygulayalÄ±m. BÃ¶ylece az Ã¶nce deployment oluÅŸturulduÄŸu gibi ÅŸimdi de servis oluÅŸacak. BakalÄ±m ne olacak?</p>
    <p><img src="images/111.png" /></p>
    <p>Hem daÄŸÄ±tÄ±m hem de servis yapÄ±landÄ±rmasÄ± olmasÄ±na raÄŸmen, Kubernetes deploymenti deÄŸiÅŸtirmediÄŸimizi anlÄ±yor. Bu nedenle sadece servisi oluÅŸturuyor.</p>
    <p>Åimdi servisimizin oluÅŸturulduÄŸunu kontrol edelim.</p>
    <div class="sourceCode" id="cb51"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span class="ex">kubectl</span> get services</span></code></pre></div>
    <p><img src="images/112.png" /></p>
    <p>OluÅŸan servisimiz 27017 portunda dinliyor. HatÄ±rlarsanÄ±z, servisin doÄŸru Podâ€™a baÄŸlÄ± olup olmadÄ±ÄŸÄ±nÄ± da kontrol edebiliyorduk. Bunu yapmak iÃ§in;</p>
    <div class="sourceCode" id="cb52"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a><span class="ex">kubectl</span> describe service [SERVICE_NAME]</span></code></pre></div>
    <p><img src="images/113.png" /></p>
    <p>Burada bir IP adresi ve Podâ€™un iÃ§inde dinleyen uygulama portu var. Bu doÄŸru Pod olup olmadÄ±ÄŸÄ±nÄ± kontrol edelim. <code>-o wide</code> ile ek Ã§Ä±ktÄ±yla Ã§alÄ±ÅŸtÄ±rÄ±yorum.</p>
    <div class="sourceCode" id="cb53"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a><span class="ex">kubectl</span> get pod -o wide</span></code></pre></div>
    <p><img src="images/114.png" /></p>
    <p>Bu IP adresi, Pod IP adresi ile eÅŸleÅŸiyor ve uygulamanÄ±n Pod iÃ§inde dinlediÄŸi port doÄŸru.</p>
    <p>Her ÅŸey mÃ¼kemmel ÅŸekilde ayarlandÄ±. MongoDB daÄŸÄ±tÄ±mÄ± ve servisi oluÅŸturuldu.</p>
    <blockquote>
    <p> Bir uygulamanÄ±n tÃ¼m componentlerini gÃ¶rmek istersek, <code>kubectl get all</code> ve <code>grep</code> komutunu birlikte kullanabiliriz. BÃ¶ylece hem tÃ¼m componentleri listeleyip hem de isme gÃ¶re filtreleyebiliriz.</p>
    </blockquote>
    <p><img src="images/115.png" /></p>
    <p>Ä°ÅŸte bu ÅŸekilde tek komutla servisimizi, deploymentÄ±mÄ±zÄ±, replicasetimizi ve Podumuzu gÃ¶rÃ¼ntÃ¼leyebiliriz. TÃ¼m component tipleri burada gÃ¶rÃ¼nÃ¼yor.</p>
    <h3 id="mongo-express-deployment-service-configmap">d) Mongo Express Deployment &amp; Service &amp; ConfigMap</h3>
    <p><img src="images/116.png" /></p>
    <p>Åimdi sÄ±radaki adÄ±mda, <code>Mongo Express Deployment ve Servisi</code> oluÅŸturacaÄŸÄ±z. AyrÄ±ca MongoDB iÃ§in veritabanÄ± URLâ€™sini iÃ§eren <code>External Configuration</code> oluÅŸturacaÄŸÄ±z. Yeni bir dosya oluÅŸturarak baÅŸlayalÄ±m.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: mongo-express
      labels:
        app: mongo-express
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: mongo-express
      template:
        metadata:
          labels:
            app: mongo-express
        spec:
          containers:
          - name: mongo-express
            image: mongo-express
        </code></pre>
    </div>
</div>

    <p>Bu, MongoExpress deployment taslaÄŸÄ±. Ä°sim <code>express</code>. * <code>template:</code> Pod tanÄ±mÄ±mÄ±z var. Image adÄ± <code>express</code>. Bu imajÄ± da kontrol edelim. image adÄ± <code>mongo-express</code>.</p>
    <p>*https://hub.docker.com/_/mongo-express*</p>
    <p><img src="images/117.png" /></p>
    <p>Konteyner iÃ§indeki MongoExpress Port 8081â€™deymiÅŸ. Biraz aÅŸaÄŸÄ± inersek de Ã§evresel deÄŸiÅŸkenleri(environmental variables) gÃ¶rebiliriz.</p>
    <ul>
    <li>MongoExpress iÃ§in Ã¼Ã§ ÅŸeye ihtiyacÄ±mÄ±z var: MongoDB adresi(veritabanÄ± adresi) ve kimlik doÄŸrulama bilgileri.
    <ul>
    <li>MongoDB Adresi -&gt; â€¦MONGODB_SERVER</li>
    <li>Kimlik DoÄŸrulama BÄ°lgileri -&gt; â€¦ADMIN_USERNAME, â€¦ADMIN_PASSWORD</li>
    </ul></li>
    </ul>
    <p><img src="images/118.png" /></p>
    <p>Bu Ã§evresel deÄŸiÅŸkenleri kullanacaÄŸÄ±z. O zaman ilk olarak konteyner portlarÄ±nÄ± aÃ§abiliriz.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
...
    ...
      template:
        metadata:
          labels:
            app: mongo-express
        spec:
          containers:
          - name: mongo-express
            image: mongo-express
            ports:
            - containerPort: 8081
        </code></pre>
    </div>
</div>

    <ul>
    <li>Ä°Ã§erideki Podâ€™da birden fazla port aÃ§abileceÄŸimiz iÃ§in birden fazla port olabileceÄŸi anlamÄ±na gelen <code>ports</code> kullanÄ±lÄ±r. Bu deÄŸerimiz, 8081 olacak.</li>
    </ul>
    <p>Åimdi baÄŸlantÄ± iÃ§in <code>ENV</code>(environment variables) ekleyeceÄŸiz.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
...
    ...
            ports:
            - containerPort: 8081
            env:
            - name: ME_CONFIG_MONGODB_ADMINUSERNAME
              valueFrom:
                secretKeyRef:
                  name: mongodb-secret
                  key: mongo-root-username
            - name: ME_CONFIG_MONGODB_ADMINPASSWORD
              valueFrom:
                secretKeyRef:
                  name: mongodb-secret
                  key: mongo-root-username
        </code></pre>
    </div>
</div>

    <p>Tabiiki tanÄ±mladÄ±ÄŸÄ±mÄ±z aynÄ± kullanÄ±cÄ± adÄ± ve ÅŸifre, deploymentta tanÄ±mladÄ±ÄŸÄ±mÄ±z ile aynÄ± olacak. Bu yÃ¼zden yaptÄ±ÄŸÄ±mÄ±z ÅŸey onlarÄ± kopyalamak. AynÄ± <code>valueFrom</code> ile zaten orada olan secret iÃ§erisinden okumuÅŸ olacaÄŸÄ±z.</p>
    <p>Son olarak database server:</p>

<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
...
    ...
            - name: ME_CONFIG_MONGODB_ADMINPASSWORD
              valueFrom:
                secretKeyRef:
                  name: mongodb-secret
                  key: mongo-root-username
            - name: ME_CONFIG_MONGODB_SERVER
              value:
        </code></pre>
    </div>
</div>
    <p>Bu da harici bir yapÄ±landÄ±rma olduÄŸu iÃ§in ya burada <code>value</code> kullanabilir ve mongodb sunucu adresini doÄŸrudan buraya yazabiliriz. Ya da diyagramda gÃ¶sterildiÄŸi gibi, merkezi bir yapÄ±landÄ±rma olan bir configmapâ€™e koyabiliriz. Bu ÅŸekilde merkezi bir yerde saklanÄ±r ve diÄŸer componentler de kullanabilir. * Ã–rneÄŸin, iki uygulamam mongodb veritabanÄ±nÄ± kullanÄ±yorsa, bu harici yapÄ±landÄ±rmayÄ± referans alabiliriz ve bir noktada deÄŸiÅŸiklik yapmamÄ±z gerekirse; sadece bir yerde deÄŸiÅŸiklik yaparak diÄŸer dosyalarÄ± gÃ¼ncellemeden devam edebiliriz. Bu nedenle, ÅŸu an iÃ§in eksik olan bu deployment configi kenara kaydedip, mongodb sunucu adresini iÃ§eren configmapâ€™i oluÅŸturacaÄŸÄ±z. Yeni bir dosya oluÅŸturalÄ±m, bu eksik daÄŸÄ±tÄ±mÄ± kaydedelim, adÄ±nÄ± <code>mongo-express.yaml</code> koyalÄ±m ve daha sonra geri dÃ¶nelim!</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: v1
    kind: ConfigMap
    metadata:
      name: mongodb-configmap
    data:
      database_url:
        </code></pre>
    </div>
</div>

    <p>Bu da secret key gibi oldukÃ§a basit. Beraber gÃ¶z atalÄ±m: * <code>kind: ConfigMap</code> olan aynÄ± Secret gibi bir yapÄ± gÃ¶rÃ¼yoruz.</p>
    <p><img src="images/119.png" /> * TÄ±pkÄ± yukarÄ±da gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi <code>data</code> iÃ§erisinde <code>key-value</code> Ã§ifti var. * <code>type:</code> yok Ã§Ã¼nkÃ¼ sadece configmapin sadece bir tÃ¼rÃ¼ var. SonuÃ§ olarak veritabanÄ± URLâ€™si ve server adÄ± aslÄ±nda Servisin adÄ±. Bu kadar basit.</p>
    <p>Hizmetimize <code>mongodb-service</code> adÄ±nÄ± vermiÅŸtik. Bu yÃ¼zden hizmet adÄ±nÄ± kopyalayalÄ±m ve bunu veritabanÄ± sunucusu URLâ€™sine yazalÄ±m. DosyayÄ± mongo-configmap.yaml olarak kaydedelim.</p>
    <blockquote>
    <p> Gizli anahtar gibi, Ã§alÄ±ÅŸtÄ±rma veya oluÅŸturma sÄ±rasÄ± Ã¶nemlidir. ConfigMapâ€™in zaten clusterda olmasÄ± gerekiyor ki onu referans alabilelim. Bu yÃ¼zden iÅŸimiz bittiÄŸinde, Ã¶nce configmapâ€™i oluÅŸturmalÄ± daha sonra deploymenti yapmalÄ±yÄ±z.</p>
    </blockquote>
    <p>YapÄ±landÄ±rma haritasÄ±nÄ± deployment iÃ§inde referans almaya geldik. mongo-express.yaml dosyamÄ±za geri dÃ¶nelim.</p>
    <blockquote>
    <p> YapÄ±landÄ±rma haritasÄ±nÄ± deployment iÃ§inde referans almanÄ±n yolu gizli anahtara Ã§ok benzer. Tek fark burada <code>secret</code> yerine <code>configMap</code> yazacaÄŸÄ±z. TamamÄ± kÃ¼Ã§Ã¼k ve bÃ¼yÃ¼k harf karÄ±ÅŸÄ±k olacak ve elbette adÄ± <code>config map</code> olacak.</p>
    <p><img src="images/120.png" /></p>
    </blockquote>
    <p>Deploymenti tamamladÄ±k. Åimdi Ã¶nce config mapâ€™i ve sonra Express daÄŸÄ±tÄ±mÄ±nÄ± oluÅŸturalÄ±m.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectl apply -f mongo-configmap.yaml
kubectl apply -f mongo-express.yaml
        </code></pre>
    </div>
</div>

    <br>
    <p><img src="images/121.png" /></p>
    <p>Herhangi bir hata almadÄ±k. Podâ€™un durumuna bakalÄ±m.</p>
    <div class="sourceCode" id="cb60"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a><span class="ex">kubectl</span> get pod</span></code></pre></div>
    <p><img src="images/122.png" /></p>
    <p>Konteyner oluÅŸturuluyor. Gayet iyi. Biraz bekleyip tekrar kontrol edelim ve bum!</p>
    <p><img src="images/123.png" /></p>
    <p>DoÄŸru Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenmek iÃ§in LoglarÄ± gÃ¶rÃ¼ntÃ¼lemek Ã¶nemlidir.</p>
    <div class="sourceCode" id="cb61"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a><span class="ex">kubectl</span> logs [POD_NAME]</span></code></pre></div>
    <p><img src="images/124.png" /></p>
    <h3 id="mongo-express-external-service">e) Mongo Express External Service</h3>
    <p><img src="images/131.png" /></p>
    <p>Åimdi son adÄ±mÄ±mÄ±z, Expressâ€™e bir tarayÄ±cÄ±dan eriÅŸmektir. Bunu yapmak iÃ§in mongo-express iÃ§in bir External Service ihtiyacÄ±mÄ±z olacak. Ã–yleyse hadi bunu da oluÅŸturalÄ±m.</p>
    <blockquote>
    <p> Daha Ã¶nce yaptÄ±ÄŸÄ±mÄ±z gibi yine MongoExpress servisimizi, deploymentÄ± ile aynÄ± dosyada oluÅŸturacaÄŸÄ±z. Ã‡Ã¼nkÃ¼ zaten pratikte hiÃ§bir zaman servis olmadan deploymentÄ± olmaz. Bu yÃ¼zden onlarÄ± aynÄ± yaml dosyasÄ±nda yazmak mantÄ±klÄ±dÄ±r.</p>
    </blockquote>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
---
    apiVersion: v1
    kind: Service
    metadata:
      name: mongo-express-service
    spec:
      selector:
        app: mongo-express
      ports:
        - protocol: TCP
          port: 8081
          targetPort: 8081
        </code></pre>
    </div>
</div>

    <p>Deployment dosyamÄ±zÄ±n devamÄ±na yukarÄ±daki servis configi yapÄ±ÅŸtÄ±rÄ±yoruz. Bu, Mongo Expressâ€™in external servisi ve bu farkettiyseniz tamamen mongodb servisinin yapÄ±landÄ±rmasÄ±yla aynÄ± gÃ¶rÃ¼nÃ¼yor.</p>
    <p><img src="images/125.png" /></p>
    <ul>
    <li>Servis portunu 8081 olarak aÃ§tÄ±k ve yine target Port, container Portâ€™un dinlediÄŸi yerdir.</li>
    </ul>
    <p><strong>Peki bu servisi external(harici) yapacak olan ÅŸey nedir?</strong> Bu servisi iki ÅŸey yaparak external yaparÄ±z:</p>
    <ol type="1">
    <li><code>spec</code> bÃ¶lÃ¼mÃ¼nde, <code>selector</code> altÄ±na <code>type: Loadbalancer</code> yazarÄ±z.</li>
    </ol>
    <blockquote>
    <p> SanÄ±yoruz ki <code>external servis</code> iÃ§in bu isim â€œLoadBalancerâ€ olarak dÃ¼zgÃ¼n seÃ§ilmemiÅŸ Ã§Ã¼nkÃ¼ <code>internal servis</code> de istekleri dengeleyip Load Balance yapabilir. Ä°ki mongodb podumuz olsa, internal servis de bu podlara gelen istekleri dengeleyebilirdi. Yani gerÃ§ekten de tÃ¼r adÄ± olarak <code>Load Balancer</code> seÃ§ilmesi Ã§ok iyi deÄŸil gibi Ã§Ã¼nkÃ¼ kafa karÄ±ÅŸÄ±klÄ±ÄŸÄ±na neden olabilir. Ancak, bu yÃ¼k dengeleyici tÃ¼rÃ¼ basitÃ§e servise <code>external IP adres</code>i atar ve <code>external request</code>leri kabul eder.</p>
    </blockquote>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: v1
    kind: Service
    metadata:
      name: mongo-express-service
    spec:
      selector:
        app: mongo-express
      type: LoadBalancer         ## Tam burasÄ±..
      ports:
        - protocol: TCP
          port: 8081
          targetPort: 8081
        </code></pre>
    </div>
</div>

    <ol start="2" type="1">
    <li><code>nodePort: 30000</code></li>
    </ol>
    <p>YapacaÄŸÄ±mÄ±z ikinci ÅŸey ise, bu servisi harici yapmak iÃ§in Ã¼Ã§Ã¼ncÃ¼ bir port saÄŸlamak. Bu da node port olacak ve bu, External IP adresinin aÃ§Ä±k olacaÄŸÄ± port olacak. AyrÄ±ca belirtelim ki bu port, TarayÄ±cÄ±dan eriÅŸmek iÃ§in kullanacaÄŸÄ±mÄ±z port olacak.</p>
    <p>Bu port aslÄ±nda bir aralÄ±ÄŸa sahiptir ve bu aralÄ±k 30000 ile 32767 arasÄ±ndadÄ±r, yani bu aralÄ±kta bir port vermemiz gerekiyor, bu yÃ¼zden sadece 30000 ile gidelim, aralÄ±ktaki minimumdur.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: v1
    kind: Service
    metadata:
      name: mongo-express-service
    spec:
      selector:
        app: mongo-express
      type: LoadBalancer
      ports:
        - protocol: TCP
          port: 8081
          targetPort: 8081
          nodePort: 30000
        </code></pre>
    </div>
</div>

    <p>ArtÄ±k hazÄ±r olduÄŸumuza gÃ¶re uygulamaya geÃ§ebiliriz. ArdÄ±ndan bu baÄŸlantÄ± noktalarÄ±nÄ±n nasÄ±l farklÄ± olduklarÄ±na bakalÄ±m.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectl apply -f mongo-express.yaml
        </code></pre>
    </div>
</div>

    <p>Hizmet oluÅŸturuldu ve hizmeti <code>kubectl get service</code> ile gÃ¶rÃ¼ntÃ¼lersek, Ã¶nceden oluÅŸturduÄŸumuz mongodb servisinin <code>ClusterIP</code>â€™ tipinde olduÄŸunu gÃ¶rÃ¼yoruz ve yeni oluÅŸturduÄŸumuz mongo express servisinin bir <code>LoadBalancer</code> olduÄŸunu gÃ¶rÃ¼yoruz.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
c3ng0@ubn:~/hxhdle/kubernetto$ kubectl get service
    NAME                    TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
    kubernetes              ClusterIP      10.96.0.1        <none>        443/TCP          6d1h
    mongo-express-service   LoadBalancer   10.96.100.133    <pending>     8081:30000/TCP   9s
    mongodb-service         ClusterIP      10.111.249.213   <none>        27017/TCP        95m
        </code></pre>
    </div>
</div>

    <p>Internal servis oluÅŸtururken herhangi bir tÃ¼r belirtmedik Ã§Ã¼nkÃ¼ zaten default olarak internal IP hizmeti tÃ¼rÃ¼dÃ¼r.</p>
    <blockquote>
    <p> Ä°nternal Servis oluÅŸtururken <code>type</code> belirtmeye gerek yok Ã§Ã¼nkÃ¼ zaten default olarak tanÄ±mlanÄ±r.<br> <img src="images/126.png" /></p>
    </blockquote>
    <p>Fark ise; * ClusterIP, servise internal IP adresi verir. AÅŸaÄŸÄ±da gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi:</p>
    <div class="sourceCode" id="cb67"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true"></a><span class="ex">mongodb-service</span>         ClusterIP      10.111.249.213   <span class="op">&lt;</span>none<span class="op">&gt;</span>        27017/TCP        95m</span></code></pre></div>
    <ul>
    <li>LoadBalancer, servise bir internal IP adresi verir, ancak bununla birlikte external isteklerin geleceÄŸi external IP adresi de verir. <em>(pending)</em></li>
    </ul>
    <div class="sourceCode" id="cb68"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true"></a><span class="ex">mongo-express-service</span>   LoadBalancer   10.96.100.133    <span class="op">&lt;</span>pending<span class="op">&gt;</span>     8081:30000/TCP   9s</span></code></pre></div>
    <ul>
    <li>Åu an bize <code>pending</code> diyor Ã§Ã¼nkÃ¼ minicubeâ€™deyiz ve bu normal kubernetes kurulumunda biraz daha farklÄ± Ã§alÄ±ÅŸÄ±r.</li>
    </ul>
    <p>DediÄŸim gibi, â€œpendingâ€ durumu external IP adresini henÃ¼z almadÄ±ÄŸÄ± anlamÄ±na gelir. Bu durumu Minikubeâ€™da yapmanÄ±n yolu <code>minikube service</code> komutunu kullanmaktÄ±r ve servisin adÄ±na ihtiyacÄ±mÄ±z olacak.</p>
    <div class="sourceCode" id="cb69"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true"></a><span class="ex">minikube</span> service mongo-express-service</span></code></pre></div>
    <p>Bu komut temelde external servisimize bir genel IP adresi atayacak. Komutu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda tarayÄ±cÄ± aÃ§Ä±lacak ve karÅŸÄ±mÄ±za ÅŸu sayfa Ã§Ä±kacak:</p>
    <p><img src="images/127.png" /></p>
    <p>EÄŸer aÃ§Ä±lÄ±rken kullanÄ±cÄ± adÄ± ve ÅŸifre sorarsa <code>admin:pass</code> olarak yazabiliriz.</p>
    <p>Ve Mongo Express sayfamÄ±zÄ± gÃ¶rÃ¼yoruz. Komut satÄ±rÄ±na geri dÃ¶nersek, buradaki bu komut Express servisini Public IP adresli URL atadÄ±ÄŸÄ±nÄ± ve bizim belirttiÄŸimiz 30000 portunu kullandÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼yoruz.</p>
    <p><img src="images/128.png" /></p>
    <p>Burada deÄŸiÅŸiklikler yaparsak, Ã¶rneÄŸin yeni bir veritabanÄ± oluÅŸturalÄ±m, ona testDB adÄ±nÄ± verelim ve Create Database ile isteÄŸi gÃ¶nderelim.</p>
    <p><img src="images/129.png" /></p>
    <p>Arka planda olan ÅŸeyi ÅŸu ÅŸekilde aÃ§Ä±klayabiliriz. * Bu isteÄŸin Mongo Expressâ€™in external servisine ulaÅŸmasÄ± * ArdÄ±ndan Mongo Express poduna yÃ¶nlendirilmesidir. * Express podu, Internal servis olan mongodb servisine baÄŸlanÄ±r. * Mongodb servisi, isteÄŸimizi sonunda mongodb Poduna iletir. * Sonra tÃ¼m bu yol geri gelir ve burada deÄŸiÅŸiklikleri gÃ¶rÃ¼rÃ¼z.</p>
    <p><img src="images/130.png" /></p>
    <p>Basit bir uygulama kurulumunu bir Kubernetes kÃ¼mesinde nasÄ±l daÄŸÄ±tacaÄŸÄ±nÄ±zÄ± bÃ¶yle anlatmÄ±ÅŸ olduk. Bu yaptÄ±ÄŸÄ±mÄ±z demo uygulamanÄ±n dosyalarÄ±nÄ± <code>ilkuygulamademo</code> dizinine koydum.</p>
    <hr />
    <h2 id="kubernetes-namespaces">Kubernetes Namespaces</h2>
    <p>Bu konu baÅŸlÄ±ÄŸÄ±nda , <code>Namespaces</code> kullanÄ±mlarÄ±ndan bahsedeceÄŸiz.</p>
    <p><img src="images/132.png" /></p>
    <h3 id="namespace-nedir">Namespace Nedir</h3>
    <p>Ã–ncelikle, Kubernetesâ€™te <code>Namespace</code> nedir? Kubernetes clusterÄ±nda, kaynaklarÄ± namespaces ile organize edebiliriz. Yani, bir clusterda birden fazla namespace olabilir. Bir namespaceâ€™i, Kubernetes kÃ¼mesi iÃ§inde sanal bir cluster olarak dÃ¼ÅŸÃ¼nebiliriz.</p>
    <p><img src="images/133.png" /></p>
    <h3 id="default-namespaces">Default Namespaces</h3>
    <p>Bir cluster oluÅŸturduÄŸumuzda, Kubernetes bize varsayÄ±lan olarak bazÄ± namespaceâ€™ler saÄŸlar. Komut satÄ±rÄ±nda <code>kubectl get namespaces</code> yazarsak, Kubernetesâ€™in varsayÄ±lan olarak sunduÄŸu namespace listesini gÃ¶rÃ¼rÃ¼z.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl get namespace
    NAME              STATUS   AGE
    default           Active   6d3h
    kube-node-lease   Active   6d3h
    kube-public       Active   6d3h
    kube-system       Active   6d3h
        </code></pre>
    </div>
</div>

    <p>Åimdi, bunlarÄ± tek tek inceleyelim. * 1) <code>kube-system</code> <code>kube-system</code> namespace, bizim kullanÄ±mÄ±mÄ±za yÃ¶nelik deÄŸildir. Yani, bu namespaceâ€™te herhangi bir ÅŸey oluÅŸturmamalÄ± veya deÄŸiÅŸtirmemeliyiz. Bu namespaceâ€™te yer alan componentler, sistem sÃ¼reÃ§leri, yÃ¶netici sÃ¼reÃ§ler veya <code>kubectl</code> gibi bileÅŸenlerdir.</p>
    <ul>
    <li><ol start="2" type="1">
    <li><code>kube-public</code> Genel olarak eriÅŸilebilir veriler bulunur. Bu namespaceâ€™te, cluster bilgilerini iÃ§eren ve kimlik doÄŸrulama olmadan bile eriÅŸilebilen bir ConfigMap bulunur. <code>kubectl cluster-info</code> yazarsak, bu ConfigMap bilgilerinin Ã§Ä±ktÄ±sÄ±nÄ± alÄ±rÄ±z.</li>
    </ol></li>
    </ul>
    <p><img src="images/134.png" /></p>
    <ul>
    <li><ol start="3" type="1">
    <li><code>kube-node-lease</code> Bu namespaceâ€™in amacÄ±, nodelarÄ±n kalp atÄ±ÅŸ bilgilerini tutmaktÄ±r. Her node, kendisinin kullanÄ±labilirlik bilgilerini iÃ§eren kendi objesini alÄ±r.</li>
    </ol></li>
    <li><ol start="4" type="1">
    <li><code>default</code> default namespace, baÅŸlangÄ±Ã§ta yeni bir namespace oluÅŸturmadÄ±ysak, kaynaklarÄ± oluÅŸturmak iÃ§in kullanacaÄŸÄ±mÄ±z alandÄ±r.</li>
    </ol></li>
    </ul>
    <p><img src="images/135.png" /></p>
    <p>Tabii ki, yeni namespace ekleyip oluÅŸturabiliriz. Bunu yapmak iÃ§in, <code>kubectl create namespace</code> komutunu, namespace adÄ±yla birlikte kullanabiliriz. BÃ¶ylece, kendi namespaceâ€™imizi oluÅŸturabilir ve <code>kubectl get namespaces</code> yazarsak, namespaceâ€™imiz listede gÃ¶rÃ¼necektir.</p>
    <div class="sourceCode" id="cb71"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true"></a><span class="ex">kubectl</span> create namespace my-namespace</span></code></pre></div>
    <p>Namespace oluÅŸturmanÄ±n bir diÄŸer yolu, namespace config file kullanmaktÄ±r. Bu, namespace oluÅŸturmanÄ±n daha kaliteli bir yoludur. Ã‡Ã¼nkÃ¼ bu ÅŸekilde config file reposunda, clusterda hangi kaynaklarÄ± oluÅŸturduÄŸumuzun geÃ§miÅŸi de olur.</p>
    <p><img src="images/136.png" /></p>
    <h3 id="ne-zaman-nasÄ±l-namespace-oluÅŸturmalÄ±">Ne Zaman &amp; NasÄ±l Namespace OluÅŸturmalÄ±</h3>
    <p>Åimdi, namespacesâ€™in ne olduÄŸunu, yeni namespaces oluÅŸturabileceÄŸimizi ve Kubernetesâ€™in default olarak bazÄ± namespaceâ€™ler sunduÄŸunu gÃ¶rdÃ¼k. Ancak, asÄ±l soru ÅŸu: namespaceâ€™e neden ihtiyaÃ§ var? Ne zaman ve nasÄ±l namespaces oluÅŸturmalÄ±yÄ±z?</p>
    <p>BazÄ± use case durumlarÄ±ndan bahsedelim:</p>
    <ol type="1">
    <li><strong>Kaynaklar Namespacesâ€™ta GruplanÄ±rsa</strong>: VarsayalÄ±m ki, Kubernetes tarafÄ±ndan saÄŸlanan tek bir default namespaceâ€™a sahibiz ve tÃ¼m kaynaklarÄ±mÄ±zÄ± bu default namespacesâ€™da oluÅŸturuyoruz. EÄŸer karmaÅŸÄ±k bir uygulamamÄ±z varsa ve bu uygulama birÃ§ok deployment iÃ§eriyorsa, bu deploymentlar birÃ§ok kopya oluÅŸturuyorsa ve servisler, ConfigMap gibi kaynaklarÄ±mÄ±z varsa, Ã§ok kÄ±sa sÃ¼rede varsayÄ±lan namespaceâ€™imiz farklÄ± componentlerle dolup taÅŸacaktÄ±r. Bu durumda, neyin ne olduÄŸunu gÃ¶zlemlemek de zor olacaktÄ±r, Ã¶zellikle de birden fazla kullanÄ±cÄ± iÃ§erik oluÅŸturuyorsa..</li>
    </ol>
    <p><img src="images/137.png" /></p>
    <p>BÃ¶yle bir durumda namespacesâ€™i kullanmanÄ±n daha iyi bir yolu, kaynaklarÄ± namespacesâ€™ta gruplandÄ±rmaktÄ±r. Ã–rneÄŸin, veritabanÄ±mÄ±zÄ± ve gerekli tÃ¼m kaynaklarÄ±nÄ± daÄŸÄ±tacaÄŸÄ±mÄ±z bir veritabanÄ± namespace oluÅŸturabiliriz. Monitoring araÃ§larÄ±mÄ±zÄ± daÄŸÄ±tacaÄŸÄ±mÄ±z bir monitoring namespace oluÅŸturabiliriz. Elasticsearch ve Kibana gibi kaynaklarÄ± daÄŸÄ±tacaÄŸÄ±mÄ±z bir Elastic Stack namespace oluÅŸturabiliriz. Bu ÅŸekilde kaynaklarÄ±mÄ±zÄ± cluster iÃ§inde mantÄ±ksal olarak gruplandÄ±rabiliriz.</p>
    <p><img src="images/138.png" /></p>
    <p>Kubernetesâ€™in resmi dokÃ¼mantasyonuna gÃ¶re, eÄŸer kÃ¼Ã§Ã¼k projelerimiz ve 10â€™a kadar kullanÄ±cÄ±mÄ±z varsa, namespaces kullanmamalÄ±yÄ±z. Ancak Ninaâ€™nÄ±n kiÅŸisel gÃ¶rÃ¼ÅŸÃ¼ne gÃ¶re, kaynaklarÄ±mÄ±zÄ± namespacesâ€™ta gruplandÄ±rmak her zaman iyi bir fikirdir. Ã‡Ã¼nkÃ¼ kÃ¼Ã§Ã¼k bir projeye ve 10 kullanÄ±cÄ±ya sahip olsak bile, uygulamamÄ±z iÃ§in monitoring ve logging gibi ek kaynaklara ihtiyaÃ§ duyabiliriz.</p>
    <ol start="2" type="1">
    <li><strong>Conflicts: Birden Fazla TakÄ±m, AynÄ± Proje:</strong> Namespaces kullanmamÄ±z gereken bir diÄŸer use case, birden fazla takÄ±mÄ±mÄ±z olduÄŸunda ortaya Ã§Ä±kar. Bu senaryoda, aynÄ± clusterâ€™Ä± kullanan iki takÄ±mÄ±mÄ±z olduÄŸunu varsayalÄ±m. Bir takÄ±m, <code>my-app-deployment</code> adlÄ± bir deployment oluÅŸturur ve bu deployment belirli bir konfigÃ¼rasyona sahiptir. EÄŸer diÄŸer takÄ±m, aynÄ± ada sahip ancak farklÄ± bir konfigÃ¼rasyona sahip bir deployment oluÅŸturursa ve bunu uygularsa(apply), ilk takÄ±mÄ±n deploymentâ€™Ä±nÄ± geÃ§ersiz kÄ±labilir. Jenkins veya otomatik bir deployment aracÄ± kullanÄ±yorlarsa, diÄŸer takÄ±mÄ±n deploymentâ€™Ä±nÄ± bozduklarÄ±nÄ±n farkÄ±na bile varmazlar.</li>
    </ol>
    <p><img src="images/139.png" /></p>
    <p>Bu tÃ¼r Ã§akÄ±ÅŸmalarÄ± Ã¶nlemek iÃ§in namespaces kullanabiliriz. Her takÄ±m, kendi namespaceâ€™inde Ã§alÄ±ÅŸarak diÄŸerini rahatsÄ±z etmeden rahatÃ§a Ã§alÄ±ÅŸabilir.</p>
    <p><img src="images/140.png" /></p>
    <ol start="3" type="1">
    <li><strong>Kaynak PaylaÅŸÄ±mÄ±: Staging ve Development:</strong> Namespaces kullanmanÄ±n bir diÄŸer use caseâ€™i, aynÄ± clusterda hem staging hem de development ortamlarÄ±nÄ± barÄ±ndÄ±rmak istediÄŸimizde ortaya Ã§Ä±kar. Bu durumda, Ã¶rneÄŸin nginx controller veya Elasticsearch gibi kaynaklarÄ± her iki ortamda da kullanabiliriz. Bu ÅŸekilde, bu ortak kaynaklarÄ± iki farklÄ± clusterda da kurmak zorunda kalmayÄ±z. Hem staging hem de development ortamÄ± bu kaynaklarÄ± kullanabilir.</li>
    </ol>
    <p><img src="images/141.png" /></p>
    <ol start="3" type="1">
    <li><strong>Kaynak PaylaÅŸÄ±mÄ±: Blue/Green Deployment:</strong> NamespacesnÄ± kullanmanÄ±n bir diÄŸer durumu, Blue/Green deployment stratejisini kullandÄ±ÄŸÄ±mÄ±zda ortaya Ã§Ä±kar. Bu durumda, aynÄ± clusterda iki farklÄ± production sÃ¼rÃ¼mÃ¼ne sahip olmak isteriz . Biri aktif olan ve ÅŸu anda production olan sÃ¼rÃ¼m, diÄŸeri ise bir sonraki production sÃ¼rÃ¼mÃ¼ olacaktÄ±r. Bu durumda, her iki Ã¼retim namespace da ortak kaynaklarÄ± kullanabilir, Ã¶rneÄŸin nginx controller veya Elasticsearch gibi.</li>
    </ol>
    <p><img src="images/142.png" /></p>
    <ol start="4" type="1">
    <li><strong>Namespacesâ€™e EriÅŸimi ve KaynaklarÄ± SÄ±nÄ±rlama:</strong> namespacesnÄ± kullanmanÄ±n bir diÄŸer durumu, kaynaklarÄ± ve eriÅŸimi sÄ±nÄ±rlamaktÄ±r. Birden fazla takÄ±mÄ±n aynÄ± clusterda Ã§alÄ±ÅŸtÄ±ÄŸÄ± senaryoda, her takÄ±mÄ±n kendi namespaceâ€™nde Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlayabilir ve diÄŸer namespacesâ€™te hiÃ§bir ÅŸey yapmalarÄ±na izin vermeyiz. Bu ÅŸekilde, bir takÄ±mÄ±n diÄŸerinin iÅŸine mÃ¼dahale etme riskini azaltÄ±rÄ±z. AyrÄ±ca, namespace dÃ¼zeyinde kaynak kotalarÄ± tanÄ±mlayarak her takÄ±mÄ±n ne kadar CPU, RAM ve depolama kullanabileceÄŸini de sÄ±nÄ±rlayabiliriz. Bu, bir takÄ±mÄ±n Ã§ok fazla kaynak tÃ¼ketmesini ve diÄŸer takÄ±mlarÄ±n kaynaklarÄ±nÄ±n tÃ¼kenmesini Ã¶nler.</li>
    </ol>
    <p><img src="images/143.png" /></p>
    <p>Bu senaryolarÄ± inceledikten sonra, projenizde namespacesnÄ± nasÄ±l kullanmamÄ±z gerektiÄŸini daha iyi analiz edebileceÄŸimizi umuyoruz.</p>
    <h3 id="namespaces-Ã¶zellikleri">NameSpaces Ã–zellikleri</h3>
    <p>Namespacesâ€™imizi nasÄ±l gruplandÄ±racaÄŸÄ±mÄ±za ve kullanacaÄŸÄ±mÄ±za karar vermeden Ã¶nce dikkate almamÄ±z gereken birkaÃ§ Ã¶zellik var.</p>
    <ul>
    <li>Ä°lk olarak, Ã§oÄŸu kaynaÄŸa baÅŸka bir namespacendan eriÅŸemeyiz. Ã–rneÄŸin, bir namespaceâ€™teki bir ConfigMap, baÅŸka bir namespaceâ€™teki bir Servisi referans alÄ±yorsa, bu ConfigMapâ€™i baÅŸka bir namespaceâ€™de kullanamayÄ±z. AynÄ± referans ve aynÄ± ConfigMap olsa bile: <strong>her namespace iÃ§in, kendi ConfigMapâ€™ini tanÄ±mlamamÄ±z gerekecektir</strong>. AÅŸaÄŸÄ±daki resimde bunun Ã¶rneÄŸi vardÄ±r. Project A iÃ§erisindeki ConfigMap, Database servisine referans edilmiÅŸtir. Bu sebeple bu ConfigMap, Project B iÃ§in kullanÄ±lamaz. AynÄ± ConfigMap projectB iÃ§erisinde de oluÅŸturulmalÄ±dÄ±r ve referans edilmelidir.</li>
    </ul>
    <p><img src="images/144.png" /></p>
    <p>Bu, Secretâ€™lar iÃ§in de geÃ§erlidir. Ã–rneÄŸin, ortak bir servisin kimlik bilgilerine sahipseniz, bu kimlik bilgilerini her namespaceâ€™de oluÅŸturmamÄ±z gerekecektir. Ancak, namespaceâ€™ler arasÄ±nda paylaÅŸabileceÄŸimiz bir kaynak tÃ¼rÃ¼ <code>Servis</code>lerdir.</p>
    <p>Bir configMap, bir namespaceâ€™deki servisi referans aldÄ±ÄŸÄ±nda, URLâ€™sinde namespace adÄ± da eklenir. Bu ÅŸekilde, diÄŸer namespaceâ€™lerdeki servislere eriÅŸebiliriz. Bu, Elasticsearch veya nginx gibi paylaÅŸÄ±lan kaynaklarÄ± kullanmanÄ±n pratik bir yoludur.</p>
    <p><img src="images/145.png" /></p>
    <p>Kubernetesâ€™teki bazÄ± componentler namespace olmadan clusterda global olarak bulunur. Bu componentler, namespaceâ€™a ait olmayan componenetler olarak adlandÄ±rÄ±lÄ±r. Ã–rneÄŸin, Volumeâ€™ler veya nodeâ€™lar cluster genelinde eriÅŸilebilir.</p>
    <p>Namespaceâ€™siz componentleri listelemek iÃ§in:</p>
    <div class="sourceCode" id="cb72"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true"></a><span class="ex">kubectl</span> api-resources --namespaced=false</span></code></pre></div>
    <p>Namespaced componentleri listelemek iÃ§in:</p>
    <div class="sourceCode" id="cb73"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a><span class="ex">kubectl</span> api-resources --namespaced=true</span></code></pre></div>
    <p>Åimdi, namespacesnÄ±n ne olduÄŸunu, ne zaman ve nasÄ±l kullanmamÄ±z gerektiÄŸini Ã¶ÄŸrendik. AyrÄ±ca, bazÄ± Ã¶zellikleri dikkate almamÄ±z gerektiÄŸini de Ã¶ÄŸrendik.</p>
    <h3 id="namespaces-component-oluÅŸturma">Namespaces Component OluÅŸturma</h3>
    <p>Åimdi, namespaceâ€™te component oluÅŸturmayÄ± gÃ¶relim. Bir Ã¶nceki Ã¶rnekte, config dosyalarÄ±nÄ± kullanarak componentler oluÅŸturduk ve namespace belirtmedik. Bu durumda, componentler varsayÄ±lan olarak default namespaceâ€™te oluÅŸturuldu.</p>

<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: v1
    kind: ConfigMap
    metadata:
      name: mysql-configmap
    data:
      db_url: mysql-service.database
        </code></pre>
    </div>
</div>



    <p>Bu configMap componentini apply edelim: <code>kubectl apply -f config-map</code> komutunu uygularsak ve <code>kubectl get config-map</code> komutunu Ã§alÄ±ÅŸtÄ±rÄ±rsak, config map default namespaceâ€™te oluÅŸturulmuÅŸ olur.</p>
    <blockquote>
    <p> Dikkat edin ki <code>kubectl get config-map</code> komutunda bile bir ad alanÄ± kullanmadÄ±k Ã§Ã¼nkÃ¼ <code>kubectl get</code> veya <code>kubectl</code> komutlarÄ± varsayÄ±lan ad alanÄ±nÄ± <code>default</code> olarak alÄ±r. Yani <code>kubectl get config-map</code> komutu aslÄ±nda <code>kubectl get config-map -n default</code> ile aynÄ±dÄ±r, bu nedenle bu komutlar aynÄ±dÄ±r.</p>
    </blockquote>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl apply -f mysql-configmap.yaml
    configmap/mysql-configmap created

    c3ng0@ubn:~$ kubectl get configmap
    NAME                DATA   AGE
    kube-root-ca.crt    1      6d4h
    mongodb-configmap   1      5h1m
    mysql-configmap     1      6s

    c3ng0@ubn:~$ kubectl get configmap -n default
    NAME                DATA   AGE
    kube-root-ca.crt    1      6d4h
    mongodb-configmap   1      5h1m
    mysql-configmap     1      18s
        </code></pre>
    </div>
</div>

    <p>Bu, varsayÄ±lan olarak varsayÄ±lan ad alanÄ±nÄ± aldÄ±ÄŸÄ± iÃ§in bir kÄ±sayoldur.</p>
    <ul>
    <li>Bu config mapâ€™i belirli bir namespace ile oluÅŸturmanÄ±n bir yolu, <code>kubectl apply</code> komutunu kullanmak ve <code>--namespace</code> bayraÄŸÄ±nÄ± eklemek. ArdÄ±ndan namespace adÄ±nÄ± eklemektir. Bu, config mapâ€™i belirli bir namespace ile oluÅŸturacaktÄ±r ve bu sadece bir yoludur.</li>
    </ul>
    <div class="sourceCode" id="cb76"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true"></a><span class="ex">kubectl</span> apply -f mysql-configmap.yaml --namespace=my-namespace</span></code></pre></div>
    <ul>
    <li>BaÅŸka bir yol, config dosyasÄ±nÄ±n kendisinde yapmaktÄ±r. Bu configmap yapÄ±landÄ±rma dosyasÄ±nÄ± ayarlayarak, hedef namespace bilgilerini ekleyebiliriz. Yani, metadata iÃ§inde <code>namespace</code> Ã¶zelliÄŸini ekleyebiliriz.</li>
    </ul>
    <p><img src="images/146.png" /></p>
    <ul>
    <li>Bu config dosyasÄ±nÄ± tekrar <code>kubectl apply</code> komutuyla uygularsak ve bu namespace alanÄ±nda oluÅŸturduÄŸumuz bileÅŸeni almak istersek, <code>kubectl get</code> komutuna bayraÄŸÄ± eklememiz gerekir Ã§Ã¼nkÃ¼ varsayÄ±lan olarak Ã§alÄ±ÅŸtÄ±rÄ±rsak, sadece default namespaceâ€™leri kontrol eder. Nina, <code>namespace</code> Ã¶zniteliÄŸini yapÄ±landÄ±rma dosyasÄ±nda kullanmamÄ±zÄ± tavsiye ediyor. Ã‡Ã¼nkÃ¼</li>
    </ul>
    <ol type="1">
    <li>Daha iyi belgelenmektedir. Sadece yapÄ±landÄ±rma dosyasÄ±na bakarak componentin nerede oluÅŸturulduÄŸunu bilebiliriz ve bu Ã¶nemli bir bilgi olabilir.</li>
    <li>Otomatik daÄŸÄ±tÄ±m kullanÄ±yorsak ve sadece config dosyalarÄ±nÄ± uyguluyorsak, bu daha uygun bir yol olacaktÄ±r.</li>
    </ol>
    <p>Ã–rneÄŸin, bir ekibin kendi namespaceâ€™ine sahip olduÄŸu ve tamamen bu namespace ile Ã§alÄ±ÅŸmasÄ± gerektiÄŸi bir senaryo dÃ¼ÅŸÃ¼nÃ¼rsek, her <code>kubectl</code> komutuna bu namespace etiketini eklemek oldukÃ§a sinir bozucu olabilir. Bu yÃ¼zden, default veya aktif namespaceâ€™in; varsayÄ±lan namespaceâ€™ten seÃ§tiÄŸimizi herhangi bir namespaceâ€™e deÄŸiÅŸtirmek iÃ§in bir yol var. AracÄ±mÄ±zÄ±n adÄ± <code>Kubens</code>. Bu aracÄ± yÃ¼klememiz gerekiyor.</p>
    <p>Ubuntuâ€™da indirmek iÃ§in:</p>
    <p><code>kubectx</code> ve <code>kubens</code> depolarÄ±nÄ± klonlayalÄ±m:</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
git clone https://github.com/ahmetb/kubectx.git ~/.kubectx
sudo ln -s ~/.kubectx/kubectx /usr/local/bin/kubectx
sudo ln -s ~/.kubectx/kubens /usr/local/bin/kubens
        </code></pre>
    </div>
</div>

    <p>Ä°ndirilen dosyalarÄ±n Ã§alÄ±ÅŸtÄ±rÄ±labilir olduÄŸundan emin olalÄ±m:</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
chmod +x ~/.kubectx/kubectx
chmod +x ~/.kubectx/kubens
        </code></pre>
    </div>
</div>

    <p><code>kubectx</code> ve <code>kubens</code>â€™i kontrol edelim:</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectx
kubens
        </code></pre>
    </div>
</div>

    <p><code>kubens</code> yÃ¼klendikten sonra, sadece <code>kubens</code> komutunu Ã§alÄ±ÅŸtÄ±rabiliriz. Bu bize tÃ¼m namespaceâ€™lerin bir listesini verir ve ÅŸu anda aktif olanÄ± (varsayÄ±lan olanÄ±) vurgular.</p>
    <p><img src="images/147.png" /></p>
    <p>Aktif namespaceâ€™i deÄŸiÅŸtirmek istersek:</p>
    <pre><code>kubens &lt;Namespace_ismi&gt;</code></pre>
    <p>komutunu Ã§alÄ±ÅŸtÄ±rabiliriz. Aktif ad alanÄ±nÄ± deÄŸiÅŸtirecektir. <code>kubens</code> komutunu tekrar Ã§alÄ±ÅŸtÄ±rÄ±rsak, aktif olanÄ±n yeni namespaceâ€™iniz olduÄŸunu gÃ¶rÃ¼rÃ¼z. Bu ÅŸekilde, <code>kubectl</code> komutlarÄ±nÄ± namespace saÄŸlamadan Ã§alÄ±ÅŸtÄ±rabiliriz. Ancak, namespaceâ€™ler arasÄ±nda Ã§ok sÄ±k geÃ§iÅŸ yapÄ±yorsak, bu bizim iÃ§in pek uygun olmayacaktÄ±r.</p>
    <hr />
    <h2 id="kubernetes-ingress-explained">Kubernetes Ingress Explained</h2>
    <p><img src="images/148.png" /></p>
    <p>Bu konuda Ingressâ€™in ne olduÄŸundan, nasÄ±l kullanÄ±lacaÄŸÄ±ndan ve farklÄ± kullanÄ±m senaryolarÄ±ndan bahsedeceÄŸiz.</p>
    <h3 id="external-service-vs-ingress">External Service vs Ingress</h3>
    <p>Ã–ncelikle, basit bir Kubernetes clusterâ€™Ä± hayal edelim. Bu clusterâ€™Ä±mÄ±zda, uygulamamÄ±zÄ±n bir Podâ€™u ve buna karÅŸÄ±lÄ±k gelen bir Servisi (hizmeti) olan <code>my-app-service</code> var. Bir UI uygulamasÄ± iÃ§in ilk gereksinim, uygulamanÄ±n tarayÄ±cÄ± Ã¼zerinden eriÅŸilebilir olmasÄ±dÄ±r. Bu, dÄ±ÅŸarÄ±dan gelen isteklerin uygulamaya ulaÅŸabilmesi anlamÄ±na gelir. Bunun iÃ§in kolay bir yol, uygulamaya HTTP protokolÃ¼ kullanarak, nodeâ€™un IP adresi ve portu aracÄ±lÄ±ÄŸÄ±yla eriÅŸmek olan bir external service (dÄ±ÅŸ hizmet) kullanmaktÄ±r.</p>
    <p><img src="images/149.png" /></p>
    <p>Ancak, bu yÃ¶ntem test durumlarÄ± ve hÄ±zlÄ± bir ÅŸeyler denemek iÃ§in uygundur, nihai Ã¼rÃ¼n bÃ¶yle olmamalÄ±dÄ±r. Nihai Ã¼rÃ¼n ÅŸu ÅŸekilde olmalÄ±dÄ±r: UygulamamÄ±zÄ±n bir alan adÄ± (domain name) ve gÃ¼venli bir HTTPS baÄŸlantÄ±sÄ± olmalÄ±dÄ±r. Bunu yapmanÄ±n yolu, Kubernetes componenti olan Ingressâ€™i kullanmaktÄ±r. Bu durumda, <code>my-app-ingress</code> adÄ±nda bir Ingressâ€™e ve external service(dÄ±ÅŸ hizmet) yerine bir internal serviceâ€™e(iÃ§ hizmete) sahip oluruz. Yani uygulamamÄ±za IP adresi ve port Ã¼zerinden deÄŸil, Ingress aracÄ±lÄ±ÄŸÄ±yla eriÅŸiriz. TarayÄ±cÄ±dan gelen istek Ã¶nce Ingressâ€™e ulaÅŸÄ±r, ardÄ±ndan Ingress bu isteÄŸi iÃ§ hizmete yÃ¶nlendirir ve en sonunda Podâ€™a ulaÅŸÄ±r.</p>
    <p><img src="images/150.png" /></p>
    <h4 id="external-service-yaml-config">External Service YAML Config</h4>
    <p>Åimdi, external service yapÄ±landÄ±rmasÄ±nÄ±n nasÄ±l gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ne bir gÃ¶z atalÄ±m.</p>
    <p><img src="images/151.png" /></p>
    <p>Servisin <code>loadBalancer</code> tÃ¼rÃ¼nde olduÄŸunu gÃ¶rÃ¼rÃ¼z. Bu, servise bir <code>external IP</code> adresi atayarak publicâ€™e aÃ§tÄ±ÄŸÄ±mÄ±z anlamÄ±na gelir. KullanÄ±cÄ± bu IP adresi ve belirlenen port numarasÄ±nÄ± kullanarak uygulamaya eriÅŸebilir.</p>
    <h4 id="ingress-yaml-config">Ingress YAML Config</h4>
    <p>Ingress ile bu konfigÃ¼rasyon farklÄ±dÄ±r. Ingressâ€™in syntaxâ€™Ä±na bakalÄ±m.</p>
    <p><img src="images/152.png" /></p>
    <ul>
    <li><code>kind: Ingress</code> ile Ingress olduÄŸunu belirtiriz.</li>
    <li><code>spec</code> tÃ¼m yapÄ±landÄ±rmanÄ±n olduÄŸu yerdir.
    <ul>
    <li><code>rules</code> veya routing rules aracÄ±lÄ±ÄŸÄ±yla yapÄ±lÄ±r. Bu tanÄ±mlanan rules, belirli bir hosta yapÄ±lan tÃ¼m isteklerin internal servise yÃ¶nlendirilmesini tanÄ±mlar. <em>(YukarÄ±da net bir ÅŸekilde gÃ¶sterilmiÅŸtir.)</em> KullanÄ±cÄ± tarayÄ±cÄ±da bu hostun adresini girer ve Ingress, bu istekleri internal servise yÃ¶nlendirir.</li>
    <li><code>paths</code> ise alan adÄ±ndan sonraki URL yolunu ifade eder. Domain nameâ€™den sonra gelen herÅŸeyi paths iÃ§erisinde tanÄ±mlarÄ±z. <img src="images/153.png" /></li>
    </ul></li>
    </ul>
    <p>Åu anda yapÄ±landÄ±rmada HTTPS baÄŸlantÄ±sÄ± iÃ§in herhangi bir ÅŸey ayarlanmamÄ±ÅŸtÄ±r, sadece HTTP protokolÃ¼ kullanÄ±lÄ±yor. Ingress componentini kullanarak HTTPS yapÄ±landÄ±rmasÄ±nÄ±n nasÄ±l yapÄ±lacaÄŸÄ±nÄ± az sonra gÃ¶receÄŸiz.</p>
    <blockquote>
    <p> Config iÃ§erisindeki <code>http</code>, URL adresindeki HTTP veya HTTPSâ€™i ifade etmiyor. Bu, gelen isteÄŸin internal servise yÃ¶nlendirildiÄŸi protokoldÃ¼r. 1. AdÄ±m: tarayÄ±cÄ±dan Ingressâ€™e istek gÃ¶nderilmesilidir Config iÃ§erisindeki <code>http</code> ise ikinci adÄ±mdÄ±r. Gelen isteÄŸin internal servise yÃ¶nlendirildiÄŸi protokoldÃ¼r. Bunu birinci adÄ±mla karÄ±ÅŸtÄ±rmamak gerekir. <img src="images/154.png" /></p>
    </blockquote>
    <h3 id="ingress-konfigÃ¼rasyonu">Ingress KonfigÃ¼rasyonu</h3>
    <p>Ve ÅŸimdi, internal servisin bu Ingressâ€™e nasÄ±l gÃ¶rÃ¼neceÄŸine bakalÄ±m. Temelde, backend, gelen isteÄŸin yÃ¶nlendirileceÄŸi hedeftir ve servisin adÄ±, internal servisin adÄ±nÄ± karÅŸÄ±lamalÄ±dÄ±r.</p>
    <p><img src="images/155.png" /></p>
    <p>AyrÄ±ca port, internal servis portu olmalÄ±dÄ±r.</p>
    <p><img src="images/156.png" /></p>
    <p>Burada gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi, external ve internal servisler arasÄ±ndaki tek fark, internal serviste node portunun olmamasÄ±dÄ±r. Node portu 30000â€™den baÅŸlayan Ã¼Ã§Ã¼ncÃ¼ port burada yoktur. AyrÄ±ca tipi de bir load balancer deÄŸil, cluster IP olan default internal servis tipidir.</p>

<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
..
    ..
    spec:
      rules:
      - host: myapp.com
    ..
        </code></pre>
    </div>
</div>


    <p>Bu, geÃ§erli bir domain adresi olmalÄ±dÄ±r. Buraya rastgele bir ÅŸey yazamayÄ±z. AyrÄ±ca bu domain namei, Kubernetes clusterÄ±mÄ±zÄ±n entry pointâ€™i olan nodeâ€™un IP adresine eÅŸlemeliyiz. Ã–rneÄŸin, Kubernetes clusterÄ±mÄ±zda bir nodeâ€™u entry point olarak belirlersek, bu domain adÄ±nÄ± o nodeâ€™un IP adresine eÅŸlemelisiniz. Veya Kubernetes clusterâ€™Ä±mÄ±zÄ±n dÄ±ÅŸÄ±nda bir sunucu yapÄ±landÄ±rÄ±rsak, bu sunucunun IP adresine eÅŸlemeliyiz.</p>
    <p><img src="images/157.png" /></p>
    <p>Åimdi, Kubernetes Ingress componentini gÃ¶rdÃ¼ÄŸÃ¼mÃ¼ze gÃ¶re, Ingressâ€™i clustera nasÄ±l konfigÃ¼re edeceÄŸimize bakalÄ±m. BaÅŸlangÄ±Ã§ta gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z diyagramÄ± hatÄ±rlayalÄ±m.</p>
    <p><img src="images/158.png" /></p>
    <p>Temelde bir pod, servis ve buna karÅŸÄ±lÄ±k gelen Ingress var. Ancak, yalnÄ±zca Ingress componentini oluÅŸturmak yeterli deÄŸildir. Ingress routing rulesâ€™un Ã§alÄ±ÅŸmasÄ± iÃ§in ek olarak bir Ingress controllerâ€™a ihtiyacÄ±mÄ±z var.</p>
    <p><img src="images/159.png" /></p>
    <p>Ä°lk adÄ±m, Ingress controllers kurmak olacaktÄ±r. Bu, Kubernetes clusterÄ±mÄ±zdaki nodelarÄ±mÄ±zda Ã§alÄ±ÅŸan baÅŸka bir pod veya pod setidir ve Ingress rulesâ€™un deÄŸerlendirilmesi ve iÅŸlenmesini saÄŸlar. Az Ã¶nce gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z Ingress componentinin YAML dosyasÄ±, temelde sadece ingress bÃ¶lÃ¼mÃ¼dÃ¼r.</p>
    <p><img src="images/160.png" /></p>
    <h3 id="ingress-controller">Ingress Controller</h3>
    <p>Ingress denetleyicisi tam olarak nedir? Ingress controllerâ€™Ä±n iÅŸlevi, clusterda tanÄ±mladÄ±ÄŸÄ±mÄ±z tÃ¼m kurallarÄ±(rules) deÄŸerlendirmek ve bu ÅŸekilde tÃ¼m yÃ¶nlendirmeleri yÃ¶netmektir.</p>
    <p>Ingress Controller, yapÄ±landÄ±rdÄ±ÄŸÄ±mÄ±z domain name veya subdomain name kurallarÄ± iÃ§in clusterda <code>entry point</code> olacaktÄ±r ve tÃ¼m kurallarÄ± deÄŸerlendirecektir. Clustera 50 kural veya 50 Ingress componenti oluÅŸturmuÅŸ olabiliriz; yine de tÃ¼m kurallarÄ± deÄŸerlendirilecektir ve hangi routing ruleâ€™un belirli bir istek iÃ§in geÃ§erli olduÄŸunu belirleyecektir.</p>
    <p>Bu Ingress uygulamasÄ±nÄ± clusterÄ±mÄ±za kurmak iÃ§in birÃ§ok third party uygulamasÄ±ndan hangisini seÃ§eceÄŸimize karar vermemiz gerekir.</p>
    <p><a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">Kubernetes Docs - Ingress Controller</a></p>
    <p>burada seÃ§ebileceÄŸiniz farklÄ± Ingress denetleyicilerini gÃ¶rebilirsiniz. Kubernetesâ€™in kendi controllerÄ± olan <code>Kubernetes Nginx Ingress Controller</code> da var, ancak baÅŸka seÃ§enekler de mevcut.</p>
    <p>ClusterÄ±mÄ±za Ingress controller kurduktan sonra, Ingress rules oluÅŸturup tÃ¼m konfigÃ¼rasyonu Ã§alÄ±ÅŸtÄ±rabiliriz. Ingressâ€™in bir Kubernetes clusterÄ±nda nasÄ±l kullanÄ±labileceÄŸini gÃ¶sterdikten sonra, dÄ±ÅŸ istekleri alabilmek iÃ§in tÃ¼m clusterÄ± ayarlama konusunun Ã¶nemli olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼yorum.</p>
    <p>Ã–ncelikle, Kubernetes clusterÄ±mÄ±zÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ± ortamÄ± dÃ¼ÅŸÃ¼nmeliyiz. Amazon Web Services, Google Cloud gibi bir cloud service provider kullanÄ±yorsak, bu saÄŸlayÄ±cÄ±nÄ±n saÄŸladÄ±ÄŸÄ± bir yÃ¼k loadbalancer kullanabiliriz. DÄ±ÅŸ istekler Ã¶nce bu loadbalancerâ€™a ulaÅŸÄ±r, ardÄ±ndan Ingress controllerâ€™a yÃ¶nlendirilir. <code>Cloud Service Provider</code> kullanmanÄ±n avantajÄ±, kendi loadbalancerâ€™Ä±mÄ±zÄ± uygulamak zorunda olmamamÄ±zdÄ±r. Bu, loadbalancer iÅŸlemini ve dÄ±ÅŸ isteklerin yÃ¶nlendirilmesini daha kolay hale getirir. Ancak, bulut ortamÄ±nda bile farklÄ± yollarla yapÄ±landÄ±rma yapabiliriz, fakat bu yÃ¶ntem en yaygÄ±n stratejilerden biridir.</p>
    <p>Åimdi, Kubernetes clusterÄ±mÄ±zÄ± <code>bare metal</code> bir ortamda daÄŸÄ±tÄ±yorsak, bu kÄ±smÄ± kendimiz yapmamÄ±z gerekecek.</p>
    <p>Kubernetes clusterÄ±mÄ±za bir entry point yapÄ±landÄ±rmamÄ±z gerekecektir ve bunu yapmanÄ±n birÃ§ok farklÄ± yolu vardÄ±r. Cluster iÃ§inde veya dÄ±ÅŸÄ±nda ayrÄ± bir sunucu olarak bir entry point saÄŸlamamÄ±z gerekecektir.</p>
    <ul>
    <li>Bu entry point, yazÄ±lÄ±m veya donanÄ±m Ã§Ã¶zÃ¼mÃ¼ olabilecek harici bir proxy sunucusu olabilir ve clustera entry point olarak loadbalancer rolÃ¼nÃ¼ Ã¼stlenir.</li>
    </ul>
    <p><img src="images/161.png" /></p>
    <ul>
    <li>Temel olarak, bu ÅŸu anlama gelir: AyrÄ± bir sunucuya sahip olacaÄŸÄ±z ve bu sunucuya bir genel IP adresi vereceÄŸiz, gelen isteklerin kabul edilmesi iÃ§in portlarÄ± aÃ§acaÄŸÄ±z. Bu proxy sunucu, clusterÄ±mÄ±za tek entry point olarak iÅŸlev gÃ¶recek, yani Kubernetes clusterÄ±mÄ±zdaki hiÃ§bir sunucu genel olarak eriÅŸilebilir bir IP adresine sahip olmayacaktÄ±r, bu da oldukÃ§a iyi bir gÃ¼venlik uygulamasÄ±dÄ±r. TÃ¼m istekler proxy sunucuya girecek ve bu, isteÄŸi Ingress controllerâ€™a yÃ¶nlendirecektir. Ingress controller daha sonra bu belirli istek iÃ§in hangi Ingress kuralÄ±nÄ±n(rule) geÃ§erli olduÄŸunu belirleyecek ve tÃ¼m internal istek yÃ¶nlendirmesi gerÃ§ekleÅŸecektir.</li>
    </ul>
    <p><img src="images/162.png" /></p>
    <p>SÃ¶ylediÄŸimiz gibi farklÄ± ortam ve yaklaÅŸÄ±mlara baÄŸlÄ± olarak bunu yapÄ±landÄ±rmanÄ±n ve ayarlamanÄ±n farklÄ± yollarÄ± vardÄ±r, ancak clusterÄ±n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak Ã¶nemlidir.</p>
    <h3 id="minikube-ingress-konfigÃ¼rasyonu">Minikube Ingress KonfigÃ¼rasyonu</h3>
    <p><img src="images/163.png" /></p>
    <p>Biz tÃ¼m bunlarÄ± dizÃ¼stÃ¼ bilgisayarÄ±mÄ±zda Minikube kullanarak yapacaÄŸÄ±mÄ±z iÃ§in kurulum oldukÃ§a basit olacak ve bu, cluster ayarlarÄ±mÄ±za tam olarak uygulanmasa bile, tÃ¼m bu ÅŸeylerin pratikte nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶rmÃ¼ÅŸ olacaÄŸÄ±z. Ä°lk olarak, Minikubeâ€™da Ingress controllerâ€™Ä± kurmak gerekiyor ve bunu yapmak iÃ§in ÅŸu komutu Ã§alÄ±ÅŸtÄ±rabiliriz:</p>
    <div class="sourceCode" id="cb82"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true"></a><span class="ex">minikube</span> addons enable ingress</span></code></pre></div>
    <p>Bu komut, <code>Kubernetes NGINX Ingress controller</code>â€™Ä± otomatik olarak baÅŸlatÄ±r ve yapÄ±landÄ±rÄ±r. Bu, Minikubeâ€™un <code>out of the box</code> Ã¶zelliÄŸidir ve Ã¼retim ortamlarÄ±nda da gÃ¼venle kullanÄ±labilir. Bu komut ile Ingress controller clusterÄ±mÄ±zda yapÄ±landÄ±rÄ±lacak ve:</p>
    <div class="sourceCode" id="cb83"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true"></a><span class="ex">kubectl</span> get pod -n kube-system</span></code></pre></div>
    <p>komutunu Ã§alÄ±ÅŸtÄ±rarak Ingress controller podâ€™unun Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶rebiliriz.</p>
    <p><img src="images/164.png" /></p>
    <p>Ingress controller kurulduktan sonra, Ingress controllerâ€™Ä±n kullanacaÄŸÄ± bir Ingress kuralÄ± oluÅŸturabiliriz.</p>
    <blockquote>
    <p> EÄŸer <code>kubernetes-dashboard</code> componenti yoksa ÅŸu komutla indirebilirsiniz</p>
    <div class="sourceCode" id="cb84"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true"></a><span class="ex">kubectl</span> apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml</span></code></pre></div>
    <p>Bu komut, Kubernetes Dashboard iÃ§in gerekli kaynaklarÄ± oluÅŸturur.</p>
    </blockquote>
    <p>Åu an minikube clusterÄ±nda harici olarak eriÅŸilebilir olmayan bir <code>kubernetes-dashboard</code> var. Ä°Ã§ hizmet ve pod zaten mevcut olduÄŸundan, Kubernetes dashboard iÃ§in bir Ingress kuralÄ± yapÄ±landÄ±racaÄŸÄ±z, bÃ¶ylece bir tarayÄ±cÄ±dan bir alan adÄ± kullanarak eriÅŸebiliriz.</p>
    <div class="sourceCode" id="cb85"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true"></a><span class="ex">kubectl</span> get all -n kubernetes-dashboard</span></code></pre></div>
    <p>Bu komut kubernetes-dashboardâ€™daki tÃ¼m componentleri gÃ¶sterir.</p>
    <p><img src="images/165.png" /></p>
    <div class="sourceCode" id="cb86"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true"></a><span class="ex">service/kubernetes-dashboard</span>        ClusterIP   10.104.100.94   <span class="op">&lt;</span>none<span class="op">&gt;</span>        443/TCP    28s</span></code></pre></div>
    <p>Kubernetes Dashboard iÃ§in zaten bir internal servisimiz ve Ã§alÄ±ÅŸan bir podâ€™umuz olduÄŸu iÃ§in, Kubernetes Dashboardâ€™a eriÅŸmek amacÄ±yla bir Ingress kuralÄ± oluÅŸturabiliriz. Hadi bunu yapalÄ±m.</p>
    <p>Kubernetes Dashboard iÃ§in bir Ingress oluÅŸturacaÄŸÄ±m. ,</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: dashboard-ingress
      namespace: kubernetes-dashboard
    spec:
      rules:
        </code></pre>
    </div>
</div>

    <p>Bunlar sadece metadata. * <code>name:</code> <code>dashboard-ingress</code> olacak., * <code>namespace:</code> hizmetin ve podâ€™un olduÄŸu aynÄ± namespace olacak. * <code>spec:</code> iÃ§erisinde kurallarÄ± tanÄ±mlayacaÄŸÄ±z.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: dashboard-ingress
      namespace: kubernetes-dashboard
    spec:
      rules:
      - host: dashboard.com
        http:
          paths:
          - backend:
              serviceName: kubernetes-dashboard
              servicePort: 80
        </code></pre>
    </div>
</div>

    <ul>
    <li>Ä°lk kuralÄ±mÄ±z, <code>host:</code> olacak. <code>dashboard.com</code> olarak tanÄ±mladÄ±k.</li>
    <li><code>http</code> forwarding, internal servise yapÄ±lacak.</li>
    <li><code>paths:</code>â€™ i (all path) olarak bÄ±raktÄ±k.</li>
    <li><code>backend:</code>, servisin backendâ€™i olacak.</li>
    <li><code>servicename</code>, az Ã¶nceki Ã§Ä±ktÄ±da gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z servis adÄ±.</li>
    <li><code>servicePort:</code> ise servisin dinlediÄŸi port. Bunu da az Ã¶nce paylaÅŸtÄ±ÄŸÄ±m Ã§Ä±ktÄ±da gÃ¶rÃ¼yoruz. <code>80/TCP</code></li>
    </ul>
    <p>Bu, Ingress konfigÃ¼rasyonumuz olacak ve dashboard.comâ€™a yÃ¶nlendirilen her isteÄŸi, internal <code>kubernetes-dashboard</code> servisine yÃ¶nlendirecek. Internal Servis olduÄŸunu biliyoruz Ã§Ã¼nkÃ¼ tÃ¼rÃ¼ <code>ClusterIP</code>, yani External IP adresi yok.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
NAME                                TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
    service/kubernetes-dashboard        ClusterIP   10.101.218.170   <none>        80/TCP     82m
        </code></pre>
    </div>
</div>

    <p>Bu arada<code>dashboard.com</code> hostnamei uydurduk, hiÃ§bir yere kaydedilmedi ve ayrÄ±ca bu hostnameâ€™in hangi IP adresine Ã§Ã¶zÃ¼lmesi gerektiÄŸini hiÃ§bir yere yapÄ±landÄ±rmadÄ±k. Bu, her zaman yapÄ±landÄ±rmamÄ±z gereken bir ÅŸeydir.</p>
    <p>Åimdi bu Ingress ruleâ€™u apply edelim.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectl apply -f dashboard-ingress.yaml
        </code></pre>
    </div>
</div>

    <blockquote>
      <blockquote>
        <p><strong></strong> EÄŸer oluÅŸtururken ÅŸu hatayÄ± alÄ±rsanÄ±z:</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl apply -f dashboard-ingress.yaml Error from server (InternalError):
            error when creating "dashboard-ingress.yaml": Internal error occurred: failed calling
            webhook "validate.nginx.ingress.kubernetes.io": failed to call webhook: Post <br>
            "https://ingress-nginx-controller-admission.ingress-nginx.svc:443/networking/v1/ingresses?timeout=10s": service "ingress-nginx-controller-admission" not found
        </code></pre>
    </div>
</div>

        <p>YapmanÄ±z gereken ÅŸey ÅŸu komutu kullanmaktÄ±r. Gereken <code>ingress-nginx-controller</code> indirilecek.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/cloud/deploy.yaml
        </code></pre>
    </div>
</div>

      </blockquote>
      <blockquote>
        <p><strong></strong> <code>ingress-nginx-controller</code> oluÅŸturduktan sonra da ÅŸÃ¶yle bir hata alÄ±rsanÄ±z eÄŸer:</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl apply -f dashboard-ingress.yaml Error from server (InternalError): error when creating "dashboard-ingress.yaml": Internal error occurred:<br> failed calling webhook "validate.nginx.ingress.kubernetes.io": failed to call webhook: Post
"https://ingress-nginx-controller-admission.ingress-nginx.svc:443/networking/v1/ingresses?timeout=10s": service "ingress-nginx-controller-admission" not found
        </code></pre>
    </div>
</div>

        <p>Bunun Ã§Ã¶zÃ¼mÃ¼ sadece biraz beklemek. Ã‡Ã¼nkÃ¼ yeni oluÅŸturduÄŸumuz servisin oluÅŸmasÄ± biraz zaman alabilir ğŸ˜ğŸ˜</p>
      </blockquote>

    </blockquote>
    <p><img src="images/166.png" /></p>
    <p>Ingress oluÅŸturuldu. Namespaceâ€™te Ingressâ€™i gÃ¶rmeliyiz. Adresin boÅŸ olduÄŸunu gÃ¶rebiliriz Ã§Ã¼nkÃ¼ Ingressâ€™e adres atamasÄ± biraz zaman alÄ±r. Bu hostnameâ€™e eÅŸlenecek IP adresini almak iÃ§in beklememiz gerekecek.</p>
    <p>Adresi aldÄ±ktan sonra bu adresi aÅŸaÄŸÄ±daki ÅŸekilde hosts dosyamÄ±zda tanÄ±mlÄ±yoruz.</p>
    <p><img src="images/167.png" /></p>
    <p>Bu yerel olarak Ã§alÄ±ÅŸÄ±r, tarayÄ±cÄ±da dashboard.com yazarsak, bu IP adresine eÅŸlenecek ve istek Minikube clustera gelecek, Ingress controllerâ€™a teslim edilecek ve Ingress controller bu kuralÄ± deÄŸerlendirip isteÄŸi servise yÃ¶nlendirecek. Ä°htiyacÄ±mÄ±z olan tÃ¼m konfigÃ¼rasyon bu.</p>
    <p>Åimdi gidip tarayÄ±cÄ±ya <code>dashboard.com</code> yazacaÄŸÄ±z ve Kubernetes Dashboardâ€™umuzu burada gÃ¶receÄŸiz.</p>
    <p><img src="images/168.png" /></p>
    <h3 id="ingress-default-backend">Ingress Default Backend</h3>
    <p>Ingress ayrÄ±ca <code>default backend</code> adlÄ± bir ÅŸeye sahiptir, bu nedenle <code>kubectl describe Ingress</code> komutunu kullanarak Ingressâ€™in adÄ±nÄ± ve namespaceâ€™ini belirttiÄŸinizde ÅŸu Ã§Ä±ktÄ±yÄ± elde edersiniz.</p>
    <div class="sourceCode" id="cb94"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true"></a><span class="ex">kubectl</span> describe ingress dashboard-ingress -n kubernetes-dashboard</span></code></pre></div>
    <p><img src="images/169.png" /></p>
    <p>Burada, 80 numaralÄ± <code>default-http-backend</code> portuna eÅŸlenen bir <code>default backend</code> attributeâ€™u vardÄ±r. Bu, Kubernetes clusterÄ±na gelen ve herhangi bir backendâ€™e eÅŸlenmeyen istekleri ele alÄ±r, yani bu isteÄŸi bir servise eÅŸlemek iÃ§in herhangi bir kural bulunmayan bir istek olduÄŸunda, bu <code>default backend</code>â€™in bu isteÄŸi iÅŸleyeceÄŸi anlamÄ±na gelir. Bu servisi clusterÄ±mÄ±z iÃ§inde oluÅŸturup tanÄ±mlamazsak, Kubernetes bu servise yÃ¶nlendirmeye Ã§alÄ±ÅŸacak, bulamayacak ve bir varsayÄ±lan hata yanÄ±tÄ± alacaÄŸÄ±z.</p>
    <p>Ã–rneÄŸin, konfigÃ¼re etmediÄŸimiz bir adrese istek gÃ¶nderirsek, sadece â€œsayfa bulunamadÄ±â€ mesajÄ±nÄ± alÄ±rÄ±z.</p>
    <p><img src="images/170.png" /></p>
    <p>Bu, sayfa bulunamadÄ±ÄŸÄ±nda Ã¶zel hata mesajlarÄ± tanÄ±mlamak veya gelen ve uygulamanÄ±zÄ±n iÅŸleyemeyeceÄŸi istekler geldiÄŸinde kullanÄ±cÄ±larÄ±n anlamlÄ± bir hata mesajÄ± veya Ã¶zel bir sayfa gÃ¶rmesini saÄŸlamak iÃ§in kullanÄ±labilir; bÃ¶ylece kullanÄ±cÄ±larÄ± ana sayfamÄ±za yÃ¶nlendirebiliriz.</p>
    <p><strong>Ã–zetle</strong> Åimdiye kadar Ingressâ€™in ne olduÄŸunu ve nasÄ±l kullanabileceÄŸimizi gÃ¶rdÃ¼k. AyrÄ±ca Minikubeâ€™da bir Ingress kuralÄ±nÄ±n nasÄ±l oluÅŸturulacaÄŸÄ±na dair bir demo da yaptÄ±k, ancak sadece Ã§ok temel bir Ingress yaml konfigÃ¼rasyonu kullandÄ±k; sadece bir path ile bir internal servise basit bir yÃ¶nlendirme yaptÄ±k. Ancak Ingress configuration ile sadece temel yÃ¶nlendirmeden Ã§ok daha fazlasÄ±nÄ± yapabiliriz.</p>
    <h3 id="multiple-paths-for-same-host">Multiple paths for Same Host</h3>
    <p>Åu use caseâ€™i dÃ¼ÅŸÃ¼nelim: Google bir domaine sahip ama birden fazla hizmet sunmaktadÄ±r. Ã–rneÄŸin, bir Google hesabÄ±mÄ±z varsa, Google Analyticsâ€™i kullanabiliriz, alÄ±ÅŸveriÅŸ yapabiliriz, bir takvime sahip olabiliriz, Gmailâ€™e sahip olabiliriz vb.. TÃ¼m bunlar, aynÄ± domaine eriÅŸilebilen farklÄ± uygulamalardÄ±r. Buna benzer bir uygulamamÄ±z olduÄŸunu dÃ¼ÅŸÃ¼nelim; aynÄ± ekosistemin bir parÃ§asÄ± olan iki ayrÄ± uygulama sunuyoruz. Ancak bunlarÄ± ayrÄ± URLâ€™lerde tutmak istiyoruz.</p>
    <ul>
    <li>YapabileceÄŸimiz ÅŸey, â€œruleâ€ iÃ§inde Hostu tanÄ±mlamaktÄ±r: <code>myapp.com</code>. Path bÃ¶lÃ¼mÃ¼nde birden fazla yol tanÄ±mlayabiliriz. KullanÄ±cÄ±, analytics uygulamamÄ±za eriÅŸmek isterse, myapp.com/analytics adresini girmesi gerekecek ve bu, isteÄŸi pod iÃ§indeki internal analytics servise yÃ¶nlendirecektir. Veya alÄ±ÅŸveriÅŸ uygulamasÄ±na eriÅŸmek isterse, URL myapp.com/shopping olacaktÄ±r. Bu ÅŸekilde, tek bir Host ve bir Ingress ile, birden fazla uygulamaya yÃ¶nlendirme yapabiliriz.</li>
    </ul>
    <p><img src="images/171.png" /></p>
    <p>BaÅŸka bir use case ise, bazÄ± ÅŸirketlerin farklÄ± uygulamalarÄ± eriÅŸilebilir kÄ±lmak iÃ§in URLâ€™leri kullanmak yerine sub-domains kullanmasÄ±dÄ±r. Yani, myapp.com/analytics yerine, bir sub-domain oluÅŸtururlar: analytics.myapp.com. UygulamamÄ±z bu ÅŸekilde yapÄ±landÄ±rÄ±lmÄ±ÅŸsa, ÅŸu ÅŸekilde gÃ¶rÃ¼necektir:</p>
    <p><img src="images/172.png" /></p>
    <p>Ã¶nceki Ã¶rnekteki gibi tek bir host ve birden fazla path yerine, burada birden fazla host olur ve her host bir subdomaini temsil eder.</p>
    <h3 id="tls-certificate-konfigÃ¼rasyonu">TLS Certificate KonfigÃ¼rasyonu</h3>
    <p>Bu baÅŸlÄ±kta ele alacaÄŸÄ±mÄ±z son konu, TLS sertifikasÄ± yapÄ±landÄ±rmasÄ±dÄ±r. Åimdiye kadar sadece HTTP istekleri iÃ§in Ingress yapÄ±landÄ±rmasÄ± gÃ¶rdÃ¼k, ancak Ingressâ€™te HTTPS yÃ¶nlendirmeyi yapÄ±landÄ±rmak da Ã§ok kolaydÄ±r. YapmamÄ±z gereken tek ÅŸey, <code>rules</code> bÃ¶lÃ¼mÃ¼nÃ¼n Ã¼stÃ¼ne TLS adÄ±nda bir Ã¶zellik tanÄ±mlamak, host deÄŸeri, aynÄ± hostu <code>myapp.com</code> ve bir TLS sertifikasÄ±nÄ± iÃ§eren oluÅŸturduÄŸumuz secretâ€™Ä±n adÄ±nÄ± belirtmektir. Ingress ve Secret konfigÃ¼rasyonu ÅŸu ÅŸekilde olacaktÄ±r:</p>
    <p><img src="images/173.png" /></p>
    <ul>
    <li><code>name</code> bir referanstÄ±r.</li>
    <li><code>data</code> TLS sertifikasÄ± ve TLS anahtarÄ±nÄ± iÃ§erir.</li>
    </ul>
    <p>Ã–nceki konulardan hatÄ±rlarsanÄ±z, <code>type</code> belirtiyorduk. Kubernetesâ€™te TLS adÄ±nda belirli bir secret tÃ¼rÃ¼, TLS secretâ€™Ä± oluÅŸtururken bu tÃ¼rÃ¼ kullanmamÄ±z gerekiyor.</p>
    <p>Burada tutulmasÄ± gereken Ã¼Ã§ kÃ¼Ã§Ã¼k not var: * Birincisi, bu verilerin anahtarlarÄ±nÄ±n tam olarak bu ÅŸekilde adlandÄ±rÄ±lmasÄ± gerektiÄŸidir. <code>tls.crt</code>, <code>tls.key</code>. * Ä°kincisi, bu deÄŸerler, sertifika veya anahtar iÃ§eriklerinin kendisidir, dosya yolu veya konumu deÄŸil, bu nedenle tÃ¼m iÃ§eriÄŸi buraya base64 kodlamamÄ±z gerekiyor. * ÃœÃ§Ã¼ncÃ¼sÃ¼, secretâ€™Ä±, Ingress bileÅŸeniyle aynÄ± <code>namespace</code> ile oluÅŸturmamÄ±z gerekiyor. Aksi takdirde, farklÄ± bir namespaceâ€™teki bir secretâ€™a referans veremeyiz.</p>





  </div>
</body>
</html>
