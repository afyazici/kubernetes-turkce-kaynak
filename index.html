<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Boxicons CSS -->
  <link href="https://unpkg.com/boxicons@2.1.0/css/boxicons.min.css" rel="stylesheet" />
  <title>Kubernetes TR</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <!-- navbar -->
  <nav class="navbar">
    <div class="logo_item">
      <i class="bx bx-menu" id="sidebarOpen"></i>
      <img src="images/logo.png" alt=""></img>KubernetesTR
    </div>

    <div class="navbar_content">
      <i class="bi bi-grid"></i>
      <i class='bx bx-sun' id="darkLight"></i>
      <a href="https://github.com/afyazici" class="nav_link submenu_item"><img src="images/profile.jpeg" alt="" class="profile"/></a>
    </div>
  </nav>

  <!-- sidebar -->
  <nav class="sidebar">
    <div class="menu_content">
      <ul class="menu_items">
        <div class="menu_title menu_dahsboard"></div>
        <!-- duplicate or remove this li tag if you want to add or remove navlink with submenu -->
        <!-- start -->

        <li class="item">
          <a href="#kubernetes-nedir" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/logo.png" alt="Logo">
            </span>
            <span class="navlink">1) Kubernetes Nedir?</span>
          </a>
        </li>


        <li class="item">
          <a href="#kubernetes-avantajları" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/pros.png" alt="Logo">
            </span>
            <span class="navlink">2) Kubernetes Avantajları?</span>
          </a>
        </li>

        <li class="item">
          <a href="#kubernetes-componentleri" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/component.png" alt="Logo">
            </span>
            <span class="navlink">3) Kubernetes Componentleri</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <a href="#pod" class="nav_link sublink">Pod</a>
            <a href="#service-ve-ingress" class="nav_link sublink">Service ve Ingress</a>
            <a href="#configmap-ve-secret" class="nav_link sublink">ConfigMap ve Secret</a>
            <a href="#volumes" class="nav_link sublink">Volumes</a>
            <a href="#deployment-ve-statefulset" class="nav_link sublink">Deployment ve StatefulSet</a>
          </ul>
        </li>

        <li class="item">
          <a href="#kubernetes-mimarisi" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/arch.png" alt="Logo">
            </span>
            <span class="navlink">4) Kubernetes Mimarisi</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#node-process" class="nav_link sublink">a) Node Process</a></li>
            <li><a href="#master-node" class="nav_link sublink">b) Master Node</a></li>
          </ul>
        </li>

        <li class="item">
          <a href="#cluster-yapısı" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/cluster.png" alt="Logo">
            </span>
            <span class="navlink">5) Cluster Yapısı</span>
          </a>
        </li>

        <li class="item">
          <a href="#minikube-ve-kubectl-kurulumu" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/minikube.png" alt="Logo">
            </span>
            <span class="navlink">6) Minikube ve Kubectl</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#minikube" class="nav_link sublink">a) Minikube</a></li>
            <li><a href="#kubectl" class="nav_link sublink">b) Kubectl</a></li>
            <li><a href="#kurulum" class="nav_link sublink">c) Kurulum</a></li>
          </ul>
        </li>

        <li class="item">
          <a href="#ilk-cluster" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/first.png" alt="Logo">
            </span>
            <span class="navlink">7) İlk Cluster</span>
          </a>
        </li>

        <li class="item">
          <a href="#main-kubectl-komutları" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/commands.png" alt="Logo">
            </span>
            <span class="navlink">8) Main Kubectl Komutları</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#layerların-çalışma-şekli" class="nav_link sublink">a) Layerların Çalışma Şekli</a></li>
            <li><a href="#debugging-pods" class="nav_link sublink">b) Debugging Pods</a></li>
            <li><a href="#deployment-silme-ve-apply-configuration-file" class="nav_link sublink">c) Deployment Silme ve Apply Configuration File</a></li>
            <li><a href="#kubectl-apply" class="nav_link sublink">d) Kubectl Apply</a></li>
          </ul>
        </li>

        <li class="item">
          <a href="#kubernetes-yaml-konfigürasyonu" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/yal.png" alt="Logo">
            </span>
            <span class="navlink">9) YAML Konfigürasyonu</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#parçada-k8s-config-dosyası" class="nav_link sublink">a) 3 Parçada K8s Config Dosyası</a></li>
            <li><a href="#config-dosyasının-formatı" class="nav_link sublink">b) Config Dosyasının Formatı</a></li>
            <li><a href="#podlar-için-blueprint-template" class="nav_link sublink">c) Podlar için Blueprint (Template)</a></li>
            <li><a href="#connecting-components-labels-selectors-ports" class="nav_link sublink">d) Connecting Components Labels - Selectors - Ports</a></li>
          </ul>
        </li>

        <li class="item">
          <a href="#ilk-demo-uygulama" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/first.png" alt="Logo">
            </span>
            <span class="navlink">10) İlk Demo Uygulama</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#mongodb-pod" class="nav_link sublink">a) MongoDB Pod</a></li>
            <li><a href="#secret-ve-referans" class="nav_link sublink">b) Secret ve Referans</a></li>
            <li><a href="#mongodb-internal-service" class="nav_link sublink">c) MongoDB Internal Service</a></li>
            <li><a href="#mongo-express-deployment-service-configmap" class="nav_link sublink">d) Mongo Express Deployment & Service & ConfigMap</a></li>
            <li><a href="#mongo-express-external-service" class="nav_link sublink">e) Mongo Express External Service</a></li>
          </ul>
        </li>


        <li class="item">
          <a href="#kubernetes-namespaces" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/ns.png" alt="Logo">
            </span>
            <span class="navlink">11) Kubernetes Namespaces</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#namespace-nedir" class="nav_link sublink">a) Namespace Nedir</a></li>
            <li><a href="#default-namespaces" class="nav_link sublink">b) Default Namespaces</a></li>
            <li><a href="#ne-zaman-nasıl-namespace-oluşturmalı" class="nav_link sublink">c) Ne Zaman & Nasıl Namespace Oluşturmalı</a></li>
            <li><a href="#namespaces-özellikleri" class="nav_link sublink">d) Namespaces Özellikleri</a></li>
            <li><a href="#namespaces-component-oluşturma" class="nav_link sublink">e) Namespaces Component OLuşturma</a></li>
          </ul>
        </li>


        <li class="item">
          <a href="#kubernetes-ingress-explained" class="nav_link submenu_item">
            <span class="navlink_icon">
              <img src="images/ingress.png" alt="Logo">
            </span>
            <span class="navlink">12) Kubernetes Ingress</span>
            <i class="bx bx-chevron-right arrow-left"></i>
          </a>

          <ul class="menu_items submenu">
            <li><a href="#external-service-vs-ingress" class="nav_link sublink">a) External Service vs Ingress</a></li>
            <li><a href="#ingress-konfigürasyonu" class="nav_link sublink">b) Ingress Konfigürasyon</a></li>
            <li><a href="#ingress-controller" class="nav_link sublink">c) Ingress Controller</a></li>
            <li><a href="#minikube-ingress-konfigürasyonu" class="nav_link sublink">d) Minikube Ingress Konfigürasyonu</a></li>
            <li><a href="#ingress-default-backend" class="nav_link sublink">e) Ingress Default Backend</a></li>
          </ul>
        </li>













        <!-- end -->
      </ul>


      <!-- Sidebar Open / Close -->
      <div class="bottom_content">
        <div class="bottom expand_sidebar">
          <span> İyi Okumalar!</span>
        </div>
      </div>
    </div>
  </nav>
  <!-- JavaScript -->
  <script src="script.js"></script>

  <!-- Metinlerin olduğu kısım -->
  <div class="content">


    <h1 id="kubernetes-türkçe-döküman">Kubernetes Türkçe Döküman ☸️☸🐳👨‍💻</h1>
    <hr /><br>
    <p><img src="images/header.png" /></p>
    <hr />
    <ul>
    </ul>
    <hr />
    <h2 id="kubernetes-nedir">Kubernetes Nedir?</h2>
    <ul>
    <li><strong>Kubernetes</strong>, açık kaynaklı bir konteyner yönetim aracıdır.</li>
    <li>Google tarafından geliştirilmiştir.</li>
    <li>Farklı dağıtım ortamlarında konteynerleştirilmiş uygulamaları yönetmenize yardımcı olur.
    <ul>
    <li>fiziksel ortamda</li>
    <li>sanal ortamda</li>
    <li>bulut ortamında</li>
    </ul></li>
    </ul>
    <hr />
    <h2 id="kubernetes-avantajları">Kubernetes Avantajları:</h2>
    <ul>
    <li><strong>Yüksek erişilebilirlik</strong> veya kesintisiz çalışma</li>
    <li><strong>Ölçeklenebilirlik</strong> veya yüksek performans</li>
    <li><strong>Afet kurtarma</strong> - yedekleme ve geri yükleme</li>
    </ul>
    <hr />
    <h2 id="kubernetes-componentleri">Kubernetes Componentleri</h2>
    <h3 id="pod">Pod</h3>
    <ul>
    <li>Pod Kubernetes’in en küçük birimidir.</li>
    <li>Konteyner üzerinde sanallaştırma yapar. (abstraction)</li>
    </ul>
    <p><img src="images/1.png" /></p>
    <ul>
    <li>Bizler yalnızca Kubernetes katmanıyla etkileşime geçeriz.</li>
    <li>Bir pod içinde birden fazla konteyner çalıştırabiliriz, ancak genellikle bir pod başına bir uygulama bulunur.</li>
    <li>Her pod kendi IP adresine sahiptir. Her pod, birbirleriyle bu internal IP adresini kullanarak iletişim kurabilir.</li>
    </ul>
    <p>Ancak, Kubernetes’teki pod bileşenleri de geçicidir: yani çok kolay bir şekilde ölebilirler. Örneğin, bir veritabanı konteynerını kaybettiğimizi düşünelim (konteyner içindeki uygulama çöktüğü veya sunucu kaynakları tükendiği için pod ölür ve yerine yeni bir tane oluşturulur). Bu durumda da yeni bir IP adresi atanır. Veritabanıyla IP adresini kullanarak iletişim kuruyorsak elbette sakıncalıdır. Her pod yeniden başladığında, iletişimi her seferinde yeniden ayarlamamız gerekir. Bu nedenle, pod’un yeniden başladığında IP adresini ayarlamamıza gerek kalmadan, veritabanıyla iletişim kurmanızı sağlayan başka bir Kubernetes bileşeni olan <code>Service</code> kullanılır.</p>
    <h3 id="service-ve-ingress">Service ve Ingress</h3>
    <ul>
    <li>Service, her pod’a bağlanabilen sabit bir IP adresidir. Uygulamamızın kendi servisi olacak ve veritabanı pod’u kendi servisine sahip olacak. Buradaki güzel şey, servis ve Pod’un yaşam döngüleri birbirine bağlı değil. Bu yüzden Pod ölse bile servis ve bu servise ait IP adresi kalır. Bu şekilde endpoint’i değiştirmemize gerek yoktur.</li>
    </ul>
    <p><img src="images/2.png" /></p>
    <ul>
    <li>Tabii ki, uygulamamızın bir tarayıcı aracılığıyla erişilebilir olmasını isteriz değil mi? Bunun için bir external service oluşturmamız gerekiyor. <code>External Service</code>, dış kaynaklardan iletişimi açan bir servistir. Ancak, veritabanımızı halka açık isteklere açmak istemeyiz. Bunun için <code>Internal Service</code> adını verdiğimiz bir şey oluştururuz.</li>
    </ul>
    <p><img src="images/3.png" /></p>
    <ul>
    <li>External Service URL’sinin çok pratik olmadığını fark ettik değil mi? Temelde, bir HTTP protokolüyle bir node IP adresi ve servis port numarasına sahibiz. Bu hızlı bir şekilde bir şeyleri test etmek istiyorsak iyidir, ancak end-product için iyi değildir. Genellikle, uygulamamızla güvenli bir protokol ve bir alan adı kullanmak isteriz.</li>
    </ul>
    <p><img src="images/4.png" /></p>
    <p>Bunun için Kubernetes’in başka bir bileşeni olan <code>Ingress</code> var. Bu şekilde, istek önce servise değil, Ingress’e gider ve oradan servise yönlendirilir.</p>
    <p><img src="images/5.png" /></p>
    <h3 id="configmap-ve-secret">ConfigMap ve Secret</h3>
    <p>Pod’lar birbirleriyle servis aracılığıyla iletişim kurar. Uygulamamızın, veritabanı ile iletişim kurmak için kullandığı bir database endpoint <code>örneğin mongodb servisi</code> olacak. Ancak bu veritabanı URL’sini (ya da endpoint) genellikle nerede yapılandırırız?</p>
    <p><img src="images/6.png" /></p>
    <p>Genellikle bunu application properties file veya bazı external environmental variable olarak yaparız, ancak genellikle yapılandırma, uygulamanın içerisindeki built image’tedir.</p>
    <p>Örneğin, service endpoint (ya da service name) ‘mongodb’ olarak değişirse, uygulamadaki bu URL’i ayarlamalıyız. Genellikle yeni bir sürümle uygulamayı rebuild etmemiz ve repoya pushlamamız gerekir. Ardından bu yeni image’i pod’umuzda pull’layıp tüm uygulamayı yeniden başlatmamız gerekebilir.</p>
    <p><img src="images/7.png" /></p>
    <p>Veritabanı URL’i gibi küçük bir değişiklik için bu gerçekten zahmetli. Bu sebeple, Kubernetes’in <code>configmap</code> adında bir bileşeni var. Yapısı, uygulamamıza <code>external configuration</code> sağlar. ConfigMap genellikle kullandığımız veritabanı URL’leri gibi yapılandırma verilerini içerir. Kubernetes’te bunu Pod’a bağlarız. Pod, ConfigMap’in içerdiği verileri alır. Ve şimdi, servis adını değiştirirsek (service end point), sadece ConfigMap’i ayarlamamız yeterlidir. Yeni bir image oluşturmamıza ve tüm döngüyü geçirmemize gerek yoktur. Büyük avantaj!</p>
    <p><img src="images/8.png" /></p>
    <p>Şimdi, external configuration’ın bir parçası aynı zamanda database kullanıcı adı ve şifresi olabilir değil mi? Bu veriler de uygulama dağıtım sürecinde değişebilir. Ancak, bir şifreyi veya diğer kimlik bilgilerini düz metin formatında bir configmap’e koymamız güvensiz olur.</p>
    <blockquote>
    <p><img src="images/9.png" /></p>
    </blockquote>
    <p>Bu amaçla, Kubernetes’in <code>Secret</code> adında bir başka bileşeni daha var. Yani, Secret, ConfigMap gibi, ancak fark şu ki; şifre gibi gizli verileri saklamak için kullanılır. Ve tabii ki, düz metin formatında değil, base64 formatında kodlanmış olarak saklanır. Yani, Secret, kullanıcı adları gibi kimlik bilgilerini içerecek ve veritabanı kullanıcılarını içerecektir. ConfigMap’e de koyabiliriz, ancak önemli olan şifreler, sertifikalar, başkalarının erişimini istemediğimiz şeyler Secret’e koyulmalıdır. Aynı ConfigMap gibi, sadece Pod’umuza bağlarız, böylece Pod bu verileri görebilir ve Secret’ten okuyabilir. ConfigMap veya Secret’ten verileri, örneğin environment variables olarak veya hatta bir özellikler dosyası olarak uygulamamızın içinde kullanabiliriz.</p>
    <p><img src="images/10.png" /></p>
    <p>Aslında en çok kullanılan Kubernetes temel bileşenlerinin neredeyse tamamını gördük. Pod’a göz attık. Hizmetlerin nasıl kullanıldığını, Ingress bileşeninin ne işe yaradığını gördük ve ayrıca ConfigMap ve Secrets’ı kullanan harici yapılandırmayı da gördük.</p>
    <p><img src="images/11.png" /></p>
    <h3 id="volumes">Volumes</h3>
    <p>Sıra geldi çok önemli bir kavrama. <code>Veri depolama</code> nedir ve Kubernetes içerisinde nasıl çalışır? Uygulamamızın kullandığı bir database pod’umuz ve de bir miktar verimiz var. Şu anda gördüğünüz bu kurulumla, eğer veritabanı container veya pod’u yeniden başlatılırsa veri kaybolur. Bu açıkça sorunlu ve elverişsizdir çünkü database’deki verilerinizin veya günlük verilerinizin uzun süreli güvenilir ve kalıcı olmasını isteriz. Bunu Kubernetes’te yapmanın yolu, Kubernetes’in başka bir bileşeni olan <code>Volumes</code> kullanmaktır.</p>
    <p><img src="images/12.png" /></p>
    <p>Çalışma şekli şöyledir: Temelde bir fiziksel depolama birimini -yani bir sabit diski- pod’umuza bağlarız. * Bu depolama yerel bir makinede olabilir. * Pod’un çalıştığı aynı sunucu node’unda da olabilir. * Kubernetes kümesinin dışında(Bulut depolama, Kubernetes kümesinin bir parçası olmayan kendi yerleşke depolamanız) olabilir. Bu yüzden bununla ilgili external reference var.</p>
    <p><img src="images/13.png" /></p>
    <p>Böylece, database pod’u veya container yeniden başlatıldığında, tüm veri kalıcı bir şekilde saklanmış olacaktır.</p>
    <p>Kubernetes kümesi ve tüm bileşenlerinin ve depolama arasındaki farkı anlamamız önemlidir. Yerel veya uzak bir depolama olması fark etmeksizin, depolamayı Kubernetes kümesine takılmış harici bir sabit diske benzetebiliriz. Çünkü buradaki önemli nokta; Kubernetes kümesi açıkça hiçbir veri kalıcılığını yönetmez. Kubernetes kullanıcısı veya yöneticisi olarak sizin veriyi yedeklemenizden, çoğaltmanızdan, yönetmenizden ve uygun donanımda saklamanızdan emin olmanız gerektiği anlamına gelir.</p>
    <h3 id="deployment-ve-statefulset">Deployment ve StatefulSet</h3>
    <p>Şimdi, her şey mükemmel bir şekilde çalışıyor ve bir kullanıcı bir tarayıcı aracılığıyla uygulamaya erişebiliyor. Bu kurulumla, application pod’u ölürse, crashlerse veya yeni bir container image oluşturduğumuz için pod’u restart etmemiz gerekiyorsa ne olurdu? Basitçe cevap verecek olursak, bir kullanıcının uygulamamıza ulaşamadığı bir süre olan bir kesintimiz olurdu. Böyle bir durum end product’ta gerçekleşmesi çok kötü bir durumdur.</p>
    <p><img src="images/14.png" /></p>
    <p>Distributed systems ve konteynerların avantajı tam olarak budur. Yalnızca 1 application pod’u ve 1 database pod’u gibi bir şeye güvenmek yerine, her şeyi birden fazla sunucuda replikasını oluşturuyoruz. Yani uygulamamızın bir klonu veya çoğaltması çalışacağı başka bir node olacak ve bu da servise bağlı olacak. Hatırlarsak servisin, bir pod öldüğünde end point’i sürekli ayarlamamıza gerek olmadığı, kalıcı statik IP adresi ve bir DNS adına sahip olduğunu söylemiştik.</p>
    <ul>
    <li>Service aynı zamanda bir <code>load balancer</code>dır. Yani, servis isteği yakalayacak ve en az meşgul olan pod’a yönlendirecektir.</li>
    </ul>
    <p>Ancak application pod’unun ikinci replikasını oluşturmak için ikinci bir pod oluşturmayız. Bunun yerine uygulama pod’umuzun bir blueprint’ini tanımlarız ve o pod’un kaç tane replikasının olmasını istediğimizi belirtiriz. Ve bu component veya blueprint’e <code>deployment</code> denir. Deployment, Kubernetes’in başka bir componentidir. Pratikte, pod’larla çalışmayız veya pod’lar oluşturmayız. Çünkü zaten kaç tane replika olacağını belirtebilir ve ihtiyacımız olan pod’ların replika sayısını artırabilir veya azaltabiliriz. Yani pod, container’ların üzerinde bir soyutlama katmanıdır(layer of abstraction). Deployment ise, podların üzerinde başka bir soyutlama katmanıdır(layer of abstraction). Bu durum; pod’larla etkileşimi, kopyalama ve diğer yapılandırmaları daha kullanışlı hale getirir.</p>
    <p><img src="images/15.png" /></p>
    <p>Yani sonuç olarak çoğunlukla pod’larla değil, deployment’larla çalışırız. Uygulama pod’umuzun replikalarından biri ölürse, servis istekleri başka bir replikaya yönlendirilecektir, bu şekilde uygulamamız kullanıcılar için hala erişilebilir olacaktır.</p>
    <p><img src="images/16.png" /></p>
    <p>Şimdi muhtemelen şunu merak ediyoruzdur, database pod’u ne olacak? Çünkü eğer database pod’u ölürse, uygulamanız da erişilemez olacaktır. Bu yüzden, bir database replikasına da ihtiyacımız var. Ancak, <code>deployment kullanarak bir databese'i kopyalayamayız</code>. Bunun nedeni, database’in bir state’i olmasıdır, yani veridir. Bu da demektir ki eğer database’in replikaları veya klonları olsaydı, hepsi aynı paylaşılan data storage volume’üne erişmek zorunda kalacaktı. Bu durumda da, hangi pod’ların anlık olarak depolama birimine yazdığını veya hangi pod’ların depolama biriminden okuduğunu yöneten bir mekanizmaya ihtiyacımız olacaktı.</p>
    <p>Bu mekanizma, çoğaltma özelliklerinin yanı sıra başka bir Kubernetes componenti olan <code>StatefulSet</code> ile sağlanır.</p>
    <p><img src="images/17.png" /></p>
    <p>Bu component özellikle database gibi uygulamalar için tasarlanmıştır. Yani, MySQL, MongoDB, Elasticsearch veya herhangi bir diğer stateful applications veya databaseleri; deployments yerine <code>StatefulSets</code> kullanılarak oluşturulmalıdır. Bu çok önemli bir ayrımdır. StatefulSet, aynı deployment gibi, pod’ları replikalamayı yapar ve bunları scaling’e alır. Database reading ve writing işlemlerinin senkronize olduğundan emin olur, böylece database tutarsızlıkları olmaz.</p>
    <p><img src="images/18.png" /></p>
    <blockquote>
    <p> Ancak, bir Kubernetes kümesinde StatefulSets kullanarak database uygulamalarını deploy etmek biraz zahmetli olabilir. Bu yüzden, database uygulamalarını Kubernetes kümesinin dışında barındırmak ve yalnızca dağıtımları veya durumsuz uygulamaları Kubernetes kümesinin içinde sorunsuz bir şekilde çoğaltmak ve ölçeklendirmek ve dış database ile iletişim kurmak yaygın bir uygulamadır.</p>
    </blockquote>
    <p>Şimdi, uygulama pod’umuzun iki replikası ve database’in iki kopyası olduğunda ve hepsi load-balanced olduğunda, kurulumumuz daha güvenlidir. Bu senaryoda eğer Node 1 yeniden başlatılsaydı veya çökseydi, hala uygulama ve database pod’larının çalıştığı ikinci bir node’umuz olurdu. Uygulama, bu iki replikadan yeniden oluşturulana kadar kullanıcı tarafından erişilebilir olacaktır, bu yüzden kesintiyi önlemiş oluruz.</p>
    <p><img src="images/19.png" /></p>
    <p>Özetlemek gerekirse, en çok kullanılan Kubernetes bileşenlerini inceledik. Parçalar arasında iletişim kurmak için <code>pod</code>lar ve <code>servis</code>lerle başladık, ve trafiği clusterlara yönlendirmek için kullanılan <code>Ingress</code> bileşenini inceledik. Ayrıca, <code>ConfigMaps</code> ve <code>Secret</code> kullanarak external configuration, ve <code>Volumes</code> kullanarak veri kalıcılığını inceledik. Ve son olarak, <code>Deployments</code> ve <code>StatefulSets</code> gibi replicating ve blueprintlere baktık.</p>
    <p>Burada <code>stateful applications</code> özellikle databaseler gibi stateful applications için kullanılır. Ve evet, Kubernetes’in sunduğu çok daha fazla bileşen var, ama bunlar çekirdek, temel olanları. Bu temel bileşenleri kullanarak oldukça güçlü Kubernetes kümesi oluşturabiliriz.</p>
    <hr />
    <h2 id="kubernetes-mimarisi">Kubernetes Mimarisi</h2>
    <p>Kubernetes’in temel mimarisinden bahsedeceğiz. Bu yüzden Kubernetes’in çalıştığı iki tür node’u inceleyeceğiz: biri <code>master</code> diğeri ise <code>slave</code>. Bunların arasındaki fark nedir ve her birinin cluster içindeki rolü nedir, onlara bakacağız.</p>
    <p>Kubernetes’in ne yaptığını ve cluster’ın nasıl self-managed, self-healing ve automated olduğunu gösteren temel kavramları ele alacağız. Bir Kubernetes cluster operatörü olarak, çok daha az manuel çaba harcamamız gerektiğini göreceğiz.</p>
    <h3 id="node-process">Node Process</h3>
    <p>İki application pod’unun çalıştığı tek bir node ile bu temel kurulumla başlayacağız. Kubernetes mimarisinin ana bileşenlerinden biri worker servers veya node’dur. Her node, o node’da çalışan birden fazla application pod’una sahip olacaktır.</p>
    <p>Ve Kubernetes’in bunu yapma şekli, her node’da bulunması gereken ve bu pod’ları planlamak ve yönetmek için kullanılan <code>three process</code> kullanmasıdır. Yani node’lar, asıl işi yapan cluster serverlardır. Bu yüzden bazen onlara worker nodes da denir.</p>
    <h4 id="container-runtime">1) Container Runtime</h4>
    <p>Her node’da çalışması gereken ilk süreç, <code>container runtime</code>dır. Biz Docker ile işlem yapacağız, ancak başka bir teknoloji de olabilir. Applitacion pod’larında içinde çalışan containerlar olduğu için, her node’da bir <code>container runtime</code> kurulmalıdır.</p>
    <h4 id="kubelet">2) Kubelet</h4>
    <p>Kubernetes’in bir parçası olan kubelet, Pod’ları ve bu Pod’ların altındaki container’ları schedule eder. Container Runtime, node’un kendisiyle arayüz oluştururken, kubelet bu yapılandırmayı alır, bir pod’u çalıştırır (veya içinde bir container başlatır) ve ardından o node’dan container’a CPU, RAM gibi depolama kaynakları atar.</p>
    <p>Bu nedenle, genellikle bir Kubernetes cluster kurulu olmalıdır. Kubelet hizmetlerine sahip birden fazla node’dan oluşur. Bu worker node’ları, Örneğimizdeki application ve database pod’larının replikalarını çalıştıracak yüzlerce diğer node’u çalıştırır.</p>
    <p>Aralarındaki iletişim şekli, <code>servisler</code> ile olur, bu da isteği application parçasına veya örneğin bir database’e yönlendiren bir <code>load-balancer</code> gibi çalışır ve ardından ilgili parçaya yönlendirir.</p>
    <h4 id="kube-proxy">3) Kube Proxy</h4>
    <p>Hizmetlerden pod’lara istekleri iletmekten sorumlu üçüncü süreç <code>kube-proxy</code>dir ve her node’da kurulmalıdır. Kube-proxy, düşük bir işlem yükü ile performanslı bir şekilde iletişim kurulmasını sağlayan akıllı yönlendirme mantığına sahiptir.</p>
    <p>Bir uygulama veya bu uygulamanın replikası, bir database’e istek yapıyorsa, hizmet sadece isteği rastgele bir replikaya yönlendirmek yerine; isteği başlatan pod’un çalıştığı aynı node’da çalışan replikaya yönlendirecektir. Bu şekilde, isteği başka bir makineye göndermekle ilgili <code>ağ işlem yükünden</code> kaçınılmış olur.</p>
    <p>Özetlemek gerekirse; bir kubernetes cluster’ının düzgün çalışabilmesi için <code>kubelet</code> ve <code>kube-proxy</code> her worker node içerisine <code>container runtime</code> ile birlikte kurulmalıdır.</p>
    <p><img src="images/20.png" /></p>
    <p>Ancak şimdi soru şu: Bu cluster ile nasıl etkileşime girilir? Yeni bir application pod’u veya database pod’u nerede schedule edilmeli? Bir replika pod’u ölürse, hangi process monitoring, reschedule veya restart işlemleri ile ilgilenir?</p>
    <h3 id="master-node">Master Node</h3>
    <p>Master servers(master nodes), içerisinde tamamen farklı processler çalıştırır. Ve bunlar, cluster state ve worker nodes’ları kontrol eden, <code>her yönetici düğümünde çalışan dört süreçtir</code>.</p>
    <h4 id="api-server">1) API Server</h4>
    <p>İlk hizmetimiz API server. Bir Kubernetes cluster’ında yeni bir application deploy etmek istediğinizde, bir kullanıcı olarak API server ile interact ederiz. Bir Kubernetes Dashboard gibi bir kullanıcı arayüzü de olabilir, <code>kubectl</code> gibi bir command-line tool veya bir Kubernetes API’si de olabilir.</p>
    <p>API sunucusu, cluster içine herhangi bir güncelleme talebinin veya hatta clusterdan gelen sorguların ilk isteğini alır. Kimlik doğrulaması(auth) yaparak, yalnızca kimliği doğrulanmış ve yetkilendirilmiş isteklerin clusterlara iletilmesini sağlar.</p>
    <p><img src="images/21.png" /></p>
    <p>Bu, yeni pod’lar planlamak, yeni applications deploy etmek, yeni servisler oluşturmak veya herhangi bir component oluşturmak istediğimizde, bu requestimizi master node API sunucusuna iletmek zorunda olduğunuz anlamına gelir. API server daha sonra requestimizi doğrular. Her şey yolundaysa, requestimizi diğer süreçlere ileterek istediğimiz pod’u veya bileşeni schedule için bir node’a yönlendirir.</p>
    <p><img src="images/22.png" /></p>
    <p>Ayrıca, dağıtımımızın durumu veya cluster health etc., gibi sorgu isteklerini yapmak isteyebiliriz. Bu sorgular API sunucusuna bir istek gönderir ve o da bize yanıt verir.</p>
    <blockquote>
      <div class="note">
    <p><strong>NOT:</strong> Bu durum güvenlik açısından gayet iyidir çünkü clusterlara yalnızca <code>bir entry point</code> vardır.</p>
  </div>
    </blockquote>
    <h4 id="scheduler">2) Scheduler</h4>
    <p>Başka bir Master process ise Scheduler’dır. API serverına yeni bir pod schedule isteği gönderdiğimizi varsayalım. API server bu isteğimizi doğruladıktan sonra, bu pod’un bir worker node’da başlatılması için <code>Scheduler</code>’a teslim eder.</p>
    <p>Ve tabii ki, herhangi bir node’a rastgele atamak yerine, Scheduler, bir sonraki pod’un hangi belirli worker node’un scheduled olacağı konusunda zekice bir şekilde karar vermektedir. İlk olarak, isteğimizi kontrol eder ve planlamak istediğimiz uygulamanın ne kadar kaynağa ihtiyacı olduğunu kontrol eder. Ne kadar CPU, ne kadar RAM vb.</p>
    <p>Ardından, worker node’daki kullanılabilir kaynakları kontrol eder. Eğer bir node’un en çok kaynağa sahip olduğunu söylüyorsa, yeni pod’u o node’a schedule eder.</p>
    <p><img src="images/23.png" /></p>
    <p>Önemli bir nokta şu ki, scheduler sadece yeni bir pod’un hangi node’a schedule edileceğine karar verir. Asıl planlamayı yapan ve pod’u konteynerla başlatan işlem ise <code>kubelet</code>’tir. Yani kubelet, scheduler’dan gelen isteği alır ve bu isteği ilgili node üzerinde yürütür.</p>
    <h4 id="controller-manager">3) Controller Manager</h4>
    <p>Bir sonraki önemli bileşen ise <code>controller manager</code>’dır. Bu bileşen, herhangi bir düğümde pod’lar öldüğünde ne olacağı sorusu açısından kritik öneme sahiptir. Ölü node’ları tespit etmek ve daha sonra bu pod’ları en kısa sürede reschedule etmek gerekir.</p>
    <p><img src="images/24.png" /></p>
    <p>Dolayısıyla controller manager, state changes’ları, örneğin pod’ların çökmesini tespit eder. Pod’lar öldüğünde controller manager bunu algılar ve cluster state’ini mümkün olan en kısa sürede kurtarmaya çalışır.</p>
    <p>Ölen pod’ları yeniden schedule etme amacıyla scheduler’a bir istek gönderir. Bu döngü içinde, scheduler kaynak hesaplamasına göre hangi worker node’ların bu pod’ları tekrar başlatması gerektiğine karar verir ve bu worker node’lar üzerindeki ilgili <code>kubelet</code>lere, pod’ları yeniden başlatmaları için istek gönderir.</p>
    <p><img src="images/25.png" /></p>
    <h4 id="etcd">4) Etcd</h4>
    <p>Son olarak, ana işlemlerden biri olan etcd, bir cluster state’inin key-value deposudur. Bunu aslında bir cluster beyni olarak düşünebiliriz. Yani cluster’daki her değişiklik -örneğin yeni bir pod schedule edildiğinde veya bir pod öldüğünde- etcd’nin bu key-value deposunda kaydedilir veya güncellenir.</p>
    <p><img src="images/26.png" /></p>
    <p>Etcd deposunun bir küme beyni olarak adlandırılmasının sebebi, scheduler, controller manager gibi tüm bu mekanizmaların, etcd’nin sahip olduğu veriler sayesinde çalışmasıdır.</p>
    <p><img src="images/27.png" /></p>
    <p>Örneğin, scheduler her bir worker node’unda hangi kaynakların mevcut olduğunu nasıl bilir? Veya controller manager, cluster durumunda bir değişiklik olduğunu nasıl tespit eder? Pod’ların ölmesi, kubelet’in scheduler’ın isteği üzerine yeni pod’ları başlatması, API sunucusuna cluster health hakkında bir sorgu göndermemiz veya uygulama dağıtım durumumuz gibi bu durum bilgilerini, API sunucusu nereden alır?</p>
    <p>Cevap: Tüm bu bilgiler etcd kümesinde saklanır. Etcd’nin key-value deposunda saklanmayan şey ise gerçek uygulama verileridir. Örneğin, bir cluster içinde çalışan bir database uygulamamız varsa, veriler etcd’de değil, başka bir yerde saklanır. Bu, yalnızca master işlemlerinin worker işlemleriyle ve tersiyle iletişim kurması için kullanılan bir cluster state bilgisidir.</p>
    <p>Artık muhtemelen ana işlemlerin, özellikle de verileri güvenilir bir şekilde saklanması veya çoğaltılması gereken etcd deposunun, cluster operasyonu için kritik öneme sahip olduğunu anlamışızdır. Bu nedenle, uygulamada bir Kubernetes kümesi genellikle birden fazla master’dan oluşur. Her bir master düğümü kendi ana işlemlerini çalıştırır; elbette API sunucusu load-balanced’dır ve etcd deposu tüm master düğümleri arasında distributed bir depolama oluşturur.</p>
    <p><img src="images/28.png" /></p>
    <hr />
    <h2 id="cluster-yapısı">Cluster Yapısı</h2>
    <p>Şimdi worker ve master node’larında çalışan işlemleri gördükten sonra, gerçek hayattaki bir cluster kurulumuna bakalım. Çok küçük bir cluster’da muhtemelen iki master node ve üç worker node olur.</p>
    <p><img src="images/29.png" /></p>
    <p>Burada dikkat edilmesi gereken bir diğer nokta ise master node sunucularının donanım kaynaklarının aslında farklı olmasıdır. Master işlemleri daha önemlidir, ancak aslında daha az iş yüküne sahiptirler. Dolayısıyla CPU, RAM ve depolama gibi daha az kaynağa ihtiyaç duyarlar. Worker node’ları ise, containerları çalıştıran pod’ları barındırma gibi asıl işi yaparlar.</p>
    <p>Bu nedenle, worker node’larının daha fazla kaynağa ihtiyacı vardır. Uygulamamızın karmaşıklığı ve kaynak gereksinimi arttıkça, aslında cluster’ımıza daha fazla master ve worker node’u ekleyerek daha güçlü ve sağlam bir küme oluşturabiliriz. Böylece uygulama kaynak gereksinimlerimizi karşılayabiliriz.</p>
    <p><img src="images/30.png" /></p>
    <p>Var olan bir Kubernetes cluster’ında yeni master veya worker serverları eklemek aslında oldukça kolaydır. Bir master sunucusu eklemek istiyorsak, yeni bir bare metal sunucu ediniyoruz. Üzerine tüm master work’leri kurup onu Kubernetes kümesine ekliyoruz. Bu kadar..</p>
    <p>Yine aynı şekilde, iki worker node’una ihtiyacımız varsa, bare metal sunucular ediniyoruz. Container runtime, kubelet ve kube-proxy gibi tüm worker node işlemlerini üzerlerine kurup onları Kubernetes clusterına ekleyin.</p>
    <p>İşte bu kadar. Bu şekilde, uygulama karmaşıklığı ve kaynak gereksinimi arttıkça, Kubernetes kümemizin gücünü ve kaynaklarını sonsuza kadar artırabiliriz.</p>
    <hr />
    <h2 id="minikube-ve-kubectl-kurulumu">Minikube ve Kubectl Kurulumu</h2>
    <h3 id="minikube">Minikube</h3>
    <p><img src="images/31.png" /></p>
    <p>Genellikle Kubernetes dünyasında bir production cluster kurduğumuzda, aşağıdaki gibi görünecektir.</p>
    <p><img src="images/32.png" /></p>
    <p>En az iki olmak üzere birden fazla Master’a sahip olacağız ve birden fazla worker node olacak. Worker düğümlerinin kendi ayrı sorumlulukları vardır. Diyagramda gördüğümüz gibi, her biri bir node’u temsil eden gerçek ayrı sanal veya fiziksel makinelerimiz olur.</p>
    <p>Şimdi, yerel ortamımızda bir şey test etmek istiyorsak veya yeni bir uygulama, yeni bileşenler dağıtarak çok hızlı bir şekilde bir şey denemek istiyorsak ve bunları yerel makinemizde test etmek istiyorsak; açıkçası böyle bir cluster kurmak oldukça zor olacaktır. Bellek ve CPU gibi yeterli kaynağımız yoksa imkansız bile olabilir. İşte tam olarak bu kullanım durumu için <code>Minikube</code> adı verilen açık kaynaklı araç var.</p>
    <p>Minikube’un ne olduğuna gelirsek, temelde hem master processleri hem de worker processleri tek bir node’da çalıştıran tek node bir clusterdır. Bu node’da önceden yüklenmiş bir Docker container runtime olacak şekilde konteynerleri veya konteynerli pod’ları çalıştırabileceğiz.</p>
    <p><img src="images/33.png" /></p>
    <p>Dizüstü bilgisayarımızda VirtualBox, KVM veya başka bir hipervizör aracılığıyla çalışacak. Yani temel olarak, Minikube dizüstü bilgisayarlarımızda bir sanal makine oluşturacak ve burada gördüğümüz node’lar bu sanal makinede çalışacak.</p>
    <p>Özetleyecek olursak, Minikube, yerel kurulumumuzda Kubernetes’i test etmek için kullanabileceğimiz dizüstü bilgisayarınızda bir sanallaştırma aracıyla çalışan tek node bir Kubernetes clusterdır.</p>
    <p><img src="images/34.png" /></p>
    <p>Yerel makinemizde bir cluster veya mini cluster kurduktan sonra, bu cluster ile etkileşim kurmak için bir yola ihtiyacımız olacaktır. Componentler oluşturmak, yapılandırmak vb. isteyeceğiz. Tam burada <code>kubectl</code> devreye giriyor.</p>
    <h3 id="kubectl">Kubectl</h3>
    <p>local makinemizde Minikube’u temsil eden bu virtual node’a sahip olduktan sonra, bu cluster ile etkileşim kurmak için bir yola ihtiyacımız vardır. Bunu Kubernetes clusterları için bir command line toolu olan <code>kubectl</code> kullanarak yapabiliriz.</p>
    <p>Nasıl çalıştığını görelim. Minikube’un hem master hem de worker processleri çalıştırdığını söylemiştik, bu nedenle API server adı verilen master processlerden biri aslında Kubernetes clusterın entry point noktasıdır.</p>
    <p><img src="images/35.png" /></p>
    <p>Kubernetes’te bir şey yapmak istiyorsak veya herhangi bir şeyi yapılandırmak istiyorsak, önce API server ile konuşmamız gerekir. API server ile konuşmanın yolu ise farklı istemciler aracılığıyla olur. Bir dashboard gibi bir UI arayüzünüz olabilir, Kubernetes API’sini kullanarak konuşabilir veya <code>kubectl</code> command line tool kullanabiliriz.</p>
    <p><img src="images/36.png" /></p>
    <p><code>kubectl</code> aslında üç istemcinin de en güçlüsüdür çünkü <code>kubectl</code> ile Kubernetes’te istediğimiz her şeyi yapabiliriz.</p>
    <p>Bu yazının neredeyse sonuna kadar <code>kubectl</code> kullanılmaktadır. <code>kubectl</code> API sunucusuna component oluşturmak, component silmek vb. için komutlar gönderdikten sonra, Minikube node’undaki worker processler bunları gerçekleştirecektir. Pod’lar oluşturmak, pod’ları yok etmek, servisler oluşturmak vb. için komutları yürüteceklerdir.</p>
    <p>Bu, Minikube çalışma şeklidir. <code>kubectl</code> cluster ile nasıl kullanılır? Burada önemli bir nokta, <code>kubectl</code>’in yalnızca Minikube cluster için olmadığıdır. Bir cloud cluster’ımız veya hibrit bir cluster’ımız varsa, <code>kubectl</code> herhangi bir Kubernetes cluster kurulumuyla etkileşim kurmak için kullanılan araçtır. Bu nedenle burada unutulmaması önemlidir.</p>
    <p><img src="images/37.png" /></p>
    <p>Artık Minikube ve <code>kubectl</code>’nin ne olduğunu bildiğimize göre, onları pratikte görmek için kuruluma başlayalım.</p>
    <h3 id="kurulum">Kurulum</h3>
    <p>Daha önce de belirttiğimiz gibi Minikube bir sanallaştırmaya ihtiyaç duyar, çünkü bazı hipervizörlerde çalışacaktır. Bu nedenle bir tür hipervizör yüklemeliyiz.</p>
    <p>Şimdi linux üzerinde minikube ve kubectl kurulumuna geçelim.</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube &amp;&amp; rm minikube-linux-amd64
            </code></pre>
        </div>
    </div>

    <p>Şimdi her şeyin kurulduğundan emin olalım ve komutları kontrol edelim. Yani, <code>minikube</code> komutu çalışmalı:</p>


    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">c3ng0@ubn:~$ minikube start

            😄  minikube v1.33.1 on Ubuntu 22.04
            ✨  Automatically selected the docker driver. Other choices: kvm2, qemu2, none, ssh
            📌  Using Docker driver with root privileges
            👍  Starting &quot;minikube&quot; primary control-plane node in &quot;minikube&quot; cluster
            🚜  Pulling base image v0.0.44 ...
            💾  Downloading Kubernetes v1.30.0 preload ...
                &gt; preloaded-images-k8s-v18-v1...:  112.62 MiB / 342.90 MiB  32.84% 5.18 MiB
                &gt; gcr.io/k8s-minikube/kicbase...:  70.41 MiB / 481.58 MiB  14.62% 2.65 MiB
                &gt; index.docker.io/kicbase/sta...:  481.58 MiB / 481.58 MiB  100.00% 11.15 M
            ❗  minikube was unable to download gcr.io/k8s-minikube/kicbase:v0.0.44, but successfully downloaded docker.io/kicbase/stable:v0.0.44 as a fallback image
            🔥  Creating docker container (CPUs=2, Memory=2200MB) ...
                &gt; kubectl.sha256:  64 B / 64 B [-------------------------] 100.00% ? p/s 0s
                &gt; kubeadm.sha256:  64 B / 64 B [-------------------------] 100.00% ? p/s 0s
                &gt; kubelet.sha256:  64 B / 64 B [-------------------------] 100.00% ? p/s 0s
                &gt; kubectl:  49.07 MiB / 49.07 MiB [------------] 100.00% 14.58 MiB p/s 3.6s
                &gt; kubeadm:  47.92 MiB / 47.92 MiB [--------------] 100.00% 3.97 MiB p/s 12s
                &gt; kubelet:  95.46 MiB / 95.46 MiB [--------------] 100.00% 6.52 MiB p/s 15s

                ▪ Generating certificates and keys ...
                ▪ Booting up control plane ...
                ▪ Configuring RBAC rules ...
            🔗  Configuring bridge CNI (Container Networking Interface) ...
            🔎  Verifying Kubernetes components...
                ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
            🌟  Enabled addons: storage-provisioner, default-storageclass
            💡  kubectl not found. If you need it, try: &#39;minikube kubectl -- get pods -A&#39;
            🏄  Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default</code></pre>
        </div>
    </div>


    <p>Ve <code>kubectl</code> indirmemiz gerekiyor:</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            </code></pre>
        </div>
    </div>
    <p>Binary’i doğrula(opsiyonel)</p>
    <p>kubectl checksumfile indir:</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256"
            </code></pre>
        </div>
    </div>

    <p>İndirilen checksum file ile binary doğrulama:</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check
            </code></pre>
        </div>
    </div>
    <p>Doğru ise çıktı aşağıdaki gibi olmalı:</p>


    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl: OK
            </code></pre>
        </div>
    </div>
    <ul>
    <li>Kubectl Kurulumu</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
            </code></pre>
        </div>
    </div>
    <ul>
    <li>Son sürümü kurduğumuzu kontrol etme:</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl version --client
            </code></pre>
        </div>
    </div>
    <br>
    <br>
    <p><img src="images/38.png" /></p>
    <p>daha fazlası için <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/">kubernetes.io</a></p>
    <p>Minikube oldukça basit bir komut satırı aracı ile birlikte gelir. Tek bir komutla tüm Kubernetes kümesini bu tek düğüm kurulumunda hızlıca başlatabilir, durdurabilir veya silebiliriz.</p>
    <hr />
    <h2 id="ilk-cluster">İlk Cluster</h2>
    <p>Şimdi her ikisini de kurduğumuza göre, bir Minikube Kubernetes cluster oluşturalım.</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
minikube start
            </code></pre>
        </div>
    </div>


    <p>işte Minikube ile bir Kubernetes cluster nasıl başlatacağımız:</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
minikube start --vm-driver=kvm
            </code></pre>
        </div>
    </div>


    <p>Burada, kurulu hipervizörün devreye girdiğini görebiliriz çünkü Minikube’un bir Sanal ortamda çalışması gerektiğinden, Minikube’a hangi hipervizörü kullanması gerektiğini söyleyeceğiz. Bunun için, <code>--vm-driver</code> olarak adlandırılan bir seçenek belirleyeceğiz ve burada bende kurulu olan <code>kvm</code>’i ayarladım.</p>
    <p>Bunu yürüttüğümde bir şeyler indirecek, yani ilk kez yapıyorsak biraz daha uzun sürebilir.</p>
    <p><img src="images/39.png" /></p>
    <p>Ve bahsettiğim gibi, makinenizde Docker yoksa bile çalışacak.</p>
    <p>Tamamlandı. Artık <code>kubectl</code>, Minikube’u kullanacak şekilde yapılandırılmış durumda, bu da Minikube cluster’ının kurulduğu anlamına gelir.</p>
    <p><img src="images/40.png" /></p>
    <p>Kubernetes Kümesi ile etkileşimde bulunmak için tasarlanmış olan <code>kubectl</code> komutu da o Minikube kümesi ile bağlantılıdır, eğer şunu yaparsak:</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl get nodes
            </code></pre>
        </div>
    </div>


    <p>Bu, Kubernetes cluster node’larının durumunu bize bildirir. Bize bir Minikube node’unun hazır olduğunu söyleyecek ve gördüğümüz gibi açıkça master processleri çalıştırmalı çünkü sadece bir node var.</p>
    <p><img src="images/41.png" /></p>
    <p>Ve ayrıca Minikube’ın durumunu alabiliriz:</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
minikube status
            </code></pre>
        </div>
    </div>

<br>
    <p><img src="images/42.png" /></p>
    <p>Yani, ana makinede kubelet adlı bir hizmetin çalıştığını görüyoruz, bu da aslında konteyner runtime kullanarak pod’ları çalıştıran bir hizmettir, yani her şey çalışıyor.</p>
    <p>Buradan itibaren mini Kub kümesi ile <code>kubectl</code> komut satırı aracılığıyla etkileşime geçeceğiz. Minicube sadece cluster başlatma ve silme için kullanılır, ancak configuring ve diğer her şeyi <code>kubectl</code> aracılığıyla yapacağız.</p>
    <hr />
    <h2 id="main-kubectl-komutları">Main Kubectl Komutları</h2>
    <p>Bu bölümde bazı temel Kubectl komutlarını göreceğiz ve minikube’da nasıl create ve debug pods yapıldığını göreceğiz.</p>
    <p>Cubectl’i clusterda herhangi bir şey yapmak için kullanacağız. -components oluşturmak, status almak, vb.-</p>
    <ul>
    <li>İlk olarak, node’ların durumunu alacağız.</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl get nodes
            </code></pre>
        </div>
    </div>
    <p>Bu komutu kullanarak node’ların durumunu öğrenebiliyoruz.</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl get nodes
    NAME       STATUS   ROLES           AGE    VERSION
    minikube   Ready    control-plane   145m   v1.30.0
            </code></pre>
        </div>
    </div>
    <p>Görüyoruz ki bir node var ve her şey o node’da çalışıyor çünkü bu bir <code>minikube</code>.</p>
    <ul>
    <li>Pod’ları kontrol edebiliriz ve herhangi bir pod’umuz olmadığı için sonuç yok.</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl get pod
            </code></pre>
        </div>
    </div>
    <ul>
    <li>Services kontrol edebiliriz, varsayılan bir servisimiz var.</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl get services
    NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
    kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   148m
            </code></pre>
        </div>
    </div>
    <p>Şimdi, herhangi bir Pod’umuz olmadığı için bir tane oluşturacağız ve Kubernetes bileşenleri oluşturmanın bir Kubectl create komutu olduğunu hatırlayalım. Kubectl create komutunu kullanarak tüm bu bileşenleri oluşturabiliriz.</p>
    <ul>
    <li>Ancak listede <code>Pod</code> yok çünkü Kubernetes dünyasında, Pod, Kubernetes clusterının en küçük birimidir ve genellikle, Pod’ları doğrudan oluşturulmaz. Veya Pod’larla doğrudan çalışılmaz. Pod’ların üzerinde bir soyutlama katmanı<code>(abstraction over Pods)</code> vardır, buna ·<code>deployment</code>· denir. İşte bu oluşturmak üzere olduğumuz şey. Bu da, altındaki parçaları oluşturacak.</li>
    </ul>
    <div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ex">Usage</span>:</span>
    <span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>   <span class="ex">kubectl</span> create deployment NAME --image=image -- [COMMAND] [args...] [options]</span></code></pre></div>
    <ul>
    <li><strong>NAME</strong>: deployment’a isim vermeliyiz</li>
    <li><strong>–image=</strong>: oluşturacağımız container image’i</li>
    </ul>
    <p>Şimdi bir nginx dağıtımı oluşturalım.</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl create deployment nginx-depl --image=nginx
  deployment.apps/nginx-depl created
            </code></pre>
        </div>
    </div>

<br>
    <ul>
    <li>Nginx görüntüsünü, Docker Hub’dan indirecektir. Bu komutu yürüttüğümüz zaman, gördüğünüz gibi nginx deployment oluşturuldu.</li>
    </ul>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
c3ng0@ubn:~$ kubevtl get deployment
    NAME         READY   UP-TO-DATE   AVAILABLE   AGE
    nginx-depl   0/1     1            0           15s
            </code></pre>
        </div>
    </div>

<br>
    <ul>
    <li>Oluşturulmuş bir deployment olduğunu görüyoruz ve burada “hazır değil” durumunda olduğunu da görebiliyoruz.</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl get pod
    NAME                          READY   STATUS    RESTARTS   AGE
    nginx-depl-85c9d7c5f4-g4lwt   0/1     Creating  0          31s
            </code></pre>
        </div>
    </div>


    <ul>
    <li><p>Artık bir Pod’umuz var. Name değeri, prefix ve rastgele bir hash’e sahipt. Burada “konteyner oluşturuluyor” yazıyor, yani henüz hazır değil. Bir süre beklersek <code>Running</code>.</p></li>
    <li><p>Bir deployment oluşturduğumuzda, deployment, Pod oluşturmak için gereken tüm bilgilere veya blueprintlere sahip olur.</p></li>
    </ul>
    <p><img src="images/43.png" /></p>
    <ul>
    <li><p>Bu en temel yapılandırmadır, sadece adı ve görüntüsü. Bu kadar.. geri kalanı default.</p></li>
    <li><p>Deployment ve Pod arasında bir başka katman vardır ve bu, otomatik olarak kubernetes tarafından yönetilen <code>replicaset</code>’tir.</p></li>
    <li><p><code>kubectl get replicaset</code> yaparsak, bir nginx replica set hash’imiz olduğunu görüyoruz. Ve burada, Pod adının bir deployment prefix, replicaset’in ID’si ve son olarak kendi ID’si olduğunu görebiliriz. Pod adı bu şekilde oluşmaktadır. Replicaset, Pod’un tüm replikalarını yönetir. Biz hiçbir zaman replica set oluşturmayacak, silmeyecek veya güncellemeyeceğiz. Doğrudan deploymentlar ile çalışacağız. Bu daha uygun çünkü deploymentlarda Pod blueprintini tamamen yapılandırabiliriz. Pod’un kaç replikasına ihtiyacımız olduğunu belirtebilir ve geri kalan configuration’u orada yapabiliriz.</p></li>
    </ul>
    <h3 id="layerların-çalışma-şekli">Layerların çalışma şekli:</h3>
    <ul>
    <li>İlk olarak Deployment, ReplicaSet’i yönetir.</li>
    <li>ReplicaSet, o Pod’un tüm replikalarını yönetir.</li>
    <li>Pod, bir konteynerin soyutlamasıdır. Deployment’tan aşağıdaki her şey otomatik olarak kubernetes tarafından yönetilmelidir.</li>
    </ul>
    <p>Örneğin, kullanıldığı image gibi bir şeyi doğrudan bir deployment içerisinde düzenlememiz gerekecek, Pod içinde değil. Öyleyse hemen yapalım.</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">nginx-depl.yaml</span>
        </div>
        <div class="window-content">
            <pre><code class="language-yaml">
              c3ng0@ubn:~$ kubectl edit deployment nginx-depl


                    # Please edit the object below. Lines beginning with a '#' will be ignored,
                    # and an empty file will abort the edit. If an error occurs while saving this file will be
                    # reopened with the relevant failures.
                    #
                    apiVersion: apps/v1
                    kind: Deployment
                    metadata:
                      annotations:
                        deployment.kubernetes.io/revision: "1"
                      creationTimestamp: "2024-05-14T11:31:36Z"
                      generation: 1
                      labels:
                        app: nginx-depl
                      name: nginx-depl
                      namespace: default
                      resourceVersion: "9431"
                      uid: 66d185d6-b628-4d10-b3bc-4aea093dfc59
                    spec:
                      progressDeadlineSeconds: 600
                      replicas: 1
                      ...
                      ...
                      ...
            </code></pre>
        </div>
    </div>

    <p>Deployment oluştururken verdiğimiz iki seçenek dışında her şeyin otomatik olarak oluşturulmuş bir deployment, otomatik olarak oluşturulmuş bir yapılandırma dosyasını alıyoruz. Şimdilik sadece image'i istediğimiz versiyonu 1.16’ya sabitlemek istediğimizi varsayalım ve bu değişikliği kaydedelim.</p>


    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
              spec:
                containers:
## Sildik       - image: nginx
          ---
              spec:
                containers:
## Ekledik      - image: nginx:1.16
            </code></pre>
        </div>
    </div>

    <pre><code>
    </code></pre>
    <p>Ve gördüğünüz gibi dağıtım düzenlendi.</p>
    <p><img src="images/44.png" /></p>
    <p>Şimdi <code>kubectl get pod</code> yaparsak, eski pod’umuzu görürüz.</p>
    <p><img src="images/45.png" /></p>
    <ul>
    <li>Eski Pod sona erdi ve yeni pod başladı.</li>
    </ul>
    <p>Eğer ReplicaSet’i görüntülersek, eski olanın içinde pod olmadığını ve yeni bir tane oluşturulduğunu görüyoruz.</p>
    <p><img src="images/46.png" /></p>
    <p>Yani sonuç olarak deployment yapılandırmasını düzenledik ve altındaki her şey otomatik olarak güncellendi. Bu yaptığımız, Kubernetes’in sihrine ve nasıl çalıştığına bir örnektir.</p>
    <h3 id="debugging-pods">Debugging Pods</h3>
    <p>Bir diğer çok pratik komut ise <code>kubectl logs</code>, bu aslında Pod içinde çalışan uygulamanın neyi kaydettiğini gösterir.</p>

    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl logs [POD_NAME]
            </code></pre>
        </div>
    </div>


    <p>Logları görüntülemeden önce Nginx hiçbir şey kaydetmediği için başka bir dağıtım oluşturalım. Mongodb’den oluşturalım ve adına <code>mongo-depl</code> verelim.</p>
    <p><img src="images/47.png" /></p>
    <p>Şimdi mongodb deployment oluşturuluyor.</p>
    <p><img src="images/48.png" /></p>
    <p>Şu anda loglara bakabiliriz:</p>
    <p><img src="images/49.png" /></p>
    <ul>
    <li><code>kubectl describe pod [POD_NAME]</code> events sekmesinde bize state değişikliklerini verir.</li>
    </ul>
    <br>
    <p><img src="images/50.png" /></p>
    <p>Loglamak, uygulamanın gerçekte neyi yazdığını görmede ve hata ayıklamada yardımcı olmaktadır.</p>
    <p>Başka bir çok kullanışlı komut, <code>kubectl exec</code>tir. Debugging yaparken, bir şey çalışmıyorsa veya sadece Pod’un içeriğini kontrol etmek için kullanılır. Basitçe açıklayacak olursak, çalışan Pod’dan shell alır. bu yüzden:</p>


    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl exec -it [POD_NAME] -- bin/bash
            </code></pre>
        </div>
    </div>
<br>
    <ul>
    <li>-it = <strong>interactive terminal</strong></li>
    </ul>
    <p><img src="images/51.png" /></p>
    <p>Bu komutla mongodb uygulama konteynerinin terminalini alıyoruz ve şu anda root kullanıcısı olarak mongodb konteynerinin içindeyiz. Exec, hata ayıklama veya bir şeyleri test etmek veya denemek istediğinizde kullanışlıdır. Konteynera girebilir veya terminali alabilir ve orada bazı komutlar çalıştırabiliriz.</p>
    <h3 id="deployment-silme-ve-apply-configuration-file">Deployment Silme ve Apply Configuration File</h3>
    <p>Tabii ki kubectl ile podları silebiliriz, önce deployment’ları ve podları görüntüleyelim.</p>
    <p><img src="images/52.png" /></p>
    <pre><code>kubectl delete deployment [deployment_name]</code></pre>
    <p><img src="images/53.png" /></p>
    <p>kontrol edersek Pod’un sonlandığını ve eğer replica set alırsak, mongodb replicasetinin de gittiğini görebiliriz.</p>
    <p>Tüm crud işlemleri (create,update,delete vb.) deployment seviyesinde gerçekleşir ve altındaki her şey otomatik olarak takip eder. Aynı şekilde Services gibi diğer Kubernetes kaynakları oluşturabiliriz.</p>
    <p>Ancak fark ettiğiniz gibi, Kubectl ile deployment gibi kubernetes bileşenlerini oluştururken, tüm bu seçenekleri komut satırında belirtmemiz gerekir.</p>
    <ul>
    <li>Adı belirtmemiz gerekir.</li>
    <li>Image’i belirtmemiz gerekir</li>
    <li>option1</li>
    <li>option2.. vb. olabilir.</li>
    </ul>
    <p>Elbette bir deployment’ta veya bir Pod’ta yapılandırmak istediğimiz birçok şey olabilir ve açıkçası bunların hepsini komut satırında yazmak pratik olmayacaktır. Bunun için genellikle Kubernetes yapılandırma dosyalarıyla çalışılmaktadır. Yani oluşturduğumuz bileşenin türü, adı, image’i ve diğer tüm seçenekleri bir yapılandırma dosyasında toplanır. Sadece cubectl’e bu yapılandırma dosyasını yürütmesini söyleriz.</p>
    <p>Bunu yapmanın yolu <code>kubectl apply</code> komutunu kullanmaktır.</p>
    <h3 id="kubectl-apply">kubectl apply</h3>
    <p>Apply, temelde dosyayı, yapılandırma dosyasını bir parametre olarak alır ve orada ne yazdıysak yapar.</p>
    <div class="sourceCode" id="cb26"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="ex">kubectl</span> apply -f [file_name]</span></code></pre></div>
    <p>Apply, “-f” için bir seçenek alır ve bu dosyanın adını belirtir ve genellikle bu dosyalar için kullanılan biçim YAML’dir ve bu, dosyadaki her şeyi yürüten komuttur. Bu yüzden aslında bunu yapılandırma dosyası olarak adlandıracağız.</p>
    <p>Örnek olarak çok basit, temel bir <code>nginx-deployment.yaml</code> deployment dosyası oluşturalım.</p>
    <p>Deployment için temel yapılandırma:</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">nginx-deployment.yaml</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.16
        ports:
        - containerPort: 80
            </code></pre>
        </div>
    </div>

    <ul>
    <li>Şu an için gerekli olan satırları, aşağıda inceleyelim.</li>
    </ul>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
    kind: Deployment
        ## Ne oluşturmak istediğimizi belirtiyoruz, Deployment oluşturmak istiyoruz.
    name: nginx-deployment
        ## Oluşturacağımız Deployment ismi.
    spec:            ## specification for deployment
          replicas: 1    ## Pod'lardan oluşturulacak replika sayısı
      template:
            metadata:
              labels:
                app: nginx
            spec:    ## specification for pods
              containers:
              - name: nginx
                image: nginx:1.16   ## Konteyner image'imiz için nginx versiyonu
                ports:
                - containerPort: 80 ## Binding Port
        ## Bu alan olutşturacağımız deployment'a ait blueprint
            </code></pre>
        </div>
    </div>

    <p>Bu, bizim config dosyamız ve buna bir kere sahip olduktan sonra, bu yapılandırmayı istediğimiz zaman uygulayabiliriz.</p>
    <p><img src="images/54.png" /></p>
    <p>Deployment oluşturuldu, şimdi podu görüntülersek, nginx dağıtımı podu oluşturuldu ve çalışıyor olduğunu görürüz.</p>
    <p><img src="images/55.png" /></p>
    <p>Ayrıca dağıtımın 3 dakika 57 saniye önce oluşturulduğunu görüyoruz. Eğer bu deployment’ta bir şeyleri değiştirmek istersek, sadece yerel yapılandırmamızı değiştirmemiz yeterlidir. Örneğin, bir yerine iki replika istersek, sadece dosyayı düzenleyip tekrar apply ederiz. Ve deployment, nginx dağıtımı olarak tekrar yapılandırılacaktır.</p>
    <p><img src="images/56.png" /></p>
    <p><img src="images/57.png" /></p>
    <p>Fark ettiysek çıktıda bize “configured” dendi. Fark şu ki, Kubernetes, nginx deployment’ının var olmadığını algılarsa, yeni bir tane oluşturacak, ancak eğer deployment zaten varsa, yapılandırma dosyasını apply ettiğimizde, onu güncellemesi gerektiğini bilecek ve yeni bir deployment oluşturmak yerine eski deployment’ı cofigure edecek.</p>
    <p><img src="images/58.png" /></p>
    <p>Eski deployment hala ayakta (9m45s) fakat yeni bir replika oluşturuldu(3m22s) çünkü replika sayısını arttırdık. yani <code>kubectl apply</code> ile bir component oluşturabilir ve güncelleyebiliriz. Elbette Services, Volumes gibi diğer kubernetes bileşenlerine de ayar çekebiliriz.</p>
    <hr />
    <p>Özetlemek gerekirse, bu yazıda birkaç kubectl komutuna baktık, bir component oluşturmayı, nasıl configure edeceğimizi ve sileceğimizi gördük. Pod’ların, deployment’ların, replikaset’lerinin vb. state’lerini nasıl alacağımızı gördük. Ayrıca Pod’un içindeki uygulamanın konsola yazdığı her şeyi nasıl kaydedeceğimizi gördük ve <code>kubectl exec</code>’i kullanarak çalışan bir konteynerdan nasıl shell alacağımızı gördük. Son olarak, kubernetes yapılandırma dosyasını ve <code>kubectl apply</code> komutunu kullanarak componentleri nasıl oluşturup güncelleyeceğimizi gördük. Son olarak azıcık da <code>kubectl describe</code> komutunu gördük, bu da bir konteynerin bir Pod’da sorun giderme için ek bilgi almak istediğinizde kullandığınız bir komuttu.</p>
    <h3 id="komutları-hatırlayalım">Komutları Hatırlayalım</h3>
    <blockquote>

      <div class="note">
        <p> <strong>Crud Komutları</strong><br>
           Deployment Oluşturma -&gt; <code>kubectl create deployment [name]</code><br>
           Deployment Düzenleme -&gt; <code>kubectl edit deployment [name]</code><br>
           Deployment Silme -&gt; <code>kubectl delete deployment [name]</code></p>
        <p><strong>Farklı Kubernetes Componenetlerin Durumu</strong><code>kubectl get nodes | pod | services | replicaset | deployment</code></p>
        <p><strong>Podlar ile Debugging</strong><br>
          Pod Logları -&gt; <code>kubectl logs [pod_name]</code><br>
          Terminal ile Poda Bağlanma -&gt; <code>kubectl exec -it [pod_name] -- /bin/bash</code><br>
          Pod Bilgisi -&gt; <code>kubectl describe pod [pod_name]</code></p>
        <p><strong>CRUD için Config Dosyası Kullanma</strong><br>
          Konfigürasyon Dosyasını Uygulama -&gt; <code>kubectl apply -f [file_name]</code><br>
          Konfigürasyon Dosyasıyla Silme -&gt; <code>kubectl delete -f [file_name]</code></p>
    </div>
    </blockquote>
    <hr />
    <h2 id="kubernetes-yaml-konfigürasyonu">Kubernetes YAML Konfigürasyonu</h2>
    <p>Bu konu başlığında Kubernetes yapılandırma dosyasının sözdizimini ve içeriğini göreceğiz.</p>
    <p><img src="images/59.png" /></p>
    <p>Bu dosya, Kubernetes clusterında componentler oluşturmak ve yapılandırmak için ana tooldur. Büyük yapılandırma dosyalarını gördüysek biraz karışık olduklarını düşünebiliriz, ancak aslında oldukça basit ve mantıklı bir yapıya sahiptir. Öyleyse başlayalım!</p>
    <h3 id="parçada-k8s-config-dosyası">3 Parçada K8s Config Dosyası</h3>
    <p><img src="images/60.png" /></p>
    <p>Yukarıdaki fotoğrafta yan yana bir <code>deployment</code> ve <code>service</code> yapılandırma dosyası örnekleri var.</p>
    <p>Öncelikle her Kubernetes config(yapılandırma) dosyası üç kısımdan oluşur.</p>
    <ul>
    <li>İlk kısım, oluşturduğunuz componentin <code>metadata</code>’larının bulunduğu yerdir.</li>
    <li>İkinci kısım, yapılandırma dosyasındaki <code>specification</code>’dur(özellik). Her component config dosyasında, o component için uygulamak istediğimiz her türlü yapılandırmayı bu bölüme koyarız.</li>
    </ul>
    <p><img src="images/61.png" /></p>
    <p>Config dosyasındaki İlk iki satır, tam olarak neyi oluşturmak istediğimizi belirtiyor. Soldaki kısımda <code>deployment</code> oluşturuyoruz, sağdaki kısımda ise bir <code>service</code> oluşturuyoruz. İlk satırlarda ise API versiyonu belirtiyoruz. Her component için API versiyonu farklı olabilir. Ve bu, her component için bir API versiyonu araştırmanız gerektiği anlamına gelir.</p>
    <ul>
    <li><em>Kubernetes’te her bileşenin farklı API sürümü olmasının temel nedeni, her bileşenin farklı gereksinimlere ve özelliklere sahip olmasıdır. Her bileşenin farklı bir API sürümü olması, bu bileşenin özelliklerini ve davranışını belirleyen özelleştirilmiş bir yapıya sahip olmasını sağlar.</em></li>
    </ul>
    <p>Specification kısmında belirteceğimiz özellikler, oluşturduğumuz component türüne özgü olacaktır. Aşağıdaki resimde görüldüğü gibi:</p>
    <p><img src="images/63.png" /></p>
    <p>Deployment kendi özelliklerine sahip olacak ve tabii servis de kendi şeylerine sahip olacak.</p>
    <p>Hatırlarsak config dosyalarının üç parçadan olduğunu söylemiştik ama şu an sadece <code>metadata</code> ve <code>specification</code>’u gördük. Peki üçüncü parçamız nerede?</p>
    <ul>
    <li>Üçüncü kısım <code>status</code>’tur. Kubernetes tarafından otomatik olarak oluşturulup eklenir.</li>
    </ul>
    <p>Çalışma şekli şöyledir:</p>
    <ul>
    <li><p>Kubernetes her zaman <code>desired state</code>(istenen durum) ve <code>actual state</code>’i(gerçek durum) karşılaştırır. Eğer gerçek durum ve istenen durum uyuşmuyorsa, Kubernetes bir şeylerin düzeltilmesi gerektiğini bilir ve onu düzeltmeye çalışır.</p></li>
    <li><p>Bu, Kubernetes’in sağladığı <code>self-healing</code> özelliğinin temelidir.</p></li>
    <li><p>Örneğin, yukarıdaki deployment kodundaki specification bölümünde, nginx deployment için iki replika istediğimizi belirtmişiz. Bu config dosyasını kullanarak deployment oluşturduğumuzda(apply), Kubernetes, deployment status(durumunu) takip edecek, config dosyamıza status parçamızı da ekleyecek ve bunu sürekli olarak güncelleyecektir.</p></li>
    </ul>
    <p><img src="images/65.png" /></p>
    <ul>
    <li>Eğer status, bir noktada sadece bir replikanın çalıştığını söylüyorsa, Kubernetes bu statusu özellikle belirttiğimiz iki replikayla karşılaştıracak ve bir sorun olduğunu bilecektir. Başka bir replika oluşturması gerektiğini anlayacak ve bunu otomatik olarak gerçekleştirecektir. <code>self-healing</code>.</li>
    </ul>
    <p><img src="images/66.png" /></p>
    <p>Bunları görünce aklımıza Kubernetes’in, otomatik olarak buraya ekleyerek veya sürekli olarak güncellemek için status verisini nereden aldığı takılabilir.</p>
    <ul>
    <li>Bu bilgi daha önce bahsettiğimiz <code>etcd</code>’den gelir. Master process’lerden biri olan etcd, aslında cluster verilerini depolar. Etcd <strong>her zaman</strong> herhangi bir Kubernetes bileşeninin mevcut durumunu tutar ve bu status bilgisi buradan gelir.</li>
    </ul>
    <h3 id="config-dosyasının-formatı">Config Dosyasının Formatı</h3>
    <p>Yukarıdaki görüntülerden de gördüğümüz gibi config dosyalarının formatı <code>YAML</code>’dır. YAML oldukça basit bir formattır, ancak girintiler konusunda çok katıdır. Yanlış girintiye sahip bir dosyamız varsa, bu dosya geçersiz olacaktır. Bu yüzden 200 satırdan oluşan bir yapılandırma dosyamız varsa, <code>YAMLlint</code> gibi bir online yaml validator kullanmak mantıklı olacaktır.</p>
    <p>Başka bahsedilecek bir konu da, bu config dosyalarını nereye kaydedeceğimizdir. Klasik bir uygulama, kodumuzla birlikte saklamaktır. Çünkü deployment ve servis, uygulamaya uygulanacaktır. Bu yapılandırma dosyalarımızı, uygulama kodunun bir parçası olarak saklamak iyi bir yöntemdir. Bunlar <code>Infrastructure as a Code</code> <strong>IaC</strong> kavramının bir parçası olabilir veya config dosyaları için kendi git depolarımızı da oluşturabiliriz.</p>
    <h3 id="podlar-için-blueprint-template">Podlar için Blueprint (Template)</h3>
    <p>Biraz geriye gidersek deployment’ların, kendisinin altındaki podları yönettiğini söylemiştik.</p>
    <p><img src="images/67.png" /></p>
    <p>Yani bir deployment’ta bir şeyi düzenlediğimizde, bunun altındaki bütün podlara yayılır ve birkaç pod oluşturmak istediğimizde aslında bir deployment oluştururuz ve bu deployment gerisini halleder.</p>
    <p>*Bunlar nasıl gerçekleşir? Bu bahsettiğimiz şeyler konfigürasyonda nerede tanımlanır?</p>
    <p>Config dosyamızdaki, <code>specification</code> kısmında yer alan <code>template</code>’i genişletirsek; template’imizin de kendi <code>metadata</code>’sının ve <code>specification</code>’u olduğunu görürüz.</p>
    <p><img src="images/71.png" /> Yani basitçe tabir edecek olursak <strong>“configuration file inside of a configuration file”</strong></p>
    <p>Bunun sebebi, template içerisindeki konfigürasyonun bir <code>pod</code> için geçerli olmasıdır. Bir podun bir deployment config dosyası içinde kendi yapılandırması olmalıdır. Bu tüm deployment’ların nasıl tanımlanacağını gösterir.</p>
    <p><img src="images/72.png" /> Bu sarı alan ise bir pod için bir blueprint’tir. Hangi image’e dayanacağımızı, hangi portu açacağımızı, konteynerin adının ne olacağını vb. belirler.</p>
    <h3 id="connecting-components-labels-selectors-ports">Connecting Components (Labels &amp; Selectors &amp; Ports)</h3>
    <p>Bağlantının kurulduğu şekil <code>labels</code> ve <code>selectors</code> kullanılarak gerçekleşir.</p>
    <p><img src="images/73.png" /> * Metadata bölümü <code>labels</code> içerir.</p>
    <p><img src="images/74.png" /> * Specification bölümü ise <code>selectors</code> içerir.</p>
    <hr />
    <p>Metadata kısmında bir componente bir <code>key-value</code> (anahtar-değer) çifti veririz. Yukarıdaki örnekte app: nginx var. Bu label, bu componente yapışıyor.</p>
    <p>Bu şekilde, bu blueprint kullanılarak oluşturulan podlara <code>app: nginx</code> labeli veriyoruz ve deploymenti, “app: nginx” label’iyle eşleşen tüm label’lara bağlamak veya eşleştirmek için ayarlıyoruz.</p>
    <p><img src="images/75.png" /></p>
    <p>Bu sayede deployment, hangi podların kendisine ait olduğunu bilecektir.</p>
    <p>Dağıtımın kendi “app nginx” labeli var ve bu iki label, <code>Service</code> içindeki <code>selector</code> tarafından kullanılır. Bu nedenle, Service içerisinde specification bölümünde bir selector tanımlarız ki bu, temelde bir connection oluşturur. (Service ile Deployment veya parçaları arasında)</p>
    <p><img src="images/76.png" /></p>
    <p>Çünkü Service, kendisine kayıtlı olan podları, hangi podların o servise ait olduğunu bilmesi gerekir ve bu bağlantı <code>label</code>’ın <code>selector</code> bölümüyle yapılır.</p>
    <ul>
    <li>Service ve pod içinde yapılandırılması gereken başka bir şey de <code>Port</code> lardır.</li>
    </ul>
    <p>Yani, servis içerisinde, servisin kendisinin erişilebilir olduğu bir <em>Port</em> vardır.</p>
    <p><img src="images/77.png" /></p>
    <p>Pod içerisindeki Konteynerın da kendisine ait bir Port’u vardır.</p>
    <p><img src="images/78.png" /></p>
    <p>Bu nasıl yapılandırılır? Temelde, bir servisin kendisinin erişilebilir olduğu bir portu vardır, bu yüzden diğer servisler bir istek gönderdiğinde bu nginx servisine isteği 80 numaralı bağlantı noktasında göndermelidir, ancak bu servisin, isteği hangi pod’a yönlendirmesi gerektiğini, aynı zamanda o pod’un hangi portu dinlediğini de bilmesi gerekir ve bu da <code>target port</code>tur.</p>
    <p><img src="images/79.png" /></p>
    <p>Alttaki resimdeki gibi sağdaki servis config dosyamızdaki <code>targetPort: 8080</code>, Deployment config dosyasındaki container’ın portuyla <code>containerPort:8080</code> eşleşmelidir.</p>
    <p><img src="images/80.png" /></p>
    <p>Böylelikle deployment ve servisimizin temel yapılandırmalarını tamamlamış oluruz. Burada dikkate alınması gereken önemli bir nokta, Aşağıdaki resimdeki her iki bölümde de gördüğümüz çoğu özelliğin zorunlu olduğudur.</p>
    <p><img src="images/81.png" /><br></p>
    <p>Bu aslında deployment ve servis için minimum yapılandırmadır.</p>
    <p>Dosyalarımızı elde ettikten sonra, bunları uygulayabilir veya bunları kullanarak bileşenler oluşturabiliriz. Konsola geçip oluşturmadan önce <code>nginx-deployment.yaml</code> dosyası ile <code>nginx-service.yaml</code> dosyalarının içeriklerini buraya yazıyoruz.</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">nginx-deployment.yaml</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
    apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: nginx-deployment
          labels:
            app: nginx
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: nginx
          template:
            metadata:
              labels:
                app: nginx
            spec:
              containers:
              - name: nginx
                image: nginx:1.16
                ports:
                - containerPort: 8080

    apiVersion: v1
        kind: Service
        metadata:
          name: nginx-service
        spec:
          selector:
            app: nginx
          ports:
          - protocol: TCP
            port: 80
            targetPort: 8080
            </code></pre>
        </div>
    </div>
    <p><img src="images/82.png" /> <img src="images/84.png" /></p>
    <p><code>kubectl apply deployment</code> komutuyla deployment ve servis oluşturuldu.</p>
    <p>Şimdi eğer podları listelersem, burada iki replikanın çalıştığını görüyoruz çünkü config dosyamızda böyle tanımlamıştık. <img src="images/85.png" /></p>
    <p>Ayrıca aşağıda görüldüğü gibi; nginx servisimiz de var.</p>
    <p><img src="images/86.png" /></p>
    <p><code>kubernetes</code> default servistir, her zaman oradadır. Bizim oluşturduğumuz <code>nginx-service</code> ve Port 80’de dinlemede.</p>
    <p>Şimdi, servisin istekleri doğru pod’lara ilettiğini nasıl doğrulayabiliriz? Bunun için:</p>
    <div class="sourceCode" id="cb34"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="ex">kubectl</span> describe service [service_name]</span></code></pre></div>
    <p><img src="images/87.png" /></p>
    <p>Ve burada, status bilgilerinin olduğunu görebiliriz. Hedef Bağlantı Noktasını tanımlarız ve burada endpoint’imiz var ve bunlar servisin isteği ileteceği pod’ların IP adresleri ve bağlantı noktaları olmalıdır. Peki, bunların doğru pod’ların IP adresleri olduğunu nasıl bileceğiz? <code>kubectl get pod</code> komutu, IP adresi bilgisi vermez. Bunun için;</p>
    <div class="sourceCode" id="cb35"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="ex">kubectl</span> get pod -o wide</span></code></pre></div>
    <p><code>-o wide</code> ile daha fazla bilgi istiyoruz.</p>
    <p><img src="images/88.png" /></p>
    <p>Artık IP adresini de görüyoruz ve baktığımız zaman, servisin doğru end-point’e sahip olduğunu biliyoruz.</p>
    <p>Şimdi, config dosyasının üçüncü partını görelim. Hatırlarsak bu Kubernetes’in otomatik olarak oluşturduğu bir durumdu. Bunu yapmanın yolu, config dosyasını yaml formatında alabiliriz.</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl get deployment nginx-deployment -o yaml
            </code></pre>
        </div>
    </div>
    <p>bu komutu çalıştırdığımızda sonuçları veya güncellenmiş configi alıyoruz. Konsolumuzda yaml çıktısını aldık fakat bunu bir dosyaya kaydedelim ve yazdığımız config ile karşılaştıralım.</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
kubectl get deployment nginx-deployment -o yaml > result.yaml
            </code></pre>
        </div>
    </div>
    <br>
    <p><img src="images/90.png" /></p>
    <p>Burada eklenen birçok şey var ama sadece status kısmına göz atalım. Daha önce de belirttiğimiz gibi tüm bunlar otomatik olarak kubernetes tarafından düzenlenir ve sürekli olarak güncellenir. Kaç replikanın çalıştığını, bu replikaların durumunu ve bazı diğer bilgileri belirtir. Bu kısım ayrıca debugging yaparken de yardımcı olabilir. Eğer fark ettiysek, metadata ve specification kısmına da yeni şeyler eklenmiş.</p>
    <p>Burada dikkate alınması gereken bir şey: * örneğin, bir deploymenti kopyalamak istersek, <em>-belki otomatikleştirilmiş betikler kullanarak-</em> yapmanız gereken bu oluşturulan extra verileri kaldırmak ve temizlemektir. * Yani bu son result deployment config dosyasını önce temizlersek, ardından o blueprint konfigürasyonundan başka bir deployment oluşturabiliriz. * Son olarak, deployment’ı veya servisi silmek istersem, bunu config dosyasını kullanarak da yapabiliriz.</p>
    <div class="sourceCode" id="cb38"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a><span class="ex">kubectl</span> delete -f nginx-deployment.yml</span></code></pre></div>
    <p><img src="images/91.png" /></p>
    <hr />
    <h2 id="ilk-demo-uygulama">İlk Demo Uygulama</h2>
    <p>Bu bölümde iki uygulama deploy edeceğiz: MongoDB ve Express. Bu iki uygulama ile basit bir web app ve database kurulumunun tipik bir örneğini çok iyi görebileceğiz. O zaman yapmaya başlayalım..<br> <img src="images/92.png" /></p>
    <ul>
    <li><p>İlk olarak bir MongoDB pod’u oluşturacağız.</p></li>
    <li><p>Bu pod ile iletişim kurabilmek için bir servise ihtiyacımız olacak. Internal servis oluşturacağız, yani bu pod’a dışarıdan gelen(external request) istekler engellenecek ve yalnızca aynı cluster içindeki componentler iletişim kurabilecek. Bu bizim istediğimiz şey.</p></li>
    <li><p>Daha sonra bir Mongo Express deployment oluşturacağız. İki şeye ihtiyacımız olacak: biri MongoDB’nin veritabanı URL’si, böylece Express bu URL’ye bağlanabilecek; diğeri ise veritabanının kullanıcı adı ve şifresi, böylece kimlik doğrulaması yapabilecek.</p></li>
    <li><p>Bu bilgileri Mongo Express deployment’a geçirebilmenin yolu, deployment config dosyasında <code>environmental variables</code>(çevresel değişkenler) aracılığıyla olacak, çünkü uygulama bu şekilde yapılandırılmış.</p></li>
    <li><p>Veritabanı URL’sini içeren bir <code>ConfigMap</code> ve kimlik bilgilerini içeren bir <code>Secret</code> oluşturacağız ve bunları deployment dosyasının içine referans olarak ekleyeceğiz.</p></li>
    <li><p>Bu kurulum tamamlandığında, Mongo Express’in tarayıcı üzerinden erişilebilir olması gerekecek. Bunu yapmak için, <code>external request</code>(dış istek)lerin pod’a iletilmesine izin verecek bir <code>external service</code> oluşturacağız.</p></li>
    </ul>
    <p><img src="images/93.png" /></p>
    <p>Bu kurulumla birlikte istek akışı aşağıdaki gibi görünecek.</p>
    <p><img src="images/94.png" /></p>
    <ul>
    <li>İstek tarayıcıdan gelecek ve Mongo Express’in external servisine gidecek.</li>
    <li>Bu servis isteği Mongo Express pod’una iletecek.</li>
    <li>Pod, MongoDB’nin internal servisine bağlanacak ve isteği MongoDB pod’una iletecek. Burada kimlik doğrulama yapılacak. <strong>Şimdi bu kurulumun tamamını Kubernetes yapılandırma dosyalarını kullanarak oluşturalım.</strong></li>
    </ul>
    <h3 id="mongodb-pod">a) MongoDB Pod</h3>
    <p>İlk olarak, çalışan bir Minikube clusterımız var. <code>kubectl get all</code> komutunu kullanarak kümedeki tüm bileşenleri listelediğimde yalnızca default Kubernetes servisini görüyoruz.</p>
    <p><img src="images/95.png" /></p>
    <p>Yani clusterımız boş ve sıfırdan başlıyoruz. İlk yapacağımız şey bir MongoDB deployment oluşturmak.</p>
    <p><img src="images/96.png" /></p>
    <p>MongoDB için hazır olan deployment dosyası aşağıdaki şekilde.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">mongodb-deployment.yaml</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: mongodb-deployment
      labels:
        app: mongodb
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: mongodb
      template:
        metadata:
          labels:
            app: mongodb
        spec:
          containers:
          - name: mongodb
            image: mongo
        </code></pre>
    </div>
</div>
    <p>Bu dağıtıma <code>mongodb-deployment</code> adını verelim. Konteyner <code>mongodb</code> olarak adlandırılacak ve kullanacağımız image bu olacak. Hadi Docker-Hub’a gidip MongoDB image yapılandırmasını kontrol edelim. * https://hub.docker.com/_/mongo</p>
    <p>Aradığımız şey, bu konteyneri nasıl kullanacağımız, yani hangi portları açacağı ve hangi harici yapılandırmaları alacağız.</p>
    <p><img src="images/97.png" /></p>
    <p>MongoDB konteynerinin varsayılan portu 27017’miş, bu yüzden bunu kullanacağız.</p>
    <p>Ayrıca <code>Environment Variables</code>(çevresel değişkenler) kullanacağız.</p>
    <p><img src="images/98.png" /></p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">mongodb-deployment.yaml</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: mongodb-deployment
      labels:
        app: mongodb
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: mongodb
      template:
        metadata:
          labels:
            app: mongodb
        spec:
          containers:
          - name: mongodb
            image: mongo
            ports:
            - containerPort: 27017
            env:
            - name: MONGO_INITDB_ROOT_USERNAME
              value:
            - name: MONGO_INITDB_ROOT_PASSWORD
              value:
        </code></pre>
    </div>
</div>
    <ul>
    <li><code>ports</code> özelliği ve <code>containerPort</code> ile hangi portu açmak istediğimizi belirttik. Standart portu kullandık. Altında iki environment variables(<code>env</code>) belirttik.</li>
    <li>Birincisi <code>MONGO_INITDB_ROOT_USERNAME</code> ve boş bırakacağız.</li>
    <li>Diğeri ise <code>MONGO_INITDB_ROOT_PASSWORD</code> olacak ve bunu da boş bırakacağız.</li>
    </ul>
    <blockquote>
    <p> <strong>Şunu unutmamalıyız ki bu, bir repository içine kaydedilecek bir config dosyasıdır. Bu yüzden admin kullanıcı adı ve şifresini yapılandırma dosyasının içine yazmamalıyız.</strong></p>
    </blockquote>
    <h3 id="secret-ve-referans">b) Secret ve Referans</h3>
    <p>Şimdi yapacağımız şey, değerleri referans alacağımız bir <code>secret</code> oluşturmak olacak.</p>
    <p><img src="images/100.png" /></p>
    <p>Yani bu gizli dosya Kubernetes’te yer alacak ve kimse git reposunda buna erişemeyecek. <strong>Secret lives in K8s, not in the repository</strong></p>
    <p>Şimdilik az önce yazdığımız henüz bitmemiş olan deployment config dosyasını kaydedelim. Adını <code>mongo-depoyment.yml</code> olarak koyup kaydedelim.</p>
    <p>Şimdi bu yapılandırmayı apply etmeden önce, root kullanıcı adı ve şifresinin yer alacağı <code>Secret</code> oluşturacağız. Yeni bir dosya oluşturalım ve aşağıdaki <em>Secret</em> configi yapıştıralım.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: v1
    kind: Secret
    metadata:
      name: mongodb-secret
    type: Opaque
    data:
      username:
      password:
        </code></pre>
    </div>
</div>

    <p>Oldukça basit bir yapısı var. * <code>kind: Secret</code> var. * <code>metadata</code> var, ve bu sadece adını içeriyor. Buna <code>mongodb-secret</code> diyeceğiz. * <code>type: Opaque</code> aslında en temel <code>key-value</code> secret türüdür. Diğer türler örneğin TLS sertifikalarını içerir. Yani bir gizli dosya oluşturabiliriz ve bunu TLS sertifikası türünde yapabiliriz. Ancak çoğunlukla default türü (Opaque) kullanacağız. * <code>data</code> var ve burada <code>key-value</code> çiftleri bulunuyor. Elbette bunlar bizim belirlediğimiz isimler olacak. Mesela data kısmında değişiklik yapalım.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
data:
      mongo-root-username:
      mongo-root-password:
        </code></pre>
    </div>
</div>

    <ul>
    <li>Kullanıcı adını <code>root-username</code> ve şifreyi <code>root-password</code> olarak belirleyeceğiz.</li>
    </ul>
    <blockquote>
    <p> <strong>Buradaki önemli nokta, bu anahtar-değer çiftlerindeki değerlerin düz metin olmamasıdır. Bir gizli dosya oluştururken değerlerin base64 ile kodlanması gerekir.</strong></p>
    </blockquote>
    <p>Bunu yapmanın en basit yolu terminale gitmektir. Burada, <code>echo -n</code> komutunu kullanacağız.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
echo -n "username" | base64
echo -n "password" | base64
        </code></pre>
    </div>
</div>

    <p>Buraya istediğim düz metin değerini koyalım. <code>username</code> ve <code>password</code> kullanalım ve base64 ile kodlayalım. Elde ettiğimiz değerleri secret confige kopyalayalım.</p>
    <p><img src="images/101.png" /></p>
    <p>Tamamladıktan sonra dosyayı <code>mongo-secret.yaml</code> olarak kaydedelim.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">mongo-secret.yaml</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: v1
    kind: Secret
    metadata:
      name: mongodb-secret
    type: Opaque
    data:
      mongo-root-username: dXNlcm5hbWU=
      mongo-root-password: cGFzc3dvcmQ=
        </code></pre>
    </div>
</div>

    <p>Şimdiye kadar sadece config dosyaları yazdık, clusterda henüz bir şey oluşturmadık. Deploymenti referans alacağımız secret’tan önce oluşturmalıyız. Eğer secret içermeyen bir deployment oluşturursak, hata alırız ve deployment başlatılamaz.</p>
    <p>İlk componentimiz hazır olduğuna göre, şimdi config dosyasından bir secret oluşturabiliriz. Şu an her iki dosyamız da mevcut.</p>
    <p><img src="images/102.png" /></p>
    <p>Aşağıdaki komutu çalıştırıyoruz ve <code>secret</code> oluşturuluyor.</p>
    <div class="sourceCode" id="cb45"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a><span class="ex">kubectl</span> apply -f mongo-secret-yaml</span></code></pre></div>
    <p><img src="images/103.png" /></p>
    <p>Secretlarımızı listelemek için de aşağıdaki komutu çalıştırdığımızda, Yeni Secret’ımızın oluşturulduğunu görmeliyiz.</p>
    <div class="sourceCode" id="cb46"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a><span class="ex">kubectl</span> get secret</span></code></pre></div>
    <p><img src="images/104.png" /></p>
    <p>Artık Secret’ımızı deployment config dosyamızda referans alabiliriz. Config dosyamıza geri dönelim ve Secret’taki belirli <code>key-value</code> verilerini referans alalım.</p>
    <div class="window">
        <div class="window-header">
            <div class="buttons">
                <span class="button red"></span>
                <span class="button yellow"></span>
                <span class="button green"></span>
            </div>
            <span class="filename">~</span>
        </div>
        <div class="window-content">
            <pre><code class="language-shell">
    env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: mongo-root-username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: mongo-root-password
            </code></pre>
        </div>
    </div>

    <ul>
    <li><code>value</code> yerine <code>valueFrom</code> yazıyoruz ve altına <code>secretKeyRef</code> yazıyoruz.</li>
    <li><code>secretKeyRef</code> name’i, <code>Secret</code> dosyamızın adı olacak.</li>
    <li><code>key</code> değerini almak için de, Secret dosyamızdan isimleriyle referans alacağız. <code>mongo-root-username</code>, <code>mongo-root-password</code>.</li>
    </ul>
    <p><img src="images/105.png" /></p>
    <p>Bu şekilde referans almayı tamamlıyoruz.</p>
    <ul>
    <li>Unutmayın, YAML dosyası girintilere çok dikkat eder.</li>
    </ul>
    <p>Böylece root kullanıcı adı ve şifresi, Secret’tan referans alınacak ve config dosyasının içinde gerçek değerler bulunmayacak. Bu güvenlik açısından oldukça iyidir çünkü kimlik bilgilerimizin kod reposunda bulunmasını asla istemeyiz.</p>
    <p>Deployment dosyamız artık hazır, Artık apply edebiliriz.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectl apply -f [YAML_file]
        </code></pre>
    </div>
</div>



    <p><img src="images/106.png" /> <img src="images/107.png" /></p>
    <p>Deployment oluşturuldu, yani <code>get all</code> komutunu çalıştırırsam Pod’un başlatıldığını, deploymenti ve ReplicaSet’i görmeliyim.</p>
    <p>Şimdi Pod’un statusunu kontrol edelim. Konteyner oluşturuluyor, bu yüzden izlememiz gerekiyor. Eğer uzun sürerse ve bir sorun olup olmadığını görmek isterseniz, <code>kubectl describe pod</code> ve Pod adımızı yazıyoruz.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectl describe pod [POD_NAME]
        </code></pre>
    </div>
</div>

    <p><img src="images/108.png" /></p>
    <p>Görüyoruz ki sadece image çekiyor, bu yüzden uzun sürüyor.</p>
    <p>Tekrar <code>kubectl get pod</code> komutunu çalıştırırsak, Pod’un çalıştığını göreceğiz. Şu anda bir MongoDB deployment ve bir replika Pod çalışıyor.</p>
    <p><img src="images/109.png" /></p>
    <h3 id="mongodb-internal-service">c) MongoDB Internal Service</h3>
    <p><img src="images/110.png" /></p>
    <p>Şimdiki adımda, diğer componentlerin veya diğer Pod’ların bu MongoDB ile konuşabilmesi için bir <code>internal service</code> oluşturacağız. Önce servisconfiguration oluşturalım.</p>
    <p>YAML dosyamıza geri dönelim.</p>
    <blockquote>
    <p><strong>YAML’da tek dosyada, birden fazla yaml yazabiliriz. YAML’da 3 tire <code>---</code> belge ayırma sözdizimidir. Yani yeni bir belge başladığını belirtmiş oluyoruz.</strong></p>
    </blockquote>
    <p>Hatta deployment ve servisi aynı config dosyasına koyabiliriz çünkü genelde bu iki dosya birlikte bulunur.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">mongodb-service.yaml</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: mongodb-deployment
      labels:
        app: mongodb
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: mongodb
      template:
        metadata:
          labels:
            app: mongodb
        spec:
          containers:
          - name: mongodb
            image: mongo
            ports:
            - containerPort: 27017
            env:
            - name: MONGO_INITDB_ROOT_USERNAME
              valueFrom:
                secretKeyRef:
                  name: mongodb-secret
                  key: mongo-root-username
            - name: MONGO_INITDB_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mongodb-secret
                  key: mongo-root-password
    ---
    apiVersion: v1
    kind: Service
    metadata:
      name: mongodb-service
    spec:
      selector:
        app: mongodb
      ports:
        - protocol: TCP
          port: 27017
          targetPort: 27017
        </code></pre>
    </div>
</div>

    <p>Bu MongoDB için bir servis. Bazı nitelikleri gözden geçirelim.</p>
    <ul>
    <li><code>kind: Service</code> ve <code>name: mongodb-service</code> olarak adlandırdık.</li>
    <li><code>selector</code> önemli çünkü biz bu oluşturacağımız servisin Pod’a bağlanmasını istiyoruz ve bunu yapmanın yolu Servisten <code>selector</code>, Deployment’tan <code>label</code> kullanmaktır. Bu etiketleri kullanarak, deployment ve Pod’un sahip olduğu labelları, servis bulup bağlanabilir.</li>
    <li><code>ports:</code> Burada servisin bağlantı noktasını (port) açıyoruz.
    <ul>
    <li><code>port: 27017</code> Servis portudur.</li>
    <li><code>targetPort: 27017</code> Konteyner veya Pod portudur. Deployment config içerisindeki <code>containerPort</code> ile, Servisteki <code>targetPort</code> birbiriyle eşleşmelidir. Tabii ki, bu iki bağlantı noktası <em>farklı olabilir</em>, ama biz bu seferlik aynı portu kullanalım.</li>
    </ul></li>
    </ul>
    <p>Hadi şimdi servisi oluşturalım. Bu dosyayı kaydedelim ve aynı dosyayı tekrar uygulayalım. Böylece az önce deployment oluşturulduğu gibi şimdi de servis oluşacak. Bakalım ne olacak?</p>
    <p><img src="images/111.png" /></p>
    <p>Hem dağıtım hem de servis yapılandırması olmasına rağmen, Kubernetes deploymenti değiştirmediğimizi anlıyor. Bu nedenle sadece servisi oluşturuyor.</p>
    <p>Şimdi servisimizin oluşturulduğunu kontrol edelim.</p>
    <div class="sourceCode" id="cb51"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span class="ex">kubectl</span> get services</span></code></pre></div>
    <p><img src="images/112.png" /></p>
    <p>Oluşan servisimiz 27017 portunda dinliyor. Hatırlarsanız, servisin doğru Pod’a bağlı olup olmadığını da kontrol edebiliyorduk. Bunu yapmak için;</p>
    <div class="sourceCode" id="cb52"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a><span class="ex">kubectl</span> describe service [SERVICE_NAME]</span></code></pre></div>
    <p><img src="images/113.png" /></p>
    <p>Burada bir IP adresi ve Pod’un içinde dinleyen uygulama portu var. Bu doğru Pod olup olmadığını kontrol edelim. <code>-o wide</code> ile ek çıktıyla çalıştırıyorum.</p>
    <div class="sourceCode" id="cb53"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a><span class="ex">kubectl</span> get pod -o wide</span></code></pre></div>
    <p><img src="images/114.png" /></p>
    <p>Bu IP adresi, Pod IP adresi ile eşleşiyor ve uygulamanın Pod içinde dinlediği port doğru.</p>
    <p>Her şey mükemmel şekilde ayarlandı. MongoDB dağıtımı ve servisi oluşturuldu.</p>
    <blockquote>
    <p> Bir uygulamanın tüm componentlerini görmek istersek, <code>kubectl get all</code> ve <code>grep</code> komutunu birlikte kullanabiliriz. Böylece hem tüm componentleri listeleyip hem de isme göre filtreleyebiliriz.</p>
    </blockquote>
    <p><img src="images/115.png" /></p>
    <p>İşte bu şekilde tek komutla servisimizi, deploymentımızı, replicasetimizi ve Podumuzu görüntüleyebiliriz. Tüm component tipleri burada görünüyor.</p>
    <h3 id="mongo-express-deployment-service-configmap">d) Mongo Express Deployment &amp; Service &amp; ConfigMap</h3>
    <p><img src="images/116.png" /></p>
    <p>Şimdi sıradaki adımda, <code>Mongo Express Deployment ve Servisi</code> oluşturacağız. Ayrıca MongoDB için veritabanı URL’sini içeren <code>External Configuration</code> oluşturacağız. Yeni bir dosya oluşturarak başlayalım.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: mongo-express
      labels:
        app: mongo-express
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: mongo-express
      template:
        metadata:
          labels:
            app: mongo-express
        spec:
          containers:
          - name: mongo-express
            image: mongo-express
        </code></pre>
    </div>
</div>

    <p>Bu, MongoExpress deployment taslağı. İsim <code>express</code>. * <code>template:</code> Pod tanımımız var. Image adı <code>express</code>. Bu imajı da kontrol edelim. image adı <code>mongo-express</code>.</p>
    <p>*https://hub.docker.com/_/mongo-express*</p>
    <p><img src="images/117.png" /></p>
    <p>Konteyner içindeki MongoExpress Port 8081’deymiş. Biraz aşağı inersek de çevresel değişkenleri(environmental variables) görebiliriz.</p>
    <ul>
    <li>MongoExpress için üç şeye ihtiyacımız var: MongoDB adresi(veritabanı adresi) ve kimlik doğrulama bilgileri.
    <ul>
    <li>MongoDB Adresi -&gt; …MONGODB_SERVER</li>
    <li>Kimlik Doğrulama Bİlgileri -&gt; …ADMIN_USERNAME, …ADMIN_PASSWORD</li>
    </ul></li>
    </ul>
    <p><img src="images/118.png" /></p>
    <p>Bu çevresel değişkenleri kullanacağız. O zaman ilk olarak konteyner portlarını açabiliriz.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
...
    ...
      template:
        metadata:
          labels:
            app: mongo-express
        spec:
          containers:
          - name: mongo-express
            image: mongo-express
            ports:
            - containerPort: 8081
        </code></pre>
    </div>
</div>

    <ul>
    <li>İçerideki Pod’da birden fazla port açabileceğimiz için birden fazla port olabileceği anlamına gelen <code>ports</code> kullanılır. Bu değerimiz, 8081 olacak.</li>
    </ul>
    <p>Şimdi bağlantı için <code>ENV</code>(environment variables) ekleyeceğiz.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
...
    ...
            ports:
            - containerPort: 8081
            env:
            - name: ME_CONFIG_MONGODB_ADMINUSERNAME
              valueFrom:
                secretKeyRef:
                  name: mongodb-secret
                  key: mongo-root-username
            - name: ME_CONFIG_MONGODB_ADMINPASSWORD
              valueFrom:
                secretKeyRef:
                  name: mongodb-secret
                  key: mongo-root-username
        </code></pre>
    </div>
</div>

    <p>Tabiiki tanımladığımız aynı kullanıcı adı ve şifre, deploymentta tanımladığımız ile aynı olacak. Bu yüzden yaptığımız şey onları kopyalamak. Aynı <code>valueFrom</code> ile zaten orada olan secret içerisinden okumuş olacağız.</p>
    <p>Son olarak database server:</p>

<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
...
    ...
            - name: ME_CONFIG_MONGODB_ADMINPASSWORD
              valueFrom:
                secretKeyRef:
                  name: mongodb-secret
                  key: mongo-root-username
            - name: ME_CONFIG_MONGODB_SERVER
              value:
        </code></pre>
    </div>
</div>
    <p>Bu da harici bir yapılandırma olduğu için ya burada <code>value</code> kullanabilir ve mongodb sunucu adresini doğrudan buraya yazabiliriz. Ya da diyagramda gösterildiği gibi, merkezi bir yapılandırma olan bir configmap’e koyabiliriz. Bu şekilde merkezi bir yerde saklanır ve diğer componentler de kullanabilir. * Örneğin, iki uygulamam mongodb veritabanını kullanıyorsa, bu harici yapılandırmayı referans alabiliriz ve bir noktada değişiklik yapmamız gerekirse; sadece bir yerde değişiklik yaparak diğer dosyaları güncellemeden devam edebiliriz. Bu nedenle, şu an için eksik olan bu deployment configi kenara kaydedip, mongodb sunucu adresini içeren configmap’i oluşturacağız. Yeni bir dosya oluşturalım, bu eksik dağıtımı kaydedelim, adını <code>mongo-express.yaml</code> koyalım ve daha sonra geri dönelim!</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: v1
    kind: ConfigMap
    metadata:
      name: mongodb-configmap
    data:
      database_url:
        </code></pre>
    </div>
</div>

    <p>Bu da secret key gibi oldukça basit. Beraber göz atalım: * <code>kind: ConfigMap</code> olan aynı Secret gibi bir yapı görüyoruz.</p>
    <p><img src="images/119.png" /> * Tıpkı yukarıda gördüğünüz gibi <code>data</code> içerisinde <code>key-value</code> çifti var. * <code>type:</code> yok çünkü sadece configmapin sadece bir türü var. Sonuç olarak veritabanı URL’si ve server adı aslında Servisin adı. Bu kadar basit.</p>
    <p>Hizmetimize <code>mongodb-service</code> adını vermiştik. Bu yüzden hizmet adını kopyalayalım ve bunu veritabanı sunucusu URL’sine yazalım. Dosyayı mongo-configmap.yaml olarak kaydedelim.</p>
    <blockquote>
    <p> Gizli anahtar gibi, çalıştırma veya oluşturma sırası önemlidir. ConfigMap’in zaten clusterda olması gerekiyor ki onu referans alabilelim. Bu yüzden işimiz bittiğinde, önce configmap’i oluşturmalı daha sonra deploymenti yapmalıyız.</p>
    </blockquote>
    <p>Yapılandırma haritasını deployment içinde referans almaya geldik. mongo-express.yaml dosyamıza geri dönelim.</p>
    <blockquote>
    <p> Yapılandırma haritasını deployment içinde referans almanın yolu gizli anahtara çok benzer. Tek fark burada <code>secret</code> yerine <code>configMap</code> yazacağız. Tamamı küçük ve büyük harf karışık olacak ve elbette adı <code>config map</code> olacak.</p>
    <p><img src="images/120.png" /></p>
    </blockquote>
    <p>Deploymenti tamamladık. Şimdi önce config map’i ve sonra Express dağıtımını oluşturalım.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectl apply -f mongo-configmap.yaml
kubectl apply -f mongo-express.yaml
        </code></pre>
    </div>
</div>

    <br>
    <p><img src="images/121.png" /></p>
    <p>Herhangi bir hata almadık. Pod’un durumuna bakalım.</p>
    <div class="sourceCode" id="cb60"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a><span class="ex">kubectl</span> get pod</span></code></pre></div>
    <p><img src="images/122.png" /></p>
    <p>Konteyner oluşturuluyor. Gayet iyi. Biraz bekleyip tekrar kontrol edelim ve bum!</p>
    <p><img src="images/123.png" /></p>
    <p>Doğru çalışıp çalışmadığını öğrenmek için Logları görüntülemek önemlidir.</p>
    <div class="sourceCode" id="cb61"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a><span class="ex">kubectl</span> logs [POD_NAME]</span></code></pre></div>
    <p><img src="images/124.png" /></p>
    <h3 id="mongo-express-external-service">e) Mongo Express External Service</h3>
    <p><img src="images/131.png" /></p>
    <p>Şimdi son adımımız, Express’e bir tarayıcıdan erişmektir. Bunu yapmak için mongo-express için bir External Service ihtiyacımız olacak. Öyleyse hadi bunu da oluşturalım.</p>
    <blockquote>
    <p> Daha önce yaptığımız gibi yine MongoExpress servisimizi, deploymentı ile aynı dosyada oluşturacağız. Çünkü zaten pratikte hiçbir zaman servis olmadan deploymentı olmaz. Bu yüzden onları aynı yaml dosyasında yazmak mantıklıdır.</p>
    </blockquote>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
---
    apiVersion: v1
    kind: Service
    metadata:
      name: mongo-express-service
    spec:
      selector:
        app: mongo-express
      ports:
        - protocol: TCP
          port: 8081
          targetPort: 8081
        </code></pre>
    </div>
</div>

    <p>Deployment dosyamızın devamına yukarıdaki servis configi yapıştırıyoruz. Bu, Mongo Express’in external servisi ve bu farkettiyseniz tamamen mongodb servisinin yapılandırmasıyla aynı görünüyor.</p>
    <p><img src="images/125.png" /></p>
    <ul>
    <li>Servis portunu 8081 olarak açtık ve yine target Port, container Port’un dinlediği yerdir.</li>
    </ul>
    <p><strong>Peki bu servisi external(harici) yapacak olan şey nedir?</strong> Bu servisi iki şey yaparak external yaparız:</p>
    <ol type="1">
    <li><code>spec</code> bölümünde, <code>selector</code> altına <code>type: Loadbalancer</code> yazarız.</li>
    </ol>
    <blockquote>
    <p> Sanıyoruz ki <code>external servis</code> için bu isim “LoadBalancer” olarak düzgün seçilmemiş çünkü <code>internal servis</code> de istekleri dengeleyip Load Balance yapabilir. İki mongodb podumuz olsa, internal servis de bu podlara gelen istekleri dengeleyebilirdi. Yani gerçekten de tür adı olarak <code>Load Balancer</code> seçilmesi çok iyi değil gibi çünkü kafa karışıklığına neden olabilir. Ancak, bu yük dengeleyici türü basitçe servise <code>external IP adres</code>i atar ve <code>external request</code>leri kabul eder.</p>
    </blockquote>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: v1
    kind: Service
    metadata:
      name: mongo-express-service
    spec:
      selector:
        app: mongo-express
      type: LoadBalancer         ## Tam burası..
      ports:
        - protocol: TCP
          port: 8081
          targetPort: 8081
        </code></pre>
    </div>
</div>

    <ol start="2" type="1">
    <li><code>nodePort: 30000</code></li>
    </ol>
    <p>Yapacağımız ikinci şey ise, bu servisi harici yapmak için üçüncü bir port sağlamak. Bu da node port olacak ve bu, External IP adresinin açık olacağı port olacak. Ayrıca belirtelim ki bu port, Tarayıcıdan erişmek için kullanacağımız port olacak.</p>
    <p>Bu port aslında bir aralığa sahiptir ve bu aralık 30000 ile 32767 arasındadır, yani bu aralıkta bir port vermemiz gerekiyor, bu yüzden sadece 30000 ile gidelim, aralıktaki minimumdur.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: v1
    kind: Service
    metadata:
      name: mongo-express-service
    spec:
      selector:
        app: mongo-express
      type: LoadBalancer
      ports:
        - protocol: TCP
          port: 8081
          targetPort: 8081
          nodePort: 30000
        </code></pre>
    </div>
</div>

    <p>Artık hazır olduğumuza göre uygulamaya geçebiliriz. Ardından bu bağlantı noktalarının nasıl farklı olduklarına bakalım.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectl apply -f mongo-express.yaml
        </code></pre>
    </div>
</div>

    <p>Hizmet oluşturuldu ve hizmeti <code>kubectl get service</code> ile görüntülersek, önceden oluşturduğumuz mongodb servisinin <code>ClusterIP</code>’ tipinde olduğunu görüyoruz ve yeni oluşturduğumuz mongo express servisinin bir <code>LoadBalancer</code> olduğunu görüyoruz.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
c3ng0@ubn:~/hxhdle/kubernetto$ kubectl get service
    NAME                    TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
    kubernetes              ClusterIP      10.96.0.1        <none>        443/TCP          6d1h
    mongo-express-service   LoadBalancer   10.96.100.133    <pending>     8081:30000/TCP   9s
    mongodb-service         ClusterIP      10.111.249.213   <none>        27017/TCP        95m
        </code></pre>
    </div>
</div>

    <p>Internal servis oluştururken herhangi bir tür belirtmedik çünkü zaten default olarak internal IP hizmeti türüdür.</p>
    <blockquote>
    <p> İnternal Servis oluştururken <code>type</code> belirtmeye gerek yok çünkü zaten default olarak tanımlanır.<br> <img src="images/126.png" /></p>
    </blockquote>
    <p>Fark ise; * ClusterIP, servise internal IP adresi verir. Aşağıda görüldüğü gibi:</p>
    <div class="sourceCode" id="cb67"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true"></a><span class="ex">mongodb-service</span>         ClusterIP      10.111.249.213   <span class="op">&lt;</span>none<span class="op">&gt;</span>        27017/TCP        95m</span></code></pre></div>
    <ul>
    <li>LoadBalancer, servise bir internal IP adresi verir, ancak bununla birlikte external isteklerin geleceği external IP adresi de verir. <em>(pending)</em></li>
    </ul>
    <div class="sourceCode" id="cb68"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true"></a><span class="ex">mongo-express-service</span>   LoadBalancer   10.96.100.133    <span class="op">&lt;</span>pending<span class="op">&gt;</span>     8081:30000/TCP   9s</span></code></pre></div>
    <ul>
    <li>Şu an bize <code>pending</code> diyor çünkü minicube’deyiz ve bu normal kubernetes kurulumunda biraz daha farklı çalışır.</li>
    </ul>
    <p>Dediğim gibi, “pending” durumu external IP adresini henüz almadığı anlamına gelir. Bu durumu Minikube’da yapmanın yolu <code>minikube service</code> komutunu kullanmaktır ve servisin adına ihtiyacımız olacak.</p>
    <div class="sourceCode" id="cb69"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true"></a><span class="ex">minikube</span> service mongo-express-service</span></code></pre></div>
    <p>Bu komut temelde external servisimize bir genel IP adresi atayacak. Komutu çalıştırdığımızda tarayıcı açılacak ve karşımıza şu sayfa çıkacak:</p>
    <p><img src="images/127.png" /></p>
    <p>Eğer açılırken kullanıcı adı ve şifre sorarsa <code>admin:pass</code> olarak yazabiliriz.</p>
    <p>Ve Mongo Express sayfamızı görüyoruz. Komut satırına geri dönersek, buradaki bu komut Express servisini Public IP adresli URL atadığını ve bizim belirttiğimiz 30000 portunu kullandığını görüyoruz.</p>
    <p><img src="images/128.png" /></p>
    <p>Burada değişiklikler yaparsak, örneğin yeni bir veritabanı oluşturalım, ona testDB adını verelim ve Create Database ile isteği gönderelim.</p>
    <p><img src="images/129.png" /></p>
    <p>Arka planda olan şeyi şu şekilde açıklayabiliriz. * Bu isteğin Mongo Express’in external servisine ulaşması * Ardından Mongo Express poduna yönlendirilmesidir. * Express podu, Internal servis olan mongodb servisine bağlanır. * Mongodb servisi, isteğimizi sonunda mongodb Poduna iletir. * Sonra tüm bu yol geri gelir ve burada değişiklikleri görürüz.</p>
    <p><img src="images/130.png" /></p>
    <p>Basit bir uygulama kurulumunu bir Kubernetes kümesinde nasıl dağıtacağınızı böyle anlatmış olduk. Bu yaptığımız demo uygulamanın dosyalarını <code>ilkuygulamademo</code> dizinine koydum.</p>
    <hr />
    <h2 id="kubernetes-namespaces">Kubernetes Namespaces</h2>
    <p>Bu konu başlığında , <code>Namespaces</code> kullanımlarından bahsedeceğiz.</p>
    <p><img src="images/132.png" /></p>
    <h3 id="namespace-nedir">Namespace Nedir</h3>
    <p>Öncelikle, Kubernetes’te <code>Namespace</code> nedir? Kubernetes clusterında, kaynakları namespaces ile organize edebiliriz. Yani, bir clusterda birden fazla namespace olabilir. Bir namespace’i, Kubernetes kümesi içinde sanal bir cluster olarak düşünebiliriz.</p>
    <p><img src="images/133.png" /></p>
    <h3 id="default-namespaces">Default Namespaces</h3>
    <p>Bir cluster oluşturduğumuzda, Kubernetes bize varsayılan olarak bazı namespace’ler sağlar. Komut satırında <code>kubectl get namespaces</code> yazarsak, Kubernetes’in varsayılan olarak sunduğu namespace listesini görürüz.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl get namespace
    NAME              STATUS   AGE
    default           Active   6d3h
    kube-node-lease   Active   6d3h
    kube-public       Active   6d3h
    kube-system       Active   6d3h
        </code></pre>
    </div>
</div>

    <p>Şimdi, bunları tek tek inceleyelim. * 1) <code>kube-system</code> <code>kube-system</code> namespace, bizim kullanımımıza yönelik değildir. Yani, bu namespace’te herhangi bir şey oluşturmamalı veya değiştirmemeliyiz. Bu namespace’te yer alan componentler, sistem süreçleri, yönetici süreçler veya <code>kubectl</code> gibi bileşenlerdir.</p>
    <ul>
    <li><ol start="2" type="1">
    <li><code>kube-public</code> Genel olarak erişilebilir veriler bulunur. Bu namespace’te, cluster bilgilerini içeren ve kimlik doğrulama olmadan bile erişilebilen bir ConfigMap bulunur. <code>kubectl cluster-info</code> yazarsak, bu ConfigMap bilgilerinin çıktısını alırız.</li>
    </ol></li>
    </ul>
    <p><img src="images/134.png" /></p>
    <ul>
    <li><ol start="3" type="1">
    <li><code>kube-node-lease</code> Bu namespace’in amacı, nodeların kalp atış bilgilerini tutmaktır. Her node, kendisinin kullanılabilirlik bilgilerini içeren kendi objesini alır.</li>
    </ol></li>
    <li><ol start="4" type="1">
    <li><code>default</code> default namespace, başlangıçta yeni bir namespace oluşturmadıysak, kaynakları oluşturmak için kullanacağımız alandır.</li>
    </ol></li>
    </ul>
    <p><img src="images/135.png" /></p>
    <p>Tabii ki, yeni namespace ekleyip oluşturabiliriz. Bunu yapmak için, <code>kubectl create namespace</code> komutunu, namespace adıyla birlikte kullanabiliriz. Böylece, kendi namespace’imizi oluşturabilir ve <code>kubectl get namespaces</code> yazarsak, namespace’imiz listede görünecektir.</p>
    <div class="sourceCode" id="cb71"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true"></a><span class="ex">kubectl</span> create namespace my-namespace</span></code></pre></div>
    <p>Namespace oluşturmanın bir diğer yolu, namespace config file kullanmaktır. Bu, namespace oluşturmanın daha kaliteli bir yoludur. Çünkü bu şekilde config file reposunda, clusterda hangi kaynakları oluşturduğumuzun geçmişi de olur.</p>
    <p><img src="images/136.png" /></p>
    <h3 id="ne-zaman-nasıl-namespace-oluşturmalı">Ne Zaman &amp; Nasıl Namespace Oluşturmalı</h3>
    <p>Şimdi, namespaces’in ne olduğunu, yeni namespaces oluşturabileceğimizi ve Kubernetes’in default olarak bazı namespace’ler sunduğunu gördük. Ancak, asıl soru şu: namespace’e neden ihtiyaç var? Ne zaman ve nasıl namespaces oluşturmalıyız?</p>
    <p>Bazı use case durumlarından bahsedelim:</p>
    <ol type="1">
    <li><strong>Kaynaklar Namespaces’ta Gruplanırsa</strong>: Varsayalım ki, Kubernetes tarafından sağlanan tek bir default namespace’a sahibiz ve tüm kaynaklarımızı bu default namespaces’da oluşturuyoruz. Eğer karmaşık bir uygulamamız varsa ve bu uygulama birçok deployment içeriyorsa, bu deploymentlar birçok kopya oluşturuyorsa ve servisler, ConfigMap gibi kaynaklarımız varsa, çok kısa sürede varsayılan namespace’imiz farklı componentlerle dolup taşacaktır. Bu durumda, neyin ne olduğunu gözlemlemek de zor olacaktır, özellikle de birden fazla kullanıcı içerik oluşturuyorsa..</li>
    </ol>
    <p><img src="images/137.png" /></p>
    <p>Böyle bir durumda namespaces’i kullanmanın daha iyi bir yolu, kaynakları namespaces’ta gruplandırmaktır. Örneğin, veritabanımızı ve gerekli tüm kaynaklarını dağıtacağımız bir veritabanı namespace oluşturabiliriz. Monitoring araçlarımızı dağıtacağımız bir monitoring namespace oluşturabiliriz. Elasticsearch ve Kibana gibi kaynakları dağıtacağımız bir Elastic Stack namespace oluşturabiliriz. Bu şekilde kaynaklarımızı cluster içinde mantıksal olarak gruplandırabiliriz.</p>
    <p><img src="images/138.png" /></p>
    <p>Kubernetes’in resmi dokümantasyonuna göre, eğer küçük projelerimiz ve 10’a kadar kullanıcımız varsa, namespaces kullanmamalıyız. Ancak Nina’nın kişisel görüşüne göre, kaynaklarımızı namespaces’ta gruplandırmak her zaman iyi bir fikirdir. Çünkü küçük bir projeye ve 10 kullanıcıya sahip olsak bile, uygulamamız için monitoring ve logging gibi ek kaynaklara ihtiyaç duyabiliriz.</p>
    <ol start="2" type="1">
    <li><strong>Conflicts: Birden Fazla Takım, Aynı Proje:</strong> Namespaces kullanmamız gereken bir diğer use case, birden fazla takımımız olduğunda ortaya çıkar. Bu senaryoda, aynı cluster’ı kullanan iki takımımız olduğunu varsayalım. Bir takım, <code>my-app-deployment</code> adlı bir deployment oluşturur ve bu deployment belirli bir konfigürasyona sahiptir. Eğer diğer takım, aynı ada sahip ancak farklı bir konfigürasyona sahip bir deployment oluşturursa ve bunu uygularsa(apply), ilk takımın deployment’ını geçersiz kılabilir. Jenkins veya otomatik bir deployment aracı kullanıyorlarsa, diğer takımın deployment’ını bozduklarının farkına bile varmazlar.</li>
    </ol>
    <p><img src="images/139.png" /></p>
    <p>Bu tür çakışmaları önlemek için namespaces kullanabiliriz. Her takım, kendi namespace’inde çalışarak diğerini rahatsız etmeden rahatça çalışabilir.</p>
    <p><img src="images/140.png" /></p>
    <ol start="3" type="1">
    <li><strong>Kaynak Paylaşımı: Staging ve Development:</strong> Namespaces kullanmanın bir diğer use case’i, aynı clusterda hem staging hem de development ortamlarını barındırmak istediğimizde ortaya çıkar. Bu durumda, örneğin nginx controller veya Elasticsearch gibi kaynakları her iki ortamda da kullanabiliriz. Bu şekilde, bu ortak kaynakları iki farklı clusterda da kurmak zorunda kalmayız. Hem staging hem de development ortamı bu kaynakları kullanabilir.</li>
    </ol>
    <p><img src="images/141.png" /></p>
    <ol start="3" type="1">
    <li><strong>Kaynak Paylaşımı: Blue/Green Deployment:</strong> Namespacesnı kullanmanın bir diğer durumu, Blue/Green deployment stratejisini kullandığımızda ortaya çıkar. Bu durumda, aynı clusterda iki farklı production sürümüne sahip olmak isteriz . Biri aktif olan ve şu anda production olan sürüm, diğeri ise bir sonraki production sürümü olacaktır. Bu durumda, her iki üretim namespace da ortak kaynakları kullanabilir, örneğin nginx controller veya Elasticsearch gibi.</li>
    </ol>
    <p><img src="images/142.png" /></p>
    <ol start="4" type="1">
    <li><strong>Namespaces’e Erişimi ve Kaynakları Sınırlama:</strong> namespacesnı kullanmanın bir diğer durumu, kaynakları ve erişimi sınırlamaktır. Birden fazla takımın aynı clusterda çalıştığı senaryoda, her takımın kendi namespace’nde çalışmasını sağlayabilir ve diğer namespaces’te hiçbir şey yapmalarına izin vermeyiz. Bu şekilde, bir takımın diğerinin işine müdahale etme riskini azaltırız. Ayrıca, namespace düzeyinde kaynak kotaları tanımlayarak her takımın ne kadar CPU, RAM ve depolama kullanabileceğini de sınırlayabiliriz. Bu, bir takımın çok fazla kaynak tüketmesini ve diğer takımların kaynaklarının tükenmesini önler.</li>
    </ol>
    <p><img src="images/143.png" /></p>
    <p>Bu senaryoları inceledikten sonra, projenizde namespacesnı nasıl kullanmamız gerektiğini daha iyi analiz edebileceğimizi umuyoruz.</p>
    <h3 id="namespaces-özellikleri">NameSpaces Özellikleri</h3>
    <p>Namespaces’imizi nasıl gruplandıracağımıza ve kullanacağımıza karar vermeden önce dikkate almamız gereken birkaç özellik var.</p>
    <ul>
    <li>İlk olarak, çoğu kaynağa başka bir namespacendan erişemeyiz. Örneğin, bir namespace’teki bir ConfigMap, başka bir namespace’teki bir Servisi referans alıyorsa, bu ConfigMap’i başka bir namespace’de kullanamayız. Aynı referans ve aynı ConfigMap olsa bile: <strong>her namespace için, kendi ConfigMap’ini tanımlamamız gerekecektir</strong>. Aşağıdaki resimde bunun örneği vardır. Project A içerisindeki ConfigMap, Database servisine referans edilmiştir. Bu sebeple bu ConfigMap, Project B için kullanılamaz. Aynı ConfigMap projectB içerisinde de oluşturulmalıdır ve referans edilmelidir.</li>
    </ul>
    <p><img src="images/144.png" /></p>
    <p>Bu, Secret’lar için de geçerlidir. Örneğin, ortak bir servisin kimlik bilgilerine sahipseniz, bu kimlik bilgilerini her namespace’de oluşturmamız gerekecektir. Ancak, namespace’ler arasında paylaşabileceğimiz bir kaynak türü <code>Servis</code>lerdir.</p>
    <p>Bir configMap, bir namespace’deki servisi referans aldığında, URL’sinde namespace adı da eklenir. Bu şekilde, diğer namespace’lerdeki servislere erişebiliriz. Bu, Elasticsearch veya nginx gibi paylaşılan kaynakları kullanmanın pratik bir yoludur.</p>
    <p><img src="images/145.png" /></p>
    <p>Kubernetes’teki bazı componentler namespace olmadan clusterda global olarak bulunur. Bu componentler, namespace’a ait olmayan componenetler olarak adlandırılır. Örneğin, Volume’ler veya node’lar cluster genelinde erişilebilir.</p>
    <p>Namespace’siz componentleri listelemek için:</p>
    <div class="sourceCode" id="cb72"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true"></a><span class="ex">kubectl</span> api-resources --namespaced=false</span></code></pre></div>
    <p>Namespaced componentleri listelemek için:</p>
    <div class="sourceCode" id="cb73"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a><span class="ex">kubectl</span> api-resources --namespaced=true</span></code></pre></div>
    <p>Şimdi, namespacesnın ne olduğunu, ne zaman ve nasıl kullanmamız gerektiğini öğrendik. Ayrıca, bazı özellikleri dikkate almamız gerektiğini de öğrendik.</p>
    <h3 id="namespaces-component-oluşturma">Namespaces Component Oluşturma</h3>
    <p>Şimdi, namespace’te component oluşturmayı görelim. Bir önceki örnekte, config dosyalarını kullanarak componentler oluşturduk ve namespace belirtmedik. Bu durumda, componentler varsayılan olarak default namespace’te oluşturuldu.</p>

<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: v1
    kind: ConfigMap
    metadata:
      name: mysql-configmap
    data:
      db_url: mysql-service.database
        </code></pre>
    </div>
</div>



    <p>Bu configMap componentini apply edelim: <code>kubectl apply -f config-map</code> komutunu uygularsak ve <code>kubectl get config-map</code> komutunu çalıştırırsak, config map default namespace’te oluşturulmuş olur.</p>
    <blockquote>
    <p> Dikkat edin ki <code>kubectl get config-map</code> komutunda bile bir ad alanı kullanmadık çünkü <code>kubectl get</code> veya <code>kubectl</code> komutları varsayılan ad alanını <code>default</code> olarak alır. Yani <code>kubectl get config-map</code> komutu aslında <code>kubectl get config-map -n default</code> ile aynıdır, bu nedenle bu komutlar aynıdır.</p>
    </blockquote>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl apply -f mysql-configmap.yaml
    configmap/mysql-configmap created

    c3ng0@ubn:~$ kubectl get configmap
    NAME                DATA   AGE
    kube-root-ca.crt    1      6d4h
    mongodb-configmap   1      5h1m
    mysql-configmap     1      6s

    c3ng0@ubn:~$ kubectl get configmap -n default
    NAME                DATA   AGE
    kube-root-ca.crt    1      6d4h
    mongodb-configmap   1      5h1m
    mysql-configmap     1      18s
        </code></pre>
    </div>
</div>

    <p>Bu, varsayılan olarak varsayılan ad alanını aldığı için bir kısayoldur.</p>
    <ul>
    <li>Bu config map’i belirli bir namespace ile oluşturmanın bir yolu, <code>kubectl apply</code> komutunu kullanmak ve <code>--namespace</code> bayrağını eklemek. Ardından namespace adını eklemektir. Bu, config map’i belirli bir namespace ile oluşturacaktır ve bu sadece bir yoludur.</li>
    </ul>
    <div class="sourceCode" id="cb76"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true"></a><span class="ex">kubectl</span> apply -f mysql-configmap.yaml --namespace=my-namespace</span></code></pre></div>
    <ul>
    <li>Başka bir yol, config dosyasının kendisinde yapmaktır. Bu configmap yapılandırma dosyasını ayarlayarak, hedef namespace bilgilerini ekleyebiliriz. Yani, metadata içinde <code>namespace</code> özelliğini ekleyebiliriz.</li>
    </ul>
    <p><img src="images/146.png" /></p>
    <ul>
    <li>Bu config dosyasını tekrar <code>kubectl apply</code> komutuyla uygularsak ve bu namespace alanında oluşturduğumuz bileşeni almak istersek, <code>kubectl get</code> komutuna bayrağı eklememiz gerekir çünkü varsayılan olarak çalıştırırsak, sadece default namespace’leri kontrol eder. Nina, <code>namespace</code> özniteliğini yapılandırma dosyasında kullanmamızı tavsiye ediyor. Çünkü</li>
    </ul>
    <ol type="1">
    <li>Daha iyi belgelenmektedir. Sadece yapılandırma dosyasına bakarak componentin nerede oluşturulduğunu bilebiliriz ve bu önemli bir bilgi olabilir.</li>
    <li>Otomatik dağıtım kullanıyorsak ve sadece config dosyalarını uyguluyorsak, bu daha uygun bir yol olacaktır.</li>
    </ol>
    <p>Örneğin, bir ekibin kendi namespace’ine sahip olduğu ve tamamen bu namespace ile çalışması gerektiği bir senaryo düşünürsek, her <code>kubectl</code> komutuna bu namespace etiketini eklemek oldukça sinir bozucu olabilir. Bu yüzden, default veya aktif namespace’in; varsayılan namespace’ten seçtiğimizi herhangi bir namespace’e değiştirmek için bir yol var. Aracımızın adı <code>Kubens</code>. Bu aracı yüklememiz gerekiyor.</p>
    <p>Ubuntu’da indirmek için:</p>
    <p><code>kubectx</code> ve <code>kubens</code> depolarını klonlayalım:</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
git clone https://github.com/ahmetb/kubectx.git ~/.kubectx
sudo ln -s ~/.kubectx/kubectx /usr/local/bin/kubectx
sudo ln -s ~/.kubectx/kubens /usr/local/bin/kubens
        </code></pre>
    </div>
</div>

    <p>İndirilen dosyaların çalıştırılabilir olduğundan emin olalım:</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
chmod +x ~/.kubectx/kubectx
chmod +x ~/.kubectx/kubens
        </code></pre>
    </div>
</div>

    <p><code>kubectx</code> ve <code>kubens</code>’i kontrol edelim:</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectx
kubens
        </code></pre>
    </div>
</div>

    <p><code>kubens</code> yüklendikten sonra, sadece <code>kubens</code> komutunu çalıştırabiliriz. Bu bize tüm namespace’lerin bir listesini verir ve şu anda aktif olanı (varsayılan olanı) vurgular.</p>
    <p><img src="images/147.png" /></p>
    <p>Aktif namespace’i değiştirmek istersek:</p>
    <pre><code>kubens &lt;Namespace_ismi&gt;</code></pre>
    <p>komutunu çalıştırabiliriz. Aktif ad alanını değiştirecektir. <code>kubens</code> komutunu tekrar çalıştırırsak, aktif olanın yeni namespace’iniz olduğunu görürüz. Bu şekilde, <code>kubectl</code> komutlarını namespace sağlamadan çalıştırabiliriz. Ancak, namespace’ler arasında çok sık geçiş yapıyorsak, bu bizim için pek uygun olmayacaktır.</p>
    <hr />
    <h2 id="kubernetes-ingress-explained">Kubernetes Ingress Explained</h2>
    <p><img src="images/148.png" /></p>
    <p>Bu konuda Ingress’in ne olduğundan, nasıl kullanılacağından ve farklı kullanım senaryolarından bahsedeceğiz.</p>
    <h3 id="external-service-vs-ingress">External Service vs Ingress</h3>
    <p>Öncelikle, basit bir Kubernetes cluster’ı hayal edelim. Bu cluster’ımızda, uygulamamızın bir Pod’u ve buna karşılık gelen bir Servisi (hizmeti) olan <code>my-app-service</code> var. Bir UI uygulaması için ilk gereksinim, uygulamanın tarayıcı üzerinden erişilebilir olmasıdır. Bu, dışarıdan gelen isteklerin uygulamaya ulaşabilmesi anlamına gelir. Bunun için kolay bir yol, uygulamaya HTTP protokolü kullanarak, node’un IP adresi ve portu aracılığıyla erişmek olan bir external service (dış hizmet) kullanmaktır.</p>
    <p><img src="images/149.png" /></p>
    <p>Ancak, bu yöntem test durumları ve hızlı bir şeyler denemek için uygundur, nihai ürün böyle olmamalıdır. Nihai ürün şu şekilde olmalıdır: Uygulamamızın bir alan adı (domain name) ve güvenli bir HTTPS bağlantısı olmalıdır. Bunu yapmanın yolu, Kubernetes componenti olan Ingress’i kullanmaktır. Bu durumda, <code>my-app-ingress</code> adında bir Ingress’e ve external service(dış hizmet) yerine bir internal service’e(iç hizmete) sahip oluruz. Yani uygulamamıza IP adresi ve port üzerinden değil, Ingress aracılığıyla erişiriz. Tarayıcıdan gelen istek önce Ingress’e ulaşır, ardından Ingress bu isteği iç hizmete yönlendirir ve en sonunda Pod’a ulaşır.</p>
    <p><img src="images/150.png" /></p>
    <h4 id="external-service-yaml-config">External Service YAML Config</h4>
    <p>Şimdi, external service yapılandırmasının nasıl göründüğüne bir göz atalım.</p>
    <p><img src="images/151.png" /></p>
    <p>Servisin <code>loadBalancer</code> türünde olduğunu görürüz. Bu, servise bir <code>external IP</code> adresi atayarak public’e açtığımız anlamına gelir. Kullanıcı bu IP adresi ve belirlenen port numarasını kullanarak uygulamaya erişebilir.</p>
    <h4 id="ingress-yaml-config">Ingress YAML Config</h4>
    <p>Ingress ile bu konfigürasyon farklıdır. Ingress’in syntax’ına bakalım.</p>
    <p><img src="images/152.png" /></p>
    <ul>
    <li><code>kind: Ingress</code> ile Ingress olduğunu belirtiriz.</li>
    <li><code>spec</code> tüm yapılandırmanın olduğu yerdir.
    <ul>
    <li><code>rules</code> veya routing rules aracılığıyla yapılır. Bu tanımlanan rules, belirli bir hosta yapılan tüm isteklerin internal servise yönlendirilmesini tanımlar. <em>(Yukarıda net bir şekilde gösterilmiştir.)</em> Kullanıcı tarayıcıda bu hostun adresini girer ve Ingress, bu istekleri internal servise yönlendirir.</li>
    <li><code>paths</code> ise alan adından sonraki URL yolunu ifade eder. Domain name’den sonra gelen herşeyi paths içerisinde tanımlarız. <img src="images/153.png" /></li>
    </ul></li>
    </ul>
    <p>Şu anda yapılandırmada HTTPS bağlantısı için herhangi bir şey ayarlanmamıştır, sadece HTTP protokolü kullanılıyor. Ingress componentini kullanarak HTTPS yapılandırmasının nasıl yapılacağını az sonra göreceğiz.</p>
    <blockquote>
    <p> Config içerisindeki <code>http</code>, URL adresindeki HTTP veya HTTPS’i ifade etmiyor. Bu, gelen isteğin internal servise yönlendirildiği protokoldür. 1. Adım: tarayıcıdan Ingress’e istek gönderilmesilidir Config içerisindeki <code>http</code> ise ikinci adımdır. Gelen isteğin internal servise yönlendirildiği protokoldür. Bunu birinci adımla karıştırmamak gerekir. <img src="images/154.png" /></p>
    </blockquote>
    <h3 id="ingress-konfigürasyonu">Ingress Konfigürasyonu</h3>
    <p>Ve şimdi, internal servisin bu Ingress’e nasıl görüneceğine bakalım. Temelde, backend, gelen isteğin yönlendirileceği hedeftir ve servisin adı, internal servisin adını karşılamalıdır.</p>
    <p><img src="images/155.png" /></p>
    <p>Ayrıca port, internal servis portu olmalıdır.</p>
    <p><img src="images/156.png" /></p>
    <p>Burada gördüğünüz gibi, external ve internal servisler arasındaki tek fark, internal serviste node portunun olmamasıdır. Node portu 30000’den başlayan üçüncü port burada yoktur. Ayrıca tipi de bir load balancer değil, cluster IP olan default internal servis tipidir.</p>

<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
..
    ..
    spec:
      rules:
      - host: myapp.com
    ..
        </code></pre>
    </div>
</div>


    <p>Bu, geçerli bir domain adresi olmalıdır. Buraya rastgele bir şey yazamayız. Ayrıca bu domain namei, Kubernetes clusterımızın entry point’i olan node’un IP adresine eşlemeliyiz. Örneğin, Kubernetes clusterımızda bir node’u entry point olarak belirlersek, bu domain adını o node’un IP adresine eşlemelisiniz. Veya Kubernetes cluster’ımızın dışında bir sunucu yapılandırırsak, bu sunucunun IP adresine eşlemeliyiz.</p>
    <p><img src="images/157.png" /></p>
    <p>Şimdi, Kubernetes Ingress componentini gördüğümüze göre, Ingress’i clustera nasıl konfigüre edeceğimize bakalım. Başlangıçta gördüğümüz diyagramı hatırlayalım.</p>
    <p><img src="images/158.png" /></p>
    <p>Temelde bir pod, servis ve buna karşılık gelen Ingress var. Ancak, yalnızca Ingress componentini oluşturmak yeterli değildir. Ingress routing rules’un çalışması için ek olarak bir Ingress controller’a ihtiyacımız var.</p>
    <p><img src="images/159.png" /></p>
    <p>İlk adım, Ingress controllers kurmak olacaktır. Bu, Kubernetes clusterımızdaki nodelarımızda çalışan başka bir pod veya pod setidir ve Ingress rules’un değerlendirilmesi ve işlenmesini sağlar. Az önce gördüğümüz Ingress componentinin YAML dosyası, temelde sadece ingress bölümüdür.</p>
    <p><img src="images/160.png" /></p>
    <h3 id="ingress-controller">Ingress Controller</h3>
    <p>Ingress denetleyicisi tam olarak nedir? Ingress controller’ın işlevi, clusterda tanımladığımız tüm kuralları(rules) değerlendirmek ve bu şekilde tüm yönlendirmeleri yönetmektir.</p>
    <p>Ingress Controller, yapılandırdığımız domain name veya subdomain name kuralları için clusterda <code>entry point</code> olacaktır ve tüm kuralları değerlendirecektir. Clustera 50 kural veya 50 Ingress componenti oluşturmuş olabiliriz; yine de tüm kuralları değerlendirilecektir ve hangi routing rule’un belirli bir istek için geçerli olduğunu belirleyecektir.</p>
    <p>Bu Ingress uygulamasını clusterımıza kurmak için birçok third party uygulamasından hangisini seçeceğimize karar vermemiz gerekir.</p>
    <p><a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">Kubernetes Docs - Ingress Controller</a></p>
    <p>burada seçebileceğiniz farklı Ingress denetleyicilerini görebilirsiniz. Kubernetes’in kendi controllerı olan <code>Kubernetes Nginx Ingress Controller</code> da var, ancak başka seçenekler de mevcut.</p>
    <p>Clusterımıza Ingress controller kurduktan sonra, Ingress rules oluşturup tüm konfigürasyonu çalıştırabiliriz. Ingress’in bir Kubernetes clusterında nasıl kullanılabileceğini gösterdikten sonra, dış istekleri alabilmek için tüm clusterı ayarlama konusunun önemli olduğunu düşünüyorum.</p>
    <p>Öncelikle, Kubernetes clusterımızın çalıştığı ortamı düşünmeliyiz. Amazon Web Services, Google Cloud gibi bir cloud service provider kullanıyorsak, bu sağlayıcının sağladığı bir yük loadbalancer kullanabiliriz. Dış istekler önce bu loadbalancer’a ulaşır, ardından Ingress controller’a yönlendirilir. <code>Cloud Service Provider</code> kullanmanın avantajı, kendi loadbalancer’ımızı uygulamak zorunda olmamamızdır. Bu, loadbalancer işlemini ve dış isteklerin yönlendirilmesini daha kolay hale getirir. Ancak, bulut ortamında bile farklı yollarla yapılandırma yapabiliriz, fakat bu yöntem en yaygın stratejilerden biridir.</p>
    <p>Şimdi, Kubernetes clusterımızı <code>bare metal</code> bir ortamda dağıtıyorsak, bu kısmı kendimiz yapmamız gerekecek.</p>
    <p>Kubernetes clusterımıza bir entry point yapılandırmamız gerekecektir ve bunu yapmanın birçok farklı yolu vardır. Cluster içinde veya dışında ayrı bir sunucu olarak bir entry point sağlamamız gerekecektir.</p>
    <ul>
    <li>Bu entry point, yazılım veya donanım çözümü olabilecek harici bir proxy sunucusu olabilir ve clustera entry point olarak loadbalancer rolünü üstlenir.</li>
    </ul>
    <p><img src="images/161.png" /></p>
    <ul>
    <li>Temel olarak, bu şu anlama gelir: Ayrı bir sunucuya sahip olacağız ve bu sunucuya bir genel IP adresi vereceğiz, gelen isteklerin kabul edilmesi için portları açacağız. Bu proxy sunucu, clusterımıza tek entry point olarak işlev görecek, yani Kubernetes clusterımızdaki hiçbir sunucu genel olarak erişilebilir bir IP adresine sahip olmayacaktır, bu da oldukça iyi bir güvenlik uygulamasıdır. Tüm istekler proxy sunucuya girecek ve bu, isteği Ingress controller’a yönlendirecektir. Ingress controller daha sonra bu belirli istek için hangi Ingress kuralının(rule) geçerli olduğunu belirleyecek ve tüm internal istek yönlendirmesi gerçekleşecektir.</li>
    </ul>
    <p><img src="images/162.png" /></p>
    <p>Söylediğimiz gibi farklı ortam ve yaklaşımlara bağlı olarak bunu yapılandırmanın ve ayarlamanın farklı yolları vardır, ancak clusterın nasıl çalıştığını anlamak önemlidir.</p>
    <h3 id="minikube-ingress-konfigürasyonu">Minikube Ingress Konfigürasyonu</h3>
    <p><img src="images/163.png" /></p>
    <p>Biz tüm bunları dizüstü bilgisayarımızda Minikube kullanarak yapacağımız için kurulum oldukça basit olacak ve bu, cluster ayarlarımıza tam olarak uygulanmasa bile, tüm bu şeylerin pratikte nasıl çalıştığını görmüş olacağız. İlk olarak, Minikube’da Ingress controller’ı kurmak gerekiyor ve bunu yapmak için şu komutu çalıştırabiliriz:</p>
    <div class="sourceCode" id="cb82"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true"></a><span class="ex">minikube</span> addons enable ingress</span></code></pre></div>
    <p>Bu komut, <code>Kubernetes NGINX Ingress controller</code>’ı otomatik olarak başlatır ve yapılandırır. Bu, Minikube’un <code>out of the box</code> özelliğidir ve üretim ortamlarında da güvenle kullanılabilir. Bu komut ile Ingress controller clusterımızda yapılandırılacak ve:</p>
    <div class="sourceCode" id="cb83"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true"></a><span class="ex">kubectl</span> get pod -n kube-system</span></code></pre></div>
    <p>komutunu çalıştırarak Ingress controller pod’unun çalıştığını görebiliriz.</p>
    <p><img src="images/164.png" /></p>
    <p>Ingress controller kurulduktan sonra, Ingress controller’ın kullanacağı bir Ingress kuralı oluşturabiliriz.</p>
    <blockquote>
    <p> Eğer <code>kubernetes-dashboard</code> componenti yoksa şu komutla indirebilirsiniz</p>
    <div class="sourceCode" id="cb84"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true"></a><span class="ex">kubectl</span> apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml</span></code></pre></div>
    <p>Bu komut, Kubernetes Dashboard için gerekli kaynakları oluşturur.</p>
    </blockquote>
    <p>Şu an minikube clusterında harici olarak erişilebilir olmayan bir <code>kubernetes-dashboard</code> var. İç hizmet ve pod zaten mevcut olduğundan, Kubernetes dashboard için bir Ingress kuralı yapılandıracağız, böylece bir tarayıcıdan bir alan adı kullanarak erişebiliriz.</p>
    <div class="sourceCode" id="cb85"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true"></a><span class="ex">kubectl</span> get all -n kubernetes-dashboard</span></code></pre></div>
    <p>Bu komut kubernetes-dashboard’daki tüm componentleri gösterir.</p>
    <p><img src="images/165.png" /></p>
    <div class="sourceCode" id="cb86"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true"></a><span class="ex">service/kubernetes-dashboard</span>        ClusterIP   10.104.100.94   <span class="op">&lt;</span>none<span class="op">&gt;</span>        443/TCP    28s</span></code></pre></div>
    <p>Kubernetes Dashboard için zaten bir internal servisimiz ve çalışan bir pod’umuz olduğu için, Kubernetes Dashboard’a erişmek amacıyla bir Ingress kuralı oluşturabiliriz. Hadi bunu yapalım.</p>
    <p>Kubernetes Dashboard için bir Ingress oluşturacağım. ,</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: dashboard-ingress
      namespace: kubernetes-dashboard
    spec:
      rules:
        </code></pre>
    </div>
</div>

    <p>Bunlar sadece metadata. * <code>name:</code> <code>dashboard-ingress</code> olacak., * <code>namespace:</code> hizmetin ve pod’un olduğu aynı namespace olacak. * <code>spec:</code> içerisinde kuralları tanımlayacağız.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: dashboard-ingress
      namespace: kubernetes-dashboard
    spec:
      rules:
      - host: dashboard.com
        http:
          paths:
          - backend:
              serviceName: kubernetes-dashboard
              servicePort: 80
        </code></pre>
    </div>
</div>

    <ul>
    <li>İlk kuralımız, <code>host:</code> olacak. <code>dashboard.com</code> olarak tanımladık.</li>
    <li><code>http</code> forwarding, internal servise yapılacak.</li>
    <li><code>paths:</code>’ i (all path) olarak bıraktık.</li>
    <li><code>backend:</code>, servisin backend’i olacak.</li>
    <li><code>servicename</code>, az önceki çıktıda gördüğümüz servis adı.</li>
    <li><code>servicePort:</code> ise servisin dinlediği port. Bunu da az önce paylaştığım çıktıda görüyoruz. <code>80/TCP</code></li>
    </ul>
    <p>Bu, Ingress konfigürasyonumuz olacak ve dashboard.com’a yönlendirilen her isteği, internal <code>kubernetes-dashboard</code> servisine yönlendirecek. Internal Servis olduğunu biliyoruz çünkü türü <code>ClusterIP</code>, yani External IP adresi yok.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
NAME                                TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
    service/kubernetes-dashboard        ClusterIP   10.101.218.170   <none>        80/TCP     82m
        </code></pre>
    </div>
</div>

    <p>Bu arada<code>dashboard.com</code> hostnamei uydurduk, hiçbir yere kaydedilmedi ve ayrıca bu hostname’in hangi IP adresine çözülmesi gerektiğini hiçbir yere yapılandırmadık. Bu, her zaman yapılandırmamız gereken bir şeydir.</p>
    <p>Şimdi bu Ingress rule’u apply edelim.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectl apply -f dashboard-ingress.yaml
        </code></pre>
    </div>
</div>

    <blockquote>
      <blockquote>
        <p><strong></strong> Eğer oluştururken şu hatayı alırsanız:</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl apply -f dashboard-ingress.yaml Error from server (InternalError):
            error when creating "dashboard-ingress.yaml": Internal error occurred: failed calling
            webhook "validate.nginx.ingress.kubernetes.io": failed to call webhook: Post <br>
            "https://ingress-nginx-controller-admission.ingress-nginx.svc:443/networking/v1/ingresses?timeout=10s": service "ingress-nginx-controller-admission" not found
        </code></pre>
    </div>
</div>

        <p>Yapmanız gereken şey şu komutu kullanmaktır. Gereken <code>ingress-nginx-controller</code> indirilecek.</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/cloud/deploy.yaml
        </code></pre>
    </div>
</div>

      </blockquote>
      <blockquote>
        <p><strong></strong> <code>ingress-nginx-controller</code> oluşturduktan sonra da şöyle bir hata alırsanız eğer:</p>
<div class="window">
    <div class="window-header">
        <div class="buttons">
            <span class="button red"></span>
            <span class="button yellow"></span>
            <span class="button green"></span>
        </div>
        <span class="filename">~</span>
    </div>
    <div class="window-content">
        <pre><code class="language-shell">
c3ng0@ubn:~$ kubectl apply -f dashboard-ingress.yaml Error from server (InternalError): error when creating "dashboard-ingress.yaml": Internal error occurred:<br> failed calling webhook "validate.nginx.ingress.kubernetes.io": failed to call webhook: Post
"https://ingress-nginx-controller-admission.ingress-nginx.svc:443/networking/v1/ingresses?timeout=10s": service "ingress-nginx-controller-admission" not found
        </code></pre>
    </div>
</div>

        <p>Bunun çözümü sadece biraz beklemek. Çünkü yeni oluşturduğumuz servisin oluşması biraz zaman alabilir 😁😁</p>
      </blockquote>

    </blockquote>
    <p><img src="images/166.png" /></p>
    <p>Ingress oluşturuldu. Namespace’te Ingress’i görmeliyiz. Adresin boş olduğunu görebiliriz çünkü Ingress’e adres ataması biraz zaman alır. Bu hostname’e eşlenecek IP adresini almak için beklememiz gerekecek.</p>
    <p>Adresi aldıktan sonra bu adresi aşağıdaki şekilde hosts dosyamızda tanımlıyoruz.</p>
    <p><img src="images/167.png" /></p>
    <p>Bu yerel olarak çalışır, tarayıcıda dashboard.com yazarsak, bu IP adresine eşlenecek ve istek Minikube clustera gelecek, Ingress controller’a teslim edilecek ve Ingress controller bu kuralı değerlendirip isteği servise yönlendirecek. İhtiyacımız olan tüm konfigürasyon bu.</p>
    <p>Şimdi gidip tarayıcıya <code>dashboard.com</code> yazacağız ve Kubernetes Dashboard’umuzu burada göreceğiz.</p>
    <p><img src="images/168.png" /></p>
    <h3 id="ingress-default-backend">Ingress Default Backend</h3>
    <p>Ingress ayrıca <code>default backend</code> adlı bir şeye sahiptir, bu nedenle <code>kubectl describe Ingress</code> komutunu kullanarak Ingress’in adını ve namespace’ini belirttiğinizde şu çıktıyı elde edersiniz.</p>
    <div class="sourceCode" id="cb94"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true"></a><span class="ex">kubectl</span> describe ingress dashboard-ingress -n kubernetes-dashboard</span></code></pre></div>
    <p><img src="images/169.png" /></p>
    <p>Burada, 80 numaralı <code>default-http-backend</code> portuna eşlenen bir <code>default backend</code> attribute’u vardır. Bu, Kubernetes clusterına gelen ve herhangi bir backend’e eşlenmeyen istekleri ele alır, yani bu isteği bir servise eşlemek için herhangi bir kural bulunmayan bir istek olduğunda, bu <code>default backend</code>’in bu isteği işleyeceği anlamına gelir. Bu servisi clusterımız içinde oluşturup tanımlamazsak, Kubernetes bu servise yönlendirmeye çalışacak, bulamayacak ve bir varsayılan hata yanıtı alacağız.</p>
    <p>Örneğin, konfigüre etmediğimiz bir adrese istek gönderirsek, sadece “sayfa bulunamadı” mesajını alırız.</p>
    <p><img src="images/170.png" /></p>
    <p>Bu, sayfa bulunamadığında özel hata mesajları tanımlamak veya gelen ve uygulamanızın işleyemeyeceği istekler geldiğinde kullanıcıların anlamlı bir hata mesajı veya özel bir sayfa görmesini sağlamak için kullanılabilir; böylece kullanıcıları ana sayfamıza yönlendirebiliriz.</p>
    <p><strong>Özetle</strong> Şimdiye kadar Ingress’in ne olduğunu ve nasıl kullanabileceğimizi gördük. Ayrıca Minikube’da bir Ingress kuralının nasıl oluşturulacağına dair bir demo da yaptık, ancak sadece çok temel bir Ingress yaml konfigürasyonu kullandık; sadece bir path ile bir internal servise basit bir yönlendirme yaptık. Ancak Ingress configuration ile sadece temel yönlendirmeden çok daha fazlasını yapabiliriz.</p>
    <h3 id="multiple-paths-for-same-host">Multiple paths for Same Host</h3>
    <p>Şu use case’i düşünelim: Google bir domaine sahip ama birden fazla hizmet sunmaktadır. Örneğin, bir Google hesabımız varsa, Google Analytics’i kullanabiliriz, alışveriş yapabiliriz, bir takvime sahip olabiliriz, Gmail’e sahip olabiliriz vb.. Tüm bunlar, aynı domaine erişilebilen farklı uygulamalardır. Buna benzer bir uygulamamız olduğunu düşünelim; aynı ekosistemin bir parçası olan iki ayrı uygulama sunuyoruz. Ancak bunları ayrı URL’lerde tutmak istiyoruz.</p>
    <ul>
    <li>Yapabileceğimiz şey, “rule” içinde Hostu tanımlamaktır: <code>myapp.com</code>. Path bölümünde birden fazla yol tanımlayabiliriz. Kullanıcı, analytics uygulamamıza erişmek isterse, myapp.com/analytics adresini girmesi gerekecek ve bu, isteği pod içindeki internal analytics servise yönlendirecektir. Veya alışveriş uygulamasına erişmek isterse, URL myapp.com/shopping olacaktır. Bu şekilde, tek bir Host ve bir Ingress ile, birden fazla uygulamaya yönlendirme yapabiliriz.</li>
    </ul>
    <p><img src="images/171.png" /></p>
    <p>Başka bir use case ise, bazı şirketlerin farklı uygulamaları erişilebilir kılmak için URL’leri kullanmak yerine sub-domains kullanmasıdır. Yani, myapp.com/analytics yerine, bir sub-domain oluştururlar: analytics.myapp.com. Uygulamamız bu şekilde yapılandırılmışsa, şu şekilde görünecektir:</p>
    <p><img src="images/172.png" /></p>
    <p>önceki örnekteki gibi tek bir host ve birden fazla path yerine, burada birden fazla host olur ve her host bir subdomaini temsil eder.</p>
    <h3 id="tls-certificate-konfigürasyonu">TLS Certificate Konfigürasyonu</h3>
    <p>Bu başlıkta ele alacağımız son konu, TLS sertifikası yapılandırmasıdır. Şimdiye kadar sadece HTTP istekleri için Ingress yapılandırması gördük, ancak Ingress’te HTTPS yönlendirmeyi yapılandırmak da çok kolaydır. Yapmamız gereken tek şey, <code>rules</code> bölümünün üstüne TLS adında bir özellik tanımlamak, host değeri, aynı hostu <code>myapp.com</code> ve bir TLS sertifikasını içeren oluşturduğumuz secret’ın adını belirtmektir. Ingress ve Secret konfigürasyonu şu şekilde olacaktır:</p>
    <p><img src="images/173.png" /></p>
    <ul>
    <li><code>name</code> bir referanstır.</li>
    <li><code>data</code> TLS sertifikası ve TLS anahtarını içerir.</li>
    </ul>
    <p>Önceki konulardan hatırlarsanız, <code>type</code> belirtiyorduk. Kubernetes’te TLS adında belirli bir secret türü, TLS secret’ı oluştururken bu türü kullanmamız gerekiyor.</p>
    <p>Burada tutulması gereken üç küçük not var: * Birincisi, bu verilerin anahtarlarının tam olarak bu şekilde adlandırılması gerektiğidir. <code>tls.crt</code>, <code>tls.key</code>. * İkincisi, bu değerler, sertifika veya anahtar içeriklerinin kendisidir, dosya yolu veya konumu değil, bu nedenle tüm içeriği buraya base64 kodlamamız gerekiyor. * Üçüncüsü, secret’ı, Ingress bileşeniyle aynı <code>namespace</code> ile oluşturmamız gerekiyor. Aksi takdirde, farklı bir namespace’teki bir secret’a referans veremeyiz.</p>





  </div>
</body>
</html>
